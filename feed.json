{
  "version": "https://jsonfeed.org/version/1.1",
  "title": "RiverCold",
  "home_page_url": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/",
  "feed_url": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/feed.json",
  "description": "Welcome to RiverCold's blog!",
  "author": {
    "name": "RiverCold"
  },
  "items": [
    {
      "title": "1.md",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/code/C++/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/code/C++/",
      "content_html": "<h1 id=\"_1-md\"> 1.md</h1>\n<p>C++!</p>\n",
      "date_published": "2022-04-04T14:19:55.000Z",
      "date_modified": "2022-04-04T14:19:55.000Z",
      "authors": [
        {
          "name": "RiverCold"
        }
      ],
      "tags": []
    },
    {
      "title": "1.md",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/code/Java/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/code/Java/",
      "content_html": "<h1 id=\"_1-md\"> 1.md</h1>\n<p>Java!</p>\n",
      "date_published": "2022-04-04T14:19:55.000Z",
      "date_modified": "2022-04-04T14:19:55.000Z",
      "authors": [
        {
          "name": "RiverCold"
        }
      ],
      "tags": []
    },
    {
      "title": "1.md",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/code/Python/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/code/Python/",
      "content_html": "<h1 id=\"_1-md\"> 1.md</h1>\n<p>Python!</p>\n",
      "date_published": "2022-04-04T14:19:55.000Z",
      "date_modified": "2022-04-04T14:19:55.000Z",
      "authors": [
        {
          "name": "RiverCold"
        }
      ],
      "tags": []
    },
    {
      "title": "1.md",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/code/SQL/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/code/SQL/",
      "content_html": "<h1 id=\"_1-md\"> 1.md</h1>\n<p>SQL!</p>\n",
      "date_published": "2022-04-04T14:19:55.000Z",
      "date_modified": "2022-04-04T14:19:55.000Z",
      "authors": [
        {
          "name": "RiverCold"
        }
      ],
      "tags": []
    },
    {
      "title": "项目主页",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/en/home/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/en/home/",
      "content_html": "<p>这是普通主页的案例。你可以在这里放置你的主体内容。</p>\n<p>想要使用此布局，你需要在页面 front matter 中设置 <code>home: true</code>。</p>\n<p>配置项的相关说明详见 <a href=\"https://vuepress-theme-hope.github.io/zh/guide/layout/home/\" target=\"_blank\" rel=\"noopener noreferrer\">项目主页配置</a>。</p>\n",
      "date_published": "2022-04-04T14:19:55.000Z",
      "date_modified": "2022-04-04T14:19:55.000Z",
      "authors": [
        {
          "name": "RiverCold"
        }
      ],
      "tags": []
    },
    {
      "title": "Intro Page",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/en/intro/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/en/intro/",
      "content_html": "<h1 id=\"intro-page\"> Intro Page</h1>\n<p>Place your introducation and profile here.</p>\n",
      "date_published": "2022-04-04T14:19:55.000Z",
      "date_modified": "2022-04-04T14:19:55.000Z",
      "authors": [
        {
          "name": "RiverCold"
        }
      ],
      "tags": []
    },
    {
      "title": "自定义布局",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/en/layout/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/en/layout/",
      "content_html": "<p>您可以使用带有 Markdown 支持的插槽来自定义页面布局。</p>\n<div><p>注意</p>\n<p>此处仅仅是一个演示，你应该自行根据需求添加样式。</p>\n\n\n</div>\n<template #page-top><p>页面顶部内容</p>\n</template><template #page-bottom><p>页面底部内容</p>\n</template><template #content-top><p>内容顶部内容</p>\n</template><template #content-bottom><p>内容底部内容</p>\n</template><template #navbar-start><p>导航栏起始内容</p>\n</template><template #navbar-center><p>导航栏中部内容</p>\n</template><template #navbar-end><p>导航栏末尾内容</p>\n</template><template #sidebar-top><p>侧边栏顶部内容</p>\n</template><template #sidebar-center><p>侧边栏中部内容</p>\n</template><template #sidebar-bottom><p>侧边栏底部内容</p>\n</template><p>更多详情，详见 <a href=\"https://vuepress-theme-hope.github.io/zh/guide/layout/custom/\" target=\"_blank\" rel=\"noopener noreferrer\">自定义布局</a>.</p>\n",
      "date_published": "2022-04-04T14:19:55.000Z",
      "date_modified": "2022-04-04T14:19:55.000Z",
      "authors": [
        {
          "name": "RiverCold"
        }
      ],
      "tags": []
    },
    {
      "title": "博客主页",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/en/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/en/",
      "content_html": "<p>这是一个博客主页。</p>\n<p>要使用此布局，您应该在页面前端设置 <code>blog: true</code> 和 <code>home: true</code>。</p>\n<p>相关配置文档请见 <a href=\"https://vuepress-theme-hope.github.io/zh/guide/blog/home/\" target=\"_blank\" rel=\"noopener noreferrer\">博客主页</a></p>\n",
      "date_published": "2022-04-04T14:19:55.000Z",
      "date_modified": "2022-04-04T14:19:55.000Z",
      "authors": [
        {
          "name": "RiverCold"
        }
      ],
      "tags": []
    },
    {
      "title": "幻灯片页",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/en/slides/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/en/slides/",
      "content_html": "\n<i>Not supported content</i>",
      "image": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/logo.svg",
      "date_published": "2022-04-04T14:19:55.000Z",
      "date_modified": "2022-04-04T14:19:55.000Z",
      "authors": [
        {
          "name": "RiverCold"
        }
      ],
      "tags": []
    },
    {
      "title": "项目主页",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/home/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/home/",
      "content_html": "<p>这是普通主页的案例。你可以在这里放置你的主体内容。</p>\n<p>想要使用此布局，你需要在页面 front matter 中设置 <code>home: true</code>。</p>\n<p>配置项的相关说明详见 <a href=\"https://vuepress-theme-hope.github.io/zh/guide/layout/home/\" target=\"_blank\" rel=\"noopener noreferrer\">项目主页配置</a>。</p>\n",
      "date_published": "2022-04-04T14:19:55.000Z",
      "date_modified": "2022-04-04T14:19:55.000Z",
      "authors": [
        {
          "name": "RiverCold"
        }
      ],
      "tags": []
    },
    {
      "title": "大数据面试题（By RiverCold）",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/interview/basics/bigdata/hadoop/hadoop-full/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/interview/basics/bigdata/hadoop/hadoop-full/",
      "content_html": "<h1 id=\"大数据面试题-by-rivercold\"> 大数据面试题（By RiverCold）</h1>\n<h2 id=\"hadoop\"> Hadoop</h2>\n<h3 id=\"hdaoop运行模式\"> Hdaoop运行模式</h3>\n<blockquote>\n<p><a href=\"https://blog.csdn.net/zane3/article/details/79829175\" target=\"_blank\" rel=\"noopener noreferrer\">Hadoop运行模式</a>包括：本地模式、伪分布式模式以及完全分布式模式。</p>\n<ol>\n<li>本地模式：单机运行。使用本地文件系统和本地MapReduce运行器，不需要HDFS和YARN守护进程。</li>\n<li>伪分布式模式：单机运行。Hadoop守护进程运行在本地机器上，模拟一台机器的Hadoop集群伪分布式是完全分布式的一个特例。</li>\n<li>完全分布式模式：多台服务器组成分布式环境Hadoop守护进程运行在一个集群上。</li>\n</ol>\n</blockquote>\n<h3 id=\"hadoop1-x、2-x、3-x区别\"> Hadoop1.x、2.x、3.x区别</h3>\n<blockquote>\n<ol>\n<li>Hadoop1.x时代：Hadoop中的MapReduce同时处理业务计算和资源调度，耦合性较大。</li>\n<li>Hadoop2.x时代：增加了YarnMapReduce只负责业务计算，Yarn只负责资源调度。</li>\n<li>Hadoop3.x时代：相较于Hadoop2.x时代在组成上没有变化，但较大优化了已有组件，引入了新的功能。</li>\n</ol>\n</blockquote>\n<h3 id=\"hadoop三大基本组件\"> Hadoop三大基本组件</h3>\n<blockquote>\n<ol>\n<li><a href=\"https://baike.baidu.com/item/hdfs\" target=\"_blank\" rel=\"noopener noreferrer\">HDFS</a>：Hadoop Distributed File System，简称HDFS，即Hadoop的分布式文件系统，负责海量数据的存储。</li>\n<li><a href=\"https://baike.baidu.com/item/yarn\" target=\"_blank\" rel=\"noopener noreferrer\">YARN</a>：Yet Another Resource Negotiator，简称YARN，即Hadoop的资源管理器，负责海量数据计算时的资源调度。</li>\n<li><a href=\"https://baike.baidu.com/item/MapReduce/133425?fr=aladdin\" target=\"_blank\" rel=\"noopener noreferrer\">MapReduce</a>：MapReduce将计算过程分为两个阶段Map和Reduce，即Hadoop的并行计算系统，负责海量数据的并行计算。\n<ol>\n<li>Map（映射）阶段并行处理输入数据</li>\n<li>Reduce（归约）阶段对Map结果进行汇总</li>\n</ol>\n</li>\n</ol>\n</blockquote>\n<h3 id=\"hadoop生态圈\"> Hadoop生态圈</h3>\n<blockquote>\n<p>Hadoop生态圈包括Hadoop框架本身和保证hadoop框架正常高效运行的其他框架。根据服务对象和层次可以分为：数据来源层、数据传输层、数据存储层、资源管理层、数据计算层、任务调度层、业务模型层</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2021/png/21953026/1629386282142-70da2bfc-7170-4d52-8061-59ebaf8446d3.png\" alt=\"\" loading=\"lazy\"></p>\n<p>图中涉及的技术名词解释如下：</p>\n<ol>\n<li>Sqoop（数据传递工具）：是SQL-to-Hadoop的缩写，主要用于在Hadoop(Hive)与传统的数据库(mysql、postgresql...)间进行数据的传递，可以将一个关系型数据库（例如 ： MySQL ,Oracle 等）中的数据导进到Hadoop的HDFS中，也可以将HDFS的数据导进到关系型数据库中</li>\n<li>Flume（日志收集工具）：一个高可用的，高可靠的，分布式的海量日志采集、聚合和传输的系统</li>\n<li>HBase（分布式列存储数据库）：一个分布式、面向列的开源数据库HBase不同于一般的关系型数据库，它是一个适合于非结构化数据存储的数据库</li>\n<li>Hive（数据仓库工具）：基于Hadoop的一个数据仓库工具，可以把结构化的数据文件映射成一张数据库表，并提供简单的SQL查询功能，可以将SQL语句转换为MapReduce任务进行运行适合数据仓库的统计分析</li>\n<li>Spark（分布式计算框架）：当前最流行的开源大数据内存计算框架可以基于Hadoop上存储的大数据进行计算不同于MapReduce的是Job中间输出结果可以保存在内存中，从而不再需要读写HDFS，因此Spark能更好地适用于数据挖掘与机器学习等需要迭代计算的算法</li>\n<li>Flink（分布式计算框架）：当前最流行的开源大数据内存计算框架用于实时计算的场景较多</li>\n<li>Oozie（工作流调度器）：一个管理Hadoop作业（job）的工作流程调度管理系统</li>\n<li>Zookeeper（分布式协作服务）：一个针对大型分布式系统的可靠协调系统，提供的功能包括：配置维护、名字服务、分布式服务、组服务等</li>\n</ol>\n</blockquote>\n<h2 id=\"hdfs\"> HDFS</h2>\n<h3 id=\"hdfs默认数据块的大小是多少-为什么\"> HDFS默认数据块的大小是多少？为什么？</h3>\n<blockquote>\n<p>HDFS中的文件在物理上是分块存储（block），块的大小可以通过配置参数( dfs.blocksize)来规定，默认块大小在Hadoop2.x版本中是128M，老版本中是64M</p>\n<p>HDFS的块大小取决于磁盘传输速率目前磁盘传输率约为100M/s，而HDFS读取文件时最佳的寻址时间为10ms，理论上寻址时间为传输时间的1%时最佳</p>\n<p>故最佳传输时间为</p>\n<p class='katex-block'><span><span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span>1</span><span>m</span><span>s</span><span style=\"margin-right:0.2222em;\"></span><span>×</span><span style=\"margin-right:0.2222em;\"></span></span><span><span style=\"height:0.6444em;\"></span><span>1000</span><span style=\"margin-right:0.2778em;\"></span><span>=</span><span style=\"margin-right:0.2778em;\"></span></span><span><span style=\"height:0.6444em;\"></span><span>1000</span><span>m</span><span>s</span><span style=\"margin-right:0.2778em;\"></span><span>=</span><span style=\"margin-right:0.2778em;\"></span></span><span><span style=\"height:0.6444em;\"></span><span>1</span><span>s</span></span></span></span></span></p>\n<p>块的最佳大小=最佳传输时间×磁盘传输速率：</p>\n<p class='katex-block'><span><span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span>1</span><span>s</span><span style=\"margin-right:0.2222em;\"></span><span>×</span><span style=\"margin-right:0.2222em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>100</span><span style=\"margin-right:0.10903em;\">M</span><span>/</span><span>s</span><span style=\"margin-right:0.2778em;\"></span><span>=</span><span style=\"margin-right:0.2778em;\"></span></span><span><span style=\"height:0.6833em;\"></span><span>100</span><span style=\"margin-right:0.10903em;\">M</span></span></span></span></span></p>\n<p>所以定义块大小为128M</p>\n</blockquote>\n<h3 id=\"为什么hdfs块的大小不能设置太小-也不能设置太大\"> 为什么HDFS块的大小不能设置太小，也不能设置太大？</h3>\n<blockquote>\n<p>如果HDFS的块设置太小，会增加寻址时间，程序一直在找块的开始位置；</p>\n<p>如果块设置的太大，从磁盘传输数据的时间会明显大于定位这个块开始位置所需的时间导致程序在处理这块数据时，会非常慢；</p>\n<p>总结：HDFS块的大小设置主要取决于磁盘的传输速率</p>\n</blockquote>\n<h3 id=\"hdfs组成架构-hdfs如何存储文件\"> HDFS组成架构？(HDFS如何存储文件)</h3>\n<blockquote>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2021/png/21953026/1631347406286-eed355fb-e2b1-4249-8e84-528c3f7b24f2.png\" alt=\"img\" loading=\"lazy\"></p>\n<p>架构由4个部分组成，分别为HDFS Client、NameNode、DataNode和Secondary NameNode</p>\n<ol>\n<li>Client：客户端\n<ol>\n<li>文件切分文件上传HDFS的时候，客户端将文件切分成一个一个的块Block，然后进行上传</li>\n<li>与NameNode交互，获取文件的位置信息；</li>\n<li>与DataNode交互，读取或者写入数据；</li>\n<li>提供一些命令来管理HDFS，比如NameNode格式化；</li>\n<li>通过一些命令来访问HDFS，比如对HDFS增删改查操作；</li>\n</ol>\n</li>\n<li>NameNode：就是Master，它是一个主管、管理者\n<ol>\n<li>管理HDFS的名称空间；</li>\n<li>配置副本策略；</li>\n<li>管理数据块（Block）映射信息；</li>\n<li>处理客户端读写请求；</li>\n</ol>\n</li>\n<li>DataNode：就是Slave，NameNode下达命令，DataNode执行实际操作\n<ol>\n<li>存储实际的数据块；</li>\n<li>执行数据块的读/写操作；</li>\n</ol>\n</li>\n<li>Secondary NameNode：并非NameNode的热备份，当NameNode挂掉的时候，它并不能马上替换NameNode并提供服务\n<ol>\n<li>辅助NameNode，分担其工作量；</li>\n<li>在紧急情况下，可辅助恢复NameNode；</li>\n</ol>\n</li>\n</ol>\n</blockquote>\n<h3 id=\"hdfs的写数据流程\"> HDFS的写数据流程？</h3>\n<blockquote>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2021/png/21953026/1631349353957-8a9426dd-7a91-41b0-8775-fde95c162a13.png\" alt=\"img\" loading=\"lazy\"></p>\n<ol>\n<li>客户端通过Distributed FileSystem模块向NameNode请求上传文件，NameNode检查目标文件是否存在，父目录是否存在</li>\n<li>NameNode返回是否可以上传</li>\n<li>客户端请求第一个Block上传到哪几个datanode服务器上</li>\n<li>NameNode返回3个DataNode节点，分别为dn1、dn2、dn3</li>\n<li>客户端通过FSDataOutputStream模块请求dn1上传数据，dn1收到请求会继续调用dn2，然后dn2调用dn3，将这个通信管道建立完成。</li>\n<li>dn1、dn2、dn3逐级应答客户端</li>\n<li>客户端开始往dn1上传第一个Block（先从磁盘读取数据放到一个本地内存缓存，以Packet为单位，dn1收到一个Packet就会传给dn2，dn2传给dn3；dn1每传一个packet会放入一个应答队列等待应答）</li>\n<li>当第一个Block传输完成之后，客户端再次请求NameNode上传第二个Block的服务（重复执行3-7步）</li>\n</ol>\n</blockquote>\n<h3 id=\"hdfs的读数据流程\"> HDFS的读数据流程？</h3>\n<blockquote>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2021/png/21953026/1631460280331-5e9c5202-71a1-4a1a-a1b8-6c5a188de260.png?x-oss-process=image%2Fresize%2Cw_902%2Climit_0\" alt=\"img\" loading=\"lazy\"></p>\n<ol>\n<li>客户端通过Distributed FileSystem向NameNode请求下载文件，NameNode通过查询元数据，找到文件块所在的DataNode地址</li>\n<li>挑选一台DataNode（就近原则，然后随机）服务器，请求读取数据</li>\n<li>DataNode开始传输数据给客户端（从磁盘里面读取数据输入流，以Packet为单位来做校验）</li>\n<li>客户端以Packet为单位接收，先在本地缓存，然后写入目标文件</li>\n</ol>\n</blockquote>\n<h3 id=\"nn和2nn工作机制-了解\"> NN和2NN工作机制（了解）</h3>\n<blockquote>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2021/png/21953026/1631626177178-b9e3267a-e398-4d91-98fe-ee44df7183cb.png\" alt=\"img\" loading=\"lazy\"></p>\n<p><strong>第一阶段：NameNode启动</strong></p>\n<ol>\n<li>第一次启动NameNode格式化，创建Fsimage和Edits文件。如果不是第一次启动，直接加载编辑日志和镜像文件到内存。</li>\n<li>客户端对元数据进行增删改的请求。</li>\n<li>NameNode记录操作日志，更新滚动日志。</li>\n<li>NameNode在内存中对元数据进行增删改。</li>\n</ol>\n<p><strong>第二阶段：Secondary NameNode工作</strong></p>\n<ol>\n<li>Secnodary NameNode询问NameNode是否需要CheckPoint。直接带回NameNode是否检查结果。</li>\n<li>Secondary NameNode请求执行CheckPoint。</li>\n<li>NameNode滚动正在写的Edits日志。</li>\n<li>将滚动前的编辑日志和镜像文件拷贝到Secondary NameNode。</li>\n<li>Secondary NameNode加载编辑日志和镜像文件到内存，并合并。</li>\n<li>生成新的镜像文件fsimage.chkpoint。</li>\n<li>拷贝fsimage.chkpoint到NameNode。</li>\n<li>NameNode将fsimage.chkpoint重新命名成fsimage。</li>\n</ol>\n</blockquote>\n<h3 id=\"datanode工作机制-了解\"> DataNode工作机制（了解）</h3>\n<blockquote>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2021/png/21953026/1631540997938-34f4d0f3-af51-4a61-94f4-be7993ff6ee5.png?x-oss-process=image%2Fresize%2Cw_1182%2Climit_0\" alt=\"img\" loading=\"lazy\"></p>\n<ol>\n<li>\n<p>一个数据块在DataNode上以文件形式存储在磁盘上，包括两个文件，一个是数据本身，一个是元数据包括数据块的长度，块数据的检验和，时间戳。</p>\n</li>\n<li>\n<p>DataNode启动后向NameNode注册，通过后，周期性（6小时）的向NameNode上报所有的块信息。</p>\n<p>DN向NN汇报当前解读信息的时间间隔，默认6小时</p>\n<p>DN扫描自己节点块信息列表的时间，默认6小时</p>\n<ol>\n<li>心跳是每3秒一次，心跳返回结果带有NameNode给该DataNode的命令如复制块数据到另一台机器，或删除某个数据块。如果超过10分钟没有收到某个DataNode的心跳，则认为该节点不可用。</li>\n<li>集群运行中可以安全加入和退出一些机器。</li>\n</ol>\n</li>\n</ol>\n</blockquote>\n<h2 id=\"mapreduce\"> MapReduce</h2>\n<h3 id=\"谈谈hadoop序列化和反序列化以及自定义bean对象实现序列化\"> 谈谈Hadoop序列化和反序列化以及自定义bean对象实现序列化</h3>\n<blockquote>\n<p><strong>序列化和反序列化</strong></p>\n<ol>\n<li>\n<p>序列化就是把内存中的对象，转换成字节序列（或其他数据传输协议）以便于存储（持久化）和网络传输</p>\n</li>\n<li>\n<p>反序列化就是将受到字节序列（或其他数据传输协议）或者是硬盘的持久化数据，转换成内存中的对象。</p>\n</li>\n</ol>\n<p><strong>为什么要序列化？</strong></p>\n<p>一般来说，“活的”对象只生存在内存里，关机断电就没有了。而且“活的”对象只能由本地的进程使用，不能被发送到网络的另外一台计算机。然后序列化可以存储“活的”对象，可以将“活的”对象发送到远程计算机。</p>\n<p><strong>为什么不用Java序列化？</strong></p>\n<p>Java的序列化是一个重量级序列化框架（Serializable），一个对象被序列化后，会附带很多额外的信息（各种校验信息，head，继承体系等），不便于在网络中高效传输。所以，hadoop自己开发了一套序列化机制（Writable），精简高效。</p>\n<p><strong>自定义bean对象序列化传输步骤及注意事项</strong></p>\n<ol>\n<li>必须实现Writable接口</li>\n<li>反序列化时，需要反射调用空参构造函数，所以必须有空参构造</li>\n<li>重写序列化方法</li>\n<li>重写反序列化方法</li>\n<li>注意反序列化的顺序和序列化的顺序完全一致</li>\n<li>要想把结果显示在文件中，需要重写toString()，且用&quot;\\t&quot;分开，方便后续使用</li>\n<li>如果需要将自定义的bean放在key中传输，则还需要实现comparable接口，因为mapreduce框中的shuffle过程一定会对key进行排序</li>\n</ol>\n</blockquote>\n<h3 id=\"fileinputformat切片机制\"> FileInputFormat切片机制</h3>\n<blockquote>\n<div><pre><code>waitForCompletion()\nsubmit()\n1、建立连接\n\tconnect()\n\t1、创建提交job的代理\n\t\tnew Cluster(getConfiguration())\n\t2、判断是本地yarn还是远程\n\t\tinitialize(jobTrackAddr,conf)\n2、提交job\nsubmitter.submitJobInternal(Job.this, cluster)\t\n\t1、创建给集群提交数据的stag路径\n\tPath jobStagingArea = JobSubmissionFiles.getStagingDir(cluster, conf);\n\t2、获取jobid，并创建job路径\n\tJobID jobid = submitClient.getNewJobID();\n\t3、拷贝jar包到集群\n\tcopyAndConfigureFiles(job, submitJobDir);\n\trUploader.uploadFiles(job, jobSubmitDir);\n\t4、计算切片,生成切片规划文件\n\twriteSplits(job, submitJobDir)\n\tmaps = writeNewSplits(job, jobSubmitDir);\n\tinput.getSplits(job);\n\t5、向stag路径写xml配置文件\n\twriteConf(conf, submitJobFile);\n\tconf.writeXml(out);\n\t6、提交job，返回提交状态\n\tstatus = submitClient.submitJob(jobId, submitJobDir.toString(), job.getCredentials());\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div></blockquote>\n<h3 id=\"在一个运行的hadoop任务中-什么是inputsplit\"> 在一个运行的Hadoop任务中，什么是InputSplit?</h3>\n<blockquote>\n<p>FileInputFormat源码解析（input.getSplits(job))</p>\n<ol>\n<li>找到数据存储的目录</li>\n<li>开始遍历处理（规划切片）目录下的每一个文件</li>\n<li>遍历第一个文件（假设为ss.txt）\n<ol>\n<li>获取文件大小<code>fs.sizeOf(ss.txt)</code></li>\n<li>计算切片大小<code>computeSliteSize(Math.max(minSize,Math.min(maxSize,blocksize)))=blocksize=128M</code></li>\n<li>默认情况下，切片大小=blocksize</li>\n<li>开始切，形成3个切片（每次切片时，都要判断切完剩下的部分是否大于块的1.1倍，不大于1.1倍就划分一块切片）\n<ol>\n<li>第1个切片：ss.txt—0-128M</li>\n<li>第2个切片：ss.txt—128-256M</li>\n<li>第3个切片：ss.txt—256M-300M</li>\n</ol>\n</li>\n<li>将切片信息写到一个切片规划文件中</li>\n<li>整个切片的核心过程在getSplit()方法中完成</li>\n<li>数据切片只是在逻辑上对输入数据进行分片，并不会在磁盘上将其切分成分片进行存储。InputSplit只记录了分片的元数据信息，比如起始位置、长度以及所在的节点列表等。</li>\n<li>注意：block是HDFS上物理上存储的数据，切片是对数据逻辑上的划分</li>\n</ol>\n</li>\n<li>提交切片规划文件到yarn上，yarn上的MrAppMaster就可以根据切片规划文件计算开启maptask个数</li>\n</ol>\n</blockquote>\n<h3 id=\"如何判定一个job的map和reduce的数量\"> 如何判定一个job的map和reduce的数量？</h3>\n<blockquote>\n<ol>\n<li>\n<p>map数量</p>\n<p><code>splitSize=max{minSize,min{maxSize,blockSize}}</code></p>\n<p>map数量由处理的数据分成的block数量决定<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1.0044em;vertical-align:-0.31em;\"></span><span>d</span><span>e</span><span style=\"margin-right:0.10764em;\">f</span><span>a</span><span>u</span><span>lt</span><span style=\"margin-right:0.02778em;\">_</span><span>n</span><span>u</span><span>m</span><span style=\"margin-right:0.2778em;\"></span><span>=</span><span style=\"margin-right:0.2778em;\"></span></span><span><span style=\"height:1.06em;vertical-align:-0.31em;\"></span><span>t</span><span>o</span><span>t</span><span>a</span><span style=\"margin-right:0.01968em;\">l</span><span style=\"margin-right:0.02778em;\">_</span><span>s</span><span>i</span><span>ze</span><span>/</span><span>s</span><span style=\"margin-right:0.01968em;\">pl</span><span>i</span><span>t</span><span style=\"margin-right:0.02778em;\">_</span><span>s</span><span>i</span><span>ze</span></span></span></span></p>\n</li>\n<li>\n<p>reduce数量</p>\n<p>reduce的数量<code>job.setNumReduceTasks(x)</code>；x为reduce的数量。不设置的话默认为1</p>\n</li>\n</ol>\n</blockquote>\n<h3 id=\"maptask的个数由什么决定\"> MapTask的个数由什么决定？</h3>\n<blockquote>\n<p>一个job的map阶段MapTask并行度（个数），由客户端提交job时的切片个数决定</p>\n</blockquote>\n<h3 id=\"maptask和reducetask工作机制-mapreduce工作原理\"> MapTask和ReduceTask工作机制（MapReduce工作原理）</h3>\n<blockquote>\n<p><strong>MapTask工作机制</strong></p>\n<ol>\n<li>Read阶段：Map Task通过用户编写的RecordReader，从输入InputSplit中解析出一个个key/value</li>\n<li>Map阶段：该节点主要是将解析出的key/value交给用户编写map()函数处理，并产生一系列新的key/value</li>\n<li>Collect收集阶段：在用户编写map()函数中，当数据处理完成后，一般会调用OutputCollector.collect()输出结果。在该函数内部，它会将生成的key/value分区（调用Partitioner），并写入一个环形内存缓冲区中。</li>\n<li>Spill阶段：即&quot;溢写&quot;，当环形缓冲区满后，MapReduce会先将数据写到本地磁盘上，生成一个临时文件。需要注意的是，将数据写入本地磁盘之前，先要对数据进行一次本地排序，并在必要时对数据进行合并、压缩等操作。</li>\n<li>Combine阶段：当所有数据处理完成后，MapTask对所有临时文件进行一次合并，以确保最终只会生成一个数据文件。</li>\n</ol>\n</blockquote>\n<blockquote>\n<p><strong>ReduceTask工作机制</strong></p>\n<ol>\n<li>Copy阶段：ReduceTask从各个MapTask上远程拷贝一片数据，并针对某一片数据，如果其大小超过一定阈值，则写到磁盘上，否则直接放到内存中</li>\n<li>Sort阶段：在远程拷贝数据的同时，ReduceTask启动了两个后台线程对内存和磁盘上的文件进行合并，以防止内存使用过多或磁盘上文件过多。按照MapReduce语义，用户编写reduce()函数输入数据是按key进行聚集的一组数据。为了将key相同的数据聚在一起，Hadoop采用了基于排序的策略。由于各个MapTask已经实现对自己的处理结果进行了局部排序，因为，ReduceTask只需对所有数据进行一次归并排序即可。</li>\n<li>Reduce阶段：reduce()函数将计算结果写到HDFS中</li>\n</ol>\n</blockquote>\n<h3 id=\"描述mapreduce有几种排序及排序发生的阶段\"> 描述mapReduce有几种排序及排序发生的阶段？</h3>\n<blockquote>\n<ol>\n<li>部分排序：MapReduce根据输入记录的键对数据集排序。保证输出的每个文件内部有序。</li>\n<li>全排序：最终输出结果只有一个文件，且文件内部有序。实现方式是只设置一个ReduceTask。但该方法在处理大型文件时效率极低，因为一台机器处理所有文件，完全丧失了MapReduce所提供的并行架构。</li>\n<li>辅助排序（GroupingComparator分组）：MapReduce框架在记录到达reducer之前按键对记录排序，但键所对应的值并没有被排序。甚至在不同的执行轮次中，这些值的排序也不固定，因为它们来自不同的map任务且这些map任务在不同轮次中完成时间各不相同。一般来说，大部分MapReduce程序会避免让reduce函数依赖于值的排序，但是，有时也需要通过特定的方法对键进行排序和分组等以实现对值的排序。</li>\n<li>二次排序：在自定义排序过程中，如果compareTo中的判断条件为两个即为二次排序</li>\n</ol>\n<p><strong>自定义排序WritableComparable</strong></p>\n<p>bean对象实现WritableComparable接口重写compareTo方法，就可以实现排序</p>\n<div><pre><code>@Override\npublic int compareTo(FlowBean o){\n\t// 倒序排序，从大到小\n\treturn this.sumFlow &gt; o.getSumFlow() ? -1 : 1;\t\n}\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>排序发生的阶段</p>\n<ol>\n<li>一个是在map side发生在spill后partition前。</li>\n<li>一个是在reduce side发生在copy后reduce前。</li>\n</ol>\n</blockquote>\n<h3 id=\"描述mapreduce中shuffle阶段的工作流程-如何优化shuffle阶段\"> 描述mapReduce中shuffle阶段的工作流程，如何优化shuffle阶段</h3>\n<blockquote>\n<p>从Map产生输出开始到Reduce取得数据作为输入之前的过程称为shuffle</p>\n<p><strong>Map端Shuffle</strong></p>\n<p><strong>Collect（收集）阶段</strong>：将MapTask的结果收集输出到默认大小为100M的环形缓冲区，输出前对key进行分区的计算，默认Hash分区</p>\n<p><strong>Spill（溢写）阶段</strong>：当环形缓冲区的数据量达到一定的阈值时，将数据写入本地磁盘（在写入磁盘之前需要对数据进行一次排序的操作，如果配置了combiner，还会将有相同分区号和key的数据进行排序）</p>\n<p><strong>Merge（合并）阶段</strong>：把所有溢出的临时文件进行一次合并操作，以确保一个MapTask最终只产生一个中间数据文件</p>\n<p><strong>Reduce端shuffle</strong></p>\n<p><strong>Copy（复制）阶段</strong>：ReduceTask启动Fetcher线程到已经完成MapTask的节点上复制一份属于自己的数据</p>\n<p><strong>Merge阶段</strong>：在ReduceTask远程复制数据的同时，会在后台开启两个线程对内存和磁盘的数据文件进行合并操作。</p>\n<p><strong>Sort阶段</strong>：在对数据进行合并的同时，会进行归并排序操作，由于MapTask阶段已经对数据进行了局部的排序，ReduceTask只需保证Copy的数据的最终整体有效性即可</p>\n</blockquote>\n<h3 id=\"描述mapreduce中combiner的作用是什么-一般使用情景-哪些情况不需要combiner-以及combiner和reduce的区别\"> 描述mapReduce中combiner的作用是什么，一般使用情景，哪些情况不需要combiner，以及combiner和reduce的区别？</h3>\n<blockquote>\n<ol>\n<li>\n<p>Combiner的意义就是对每一个maptask的输出进行局部汇总，以减小网络传输量。</p>\n</li>\n<li>\n<p>Combiner能够应用的前提是不能影响最终的业务逻辑，而且，Combiner的输出kv应该跟reducer的输入kv类型相对应。</p>\n</li>\n<li>\n<p>Combiner和reducer的区别在于运行的位置。</p>\n<p>Combiner是在每一个maptask所在的节点运行；</p>\n<p>Reducer是接收全局所有Mapper的输出结果。</p>\n</li>\n</ol>\n</blockquote>\n<h3 id=\"hadoop的缓存机制\"> Hadoop的缓存机制</h3>\n<blockquote>\n<p>分布式缓存一个最重要的应用就是在进行join操作的时候</p>\n</blockquote>\n<h3 id=\"如何使用mapreduce实现两个表的join\"> 如何使用mapReduce实现两个表的join?</h3>\n<blockquote>\n<ol>\n<li>reduce side join：在map阶段，map函数同时读取两个文件File1和File2，为了区分两种来源的key/value数据对，对每条数据打一个标签（tag），比如：tag0表示来自文件File1，tag2表示来自文件File2。</li>\n<li>map side join：map side join是针对以下场景进行的优化：两个待连接表中，有一个表非常大，而另一个表非常小，以至于小表可以直接存放到内存中。这样，我们可以将小表复制多份，让每个map task内存中存在一份（比如存放到hash table中），然后只扫描大表：对于大表中的每一条记录key/value，在hash table中查找是否有相同的key的记录，如果有，则连接后输出即可。</li>\n</ol>\n</blockquote>\n<h3 id=\"什么样的计算不能用mr来提速\"> 什么样的计算不能用mr来提速？</h3>\n<blockquote>\n<ol>\n<li>数据量很小</li>\n<li>繁杂的小文件</li>\n<li>索引是更好的存取机制的时候</li>\n<li>事务处理</li>\n<li>只有一台机器的时候</li>\n</ol>\n</blockquote>\n<h3 id=\"etl是哪三个单词的缩写\"> ETL是哪三个单词的缩写？</h3>\n<blockquote>\n<p>Extraction-Transformation-Loading的缩写，中文名称为数据提取，转换和加载</p>\n</blockquote>\n<h2 id=\"yarn\"> Yarn</h2>\n<h3 id=\"hadoop1和hadoop2的架构异同\"> hadoop1和hadoop2的架构异同</h3>\n<blockquote>\n<ol>\n<li>加入了yarn解决了资源调度的问题</li>\n<li>加入了对zookeeper的支持实现比较可靠的高可用</li>\n</ol>\n</blockquote>\n<h3 id=\"为什么会产生yarn-它解决了什么问题-有什么优势\"> 为什么会产生yarn，它解决了什么问题，有什么优势？</h3>\n<blockquote>\n<ol>\n<li>Yarn最主要的功能就是解决运行的用户程序与yarn框架完全解耦</li>\n<li>Yarn上可以运行各种类型的分布式运算程序(mapreduce只是其中的一种)，比如mapreduce、storm程序、spark程序......</li>\n</ol>\n</blockquote>\n<h3 id=\"hadoop的调度器总结\"> Hadoop的调度器总结</h3>\n<blockquote>\n<ol>\n<li>\n<p>先进先出调度器FIFO</p>\n<p>支持单队列、先进先出，先按照作业的优先级高低，再按照到达时间的先后选择被执行的作业。</p>\n</li>\n<li>\n<p>容量调度器Capcity Scheduler(Yahoo)</p>\n<p>特点：</p>\n<ol>\n<li>多队列：支持多队列多作业</li>\n<li>容量保证：管理员可为每个队列设置资源最低保证和资源使用上限。</li>\n<li>灵活性：如果一个队列中的资源有剩余，可以暂时共享给那些需要资源的队列，而一旦该队列有新的应用程序提交，则其他队列借调的资源会归还给该队列。</li>\n<li>多租户：为防止同一个用户的作业独占队列中的资源，该调度器会对同一用户提交的作业所占资源量进行限定。</li>\n</ol>\n<p>资源分配算法：</p>\n<ol>\n<li>\n<p>队列资源分配</p>\n<p>优先选择资源占用率最低的队列分配资源</p>\n</li>\n<li>\n<p>作业资源分配</p>\n<p>默认按照提交作业的优先级和提交时间顺序分配资源</p>\n</li>\n<li>\n<p>容器资源分配</p>\n<p>按照容器的优先级分配资源，如果优先级相同，按照数据本地性原则：</p>\n<ol>\n<li>任务和数据在同一节点</li>\n<li>任务和数据在同一机架</li>\n<li>任务和数据不在同一节点也不在同一机架</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>\n<p>公平调度器Fair Scheduler(Facebook)</p>\n<table>\n<thead>\n<tr>\n<th>不同点</th>\n<th>容量调度器</th>\n<th>公平调度器</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>核心调度策略</td>\n<td>优先选择资源利用率低的队列</td>\n<td>FIFO、DRF</td>\n</tr>\n<tr>\n<td>资源分配方式</td>\n<td>优先选择对资源的缺额大的队列</td>\n<td>FIFO、FAIR、DRF</td>\n</tr>\n</tbody>\n</table>\n</li>\n</ol>\n</blockquote>\n",
      "image": "https://cdn.nlark.com/yuque/0/2021/png/21953026/1629386282142-70da2bfc-7170-4d52-8061-59ebaf8446d3.png",
      "date_published": "2022-04-04T14:19:55.000Z",
      "date_modified": "2022-04-04T14:19:55.000Z",
      "authors": [
        {
          "name": "RiverCold"
        }
      ],
      "tags": []
    },
    {
      "title": "mr过程",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/interview/basics/bigdata/hadoop/hadoop/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/interview/basics/bigdata/hadoop/hadoop/",
      "content_html": "<h2 id=\"mr过程\"> mr过程</h2>\n<details><summary>answer</summary>\n<p>MapReduce的工作流程大致可以分为5步：</p>\n<Mermaid id=\"mermaid-1a962851\" data-code=\"graph%20TD%0A%20%20%20%20A%5B%E5%88%86%E7%89%87%2C%E6%A0%BC%E5%BC%8F%E5%8C%96%5D%0A%20%20%20%20B%5B%E6%89%A7%E8%A1%8CMapTask%5D%0A%20%20%20%20C%5B%E6%89%A7%E8%A1%8CShuffle%5D%0A%20%20%20%20D%5B%E6%89%A7%E8%A1%8CReduceTask%5D%0A%20%20%20%20E%5B%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6%5D%0A%20%20%20%20A--%3EB--%3EC--%3ED--%3EE%0A\"></Mermaid><ol>\n<li>\n<p>分片、格式化数据</p>\n<p><strong>分片</strong>：将输入源文件在逻辑上划分为大小相等的数据分片（split），Hadoop会为每一个分片启动一个MapTask，并由该任务执行自定义的map()函数</p>\n<p><strong>格式化操作</strong>：将划分好的分片内容转换为可以作为map输入的&lt;key,value&gt;键值对。其中key代表偏移量，value代表每一行内容。</p>\n</li>\n<li>\n<p>执行MapTask</p>\n<p><strong>写入内存缓冲区</strong>：每个Map任务都有一个内存缓冲区，输入的分片（split）数据经过Map任务处理后的中间结果写入内存（环形）缓冲区。</p>\n<p><strong>写入磁盘</strong>：如果写入的数据达到内存缓冲的阈值，会启动一个线程将内存中的溢出数据写入磁盘，同时不影响Map中间结果继续写入缓冲区。</p>\n<p><strong>对key进行排序</strong>：在溢写过程中，MapReduce框架会对key进行排序。</p>\n<p><strong>合并溢写文件</strong>：如果中间结果比较大，会形成多个溢写文件，最后的缓冲区数据也会全部溢写入磁盘形成一个溢写文件，如果是多个溢写文件，则最后合并所有的溢写文件为一个文件。输出形式为&lt;key,value&gt;</p>\n</li>\n<li>\n<p>执行Shuffle过程</p>\n<p>将MapTask输出的处理结果数据分发给ReduceTask，并在分发的过程中，对数据按照key进行分区和排序，输出形式为&lt;key,{value list}&gt;</p>\n</li>\n<li>\n<p>执行ReduceTask</p>\n<p>输入ReduceTask的数据流是&lt;key,{value list}&gt;形式，用户可以自定义reduce()方法进行逻辑处理，最终以&lt;key,value&gt;的形式输出</p>\n</li>\n<li>\n<p>写入文件</p>\n<p>MapReduce框架自动将ReduceTask生成的&lt;key,value&gt;传入OutputFormat的write方法，实现文件写入。</p>\n</li>\n</ol>\n</details>\n<p><a href=\"https://blog.csdn.net/Shockang/article/details/117970151\" target=\"_blank\" rel=\"noopener noreferrer\">(35条消息) 图文详解 MapReduce 工作流程_Shockang的博客-CSDN博客_mapreduce工作流程</a></p>\n<p><a href=\"https://juejin.cn/post/6996651554921005063\" target=\"_blank\" rel=\"noopener noreferrer\">图文详解 MapReduce 的工作流程 - 掘金 (juejin.cn)</a></p>\n<p><a href=\"http://www.itheima.com/news/20210415/141213.html\" target=\"_blank\" rel=\"noopener noreferrer\">MapReduce的工作流程是怎样的？ (itheima.com)</a></p>\n",
      "date_published": "2022-04-04T14:19:55.000Z",
      "date_modified": "2022-04-04T14:19:55.000Z",
      "authors": [
        {
          "name": "RiverCold"
        }
      ],
      "tags": []
    },
    {
      "title": "Hadoop文件存储格式？",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/interview/basics/bigdata/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/interview/basics/bigdata/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8/",
      "content_html": "<h2 id=\"hadoop文件存储格式\"> Hadoop文件存储格式？</h2>\n<details><summary>answer</summary>\n<p><strong>行式存储</strong>：数据是按照行为单位进行存储，一行中的数据在存储介质中以连续存储形式存在。读速度慢，写速度快。hdfs支持TextFile、SequenceFile。</p>\n<p><strong>TextFile</strong>：采用csv、xml、json等固定长度的纯文本格式</p>\n<p><strong>SequenceFile</strong>：按行存储二进制键值对数据，Hadoop API 提供的一种二进制文件，它将数据以&lt;key,value&gt;的形式序列化到文件中。</p>\n<p><strong>列式存储</strong>：数据按照列为单位进行存储，一列中的数据在存储介质中以连续存储形式存在。写速度慢，读速度快。hdfs支持Parquet、RCFile、ORCFile。</p>\n<p><strong>Parquet</strong>：是Hadoop生态系统中任何项目都能使用的列式存储格式，由Twitter和Cloudera合作开发</p>\n<p><strong>RCFile</strong>：RCFile是Hive推出的一种专门面向列的数据格式。 它遵循“先按列划分,再垂直划分”的设计理念。</p>\n<p><strong>ORCFile</strong>：<strong>RCFile</strong>的优化版本。</p>\n<p>::: end</p>\n<p><a href=\"https://blog.csdn.net/u011955252/article/details/50530942\" target=\"_blank\" rel=\"noopener noreferrer\">(34条消息) Hadoop的文件格式_红豆和绿豆的博客-CSDN博客_hadoop文件格式有哪几种</a></p>\n<p><a href=\"https://www.cnblogs.com/wqbin/p/14635480.html\" target=\"_blank\" rel=\"noopener noreferrer\">hdfs文件格式比较 - wqbin - 博客园 (cnblogs.com)</a></p>\n<p><a href=\"https://blog.csdn.net/qq_40579464/article/details/105756498\" target=\"_blank\" rel=\"noopener noreferrer\">(34条消息) Hadoop文件存储格式_赵昕彧的博客-CSDN博客_hdfs文件存储格式</a></p>\n<p><a href=\"https://www.cnblogs.com/wqbin/p/14635480.html\" target=\"_blank\" rel=\"noopener noreferrer\">hdfs文件格式比较 - wqbin - 博客园 (cnblogs.com)</a></p>\n<h2 id=\"spark和hive的区别\"> spark和hive的区别</h2>\n<p>Spark是一种基于内存的快速、通用、可扩展的大数据分析计算引擎，从各种各样的数据源读取数据进行运算。Spark是加强版的MapReduce，本身不存储数据。</p>\n<p>Apache Hive是一款建立在Hadoop之上的开源数据仓库系统，Hive核心是将HQL转换为MapReduce程序，然后将程序提交到Hadoop集群执行，本身不存储数据。</p>\n<p><a href=\"https://www.zhihu.com/question/329052025\" target=\"_blank\" rel=\"noopener noreferrer\">(14 封私信 / 80 条消息) 请问spark和hive是什么关系？ - 知乎 (zhihu.com)</a></p>\n</details>\n",
      "date_published": "2022-04-04T14:19:55.000Z",
      "date_modified": "2022-04-04T14:19:55.000Z",
      "authors": [
        {
          "name": "RiverCold"
        }
      ],
      "tags": []
    },
    {
      "title": "MySQL知识点&面试题总结",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/interview/basics/database/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9&%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/interview/basics/database/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9&%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/",
      "content_html": "<h1 id=\"mysql知识点-面试题总结\"> MySQL知识点&amp;面试题总结</h1>\n<h2 id=\"关系型数据库介绍\"> 关系型数据库介绍</h2>\n<h3 id=\"什么是关系型数据库-有哪些常见的关系型数据库\"> 什么是关系型数据库？有哪些常见的关系型数据库？</h3>\n<details><summary>answer</summary>\n<p>关系型数据库就是一种建立在关系模型的基础上的数据库。关系模型表明了数据库中所存储的数据之间的联系（一对一、一对多、多对多）。</p>\n<p>关系模型是指用二维表的形式表示实体和实体间联系的数据模型。常见的关系型数据库包括MySQL、Oracle、SQL Server、SQLite</p>\n</details>\n<h2 id=\"mysql介绍\"> MySQL介绍</h2>\n<h3 id=\"mysql是什么\"> MySQL是什么？</h3>\n<details><summary>answer</summary>\n<p>MySQL是一种关系型数据库管理系统（RDBMS），主要用于持久化存储我们的系统中的一些数据。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/River-Cold/vuepress-theme-hope-image/img/MySQL基础架构.png\" alt=\"\" loading=\"lazy\"></p>\n</details>\n<h2 id=\"存储引擎\"> 存储引擎</h2>\n<h3 id=\"存储引擎相关的命令\"> 存储引擎相关的命令？</h3>\n<details><summary>answer</summary>\n<p>查看MySQL提供的所有存储引擎</p>\n<div><pre><code>show engines;\n</code></pre>\n<div><span>1</span><br></div></div><p>MySQL默认的存储引擎是InnoDB，且只有InnoDB支持事务</p>\n<p>查看MySQL当前默认的存储引擎</p>\n<div><pre><code>show variables like &#39;%storage_engine%&#39;;\n</code></pre>\n<div><span>1</span><br></div></div><p>查看表的存储引擎</p>\n<div><pre><code>show table status like &#39;table_name&#39;;\n</code></pre>\n<div><span>1</span><br></div></div></details>\n<h3 id=\"myisam-和-innodb-的区别\"> MyISAM 和 InnoDB 的区别?</h3>\n<details><summary>answer</summary>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>InnoDB</th>\n<th>MyISAM</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>是否支持行级锁、表级锁</td>\n<td>既支持表级锁又支持行级锁</td>\n<td>支持表级锁，不支持行级锁</td>\n</tr>\n<tr>\n<td>是否支持事务</td>\n<td>支持事务</td>\n<td>不支持事务</td>\n</tr>\n<tr>\n<td>是否支持外键</td>\n<td>支持外键</td>\n<td>不支持外键</td>\n</tr>\n<tr>\n<td>是否支持数据库异常崩溃后的安全恢复</td>\n<td>支持安全恢复</td>\n<td>不支持安全恢复</td>\n</tr>\n</tbody>\n</table>\n</details>\n<h3 id=\"myisam和innodb存储引擎使用的锁\"> MyISAM和InnoDB存储引擎使用的锁？</h3>\n<details><summary>answer</summary>\n<p>MyISAM和InnoDB存储引擎使用的锁：</p>\n<ul>\n<li>InnoDB支持行级锁和表级锁</li>\n<li>MyISAM只支持表级锁</li>\n</ul>\n<p><strong>表级锁和行级锁对比</strong>：</p>\n<p><strong>表级锁</strong>：</p>\n<p>MySQL中<strong>锁定粒度</strong>最大的一种锁，对当前操作的整张表加锁。</p>\n<ul>\n<li>开销：实现简单，资源消耗（开销）较少。</li>\n<li>速度：加锁快，不会出现死锁。</li>\n<li>并发度：触发锁冲突的概率高，并发度低。</li>\n</ul>\n<p><strong>行级锁</strong>：MySQL中<strong>锁定粒度</strong>最小的一种锁，对当前操作的行进行加锁。</p>\n<ul>\n<li>开销：实现复杂，资源消耗（开销）较大</li>\n<li>速度：加锁慢，会出现死锁</li>\n<li>并发度：触发锁冲突的概率低，并发度高。</li>\n</ul>\n</details>\n<h3 id=\"innodb存储引擎的锁的算法有几种\"> InnoDB存储引擎的锁的算法有几种？</h3>\n<details><summary>answer</summary>\n<ol>\n<li>记录锁、行锁（Record Lock）：锁定单个行记录的锁，防止其他事务对此行进行update和delete。</li>\n<li>间隙锁（Gap Lock）：锁定索引记录间隙（不包含该记录），确保索引记录间隙不变，防止其他事务在这个间隙进行insert，产生幻读。</li>\n<li>临键锁（Next-Key Lock）：行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap。</li>\n</ol>\n</details>\n",
      "image": "https://cdn.jsdelivr.net/gh/River-Cold/vuepress-theme-hope-image/img/MySQL基础架构.png",
      "date_published": "2022-04-04T14:19:55.000Z",
      "date_modified": "2022-04-04T14:19:55.000Z",
      "authors": [
        {
          "name": "RiverCold"
        }
      ],
      "tags": []
    },
    {
      "title": "MySQL重要知识点",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/interview/basics/database/MySQL%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/interview/basics/database/MySQL%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9/",
      "content_html": "<h1 id=\"mysql重要知识点\"> MySQL重要知识点</h1>\n<h2 id=\"重要知识点\"> 重要知识点</h2>\n<h3 id=\"一条-sql-语句在-mysql-中如何被执行的\"> 一条 SQL 语句在 MySQL 中如何被执行的?</h3>\n<details><summary>answer</summary>\n<p><img src=\"https://cdn.jsdelivr.net/gh/River-Cold/vuepress-theme-hope-image/img/MySQL基础架构.png\" alt=\"\" loading=\"lazy\"></p>\n<p>MySQL主要分为<strong>Server层</strong>和<strong>存储引擎层</strong>。</p>\n<p><strong>Server层</strong>：包括连接器、查询缓存、分析器、优化器、执行器等，涵盖MySQL的核心功能。</p>\n<p><strong>存储引擎层</strong>：负责数据的存储和提取。</p>\n<ul>\n<li>\n<p>查询<code>select</code>语句的执行流程如下：</p>\n<ul>\n<li>连接器：管理连接，权限验证</li>\n<li>查询缓存：判断是否命中缓存，如果命中缓存则直接返回结果</li>\n<li>分析器：词法分析，语法分析\n<ul>\n<li>词法分析：提取 sql 语句的关键元素，以<code>select</code>为例，提取出查询的表名、查询的列名（字段）、查询条件等。</li>\n<li>语法分析：判断查询关键词是否正确</li>\n</ul>\n</li>\n<li>优化器：根据优化算法选择执行方案</li>\n<li>执行器：判断当前用户对当前表是否有查询权限，如果有则调用引擎提供的读接口，返回查询结果</li>\n</ul>\n</li>\n<li>\n<p>更新语句的执行流程和查询语句的流程类似：</p>\n<ul>\n<li>连接器：管理连接，权限验证</li>\n<li>分析器：词法分析，语法分析\n<ul>\n<li>词法分析：提取 sql 语句的关键元素，以<code>update</code>为例，提取出更新的表名、更新的列名（字段）、更新条件等。</li>\n<li>语法分析：判断查询关键词是否正确</li>\n</ul>\n</li>\n<li>优化器：根据优化算法选择执行方案</li>\n<li>执行器：判断当前用户对当前记录是否有更新权限， 如果有则调用引擎提供的写接口，返回更新结果</li>\n</ul>\n</li>\n</ul>\n</details>\n<h3 id=\"mysql三大日志详解\"> MySQL三大日志详解</h3>\n<details><summary>answer</summary>\n<p>MySQL日志主要包括错误日志、二进制日志、查询日志、慢查询日志、事务日志几大类</p>\n<p>其中比较重要的还属二进制日志<code>binlog</code>和事务日志<code>redo log</code>和回滚日志<code>undo log</code></p>\n<p><code>binlog</code>是逻辑日志，记录内容是语句的原始逻辑</p>\n<p><code>binlog</code>日志有三种格式，可以通过<code>binlog_format</code>参数指定。</p>\n<ul>\n<li><strong>statement</strong>：记录的内容是<code>SQL</code>语句原文，对数据进行修改的SQL都会记录在日志文件中</li>\n<li><strong>row</strong>：基于行的日志记录，记录的是每一行的数据变更。（默认）</li>\n<li><strong>mixed</strong>：混合了STATEMENT和ROW两种格式，默认采用STATEMENT，在某些特殊情况下会自动切换为ROW进行记录。</li>\n</ul>\n</details>\n<h3 id=\"mysql-binlog的三种格式及区别\"> MySQL binlog的三种格式及区别？</h3>\n<details><summary>answer</summary>\n<table>\n<thead>\n<tr>\n<th>格式</th>\n<th>文件大小</th>\n<th>执行速度</th>\n<th>数据一致性</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>statement</td>\n<td>小</td>\n<td>快</td>\n<td>当SQL语句里面用到一些特定功能函数，比如用到日期函数时在主从复制时可能丢失数据</td>\n</tr>\n<tr>\n<td>row</td>\n<td>大</td>\n<td>慢</td>\n<td>不会引起不一致</td>\n</tr>\n<tr>\n<td>mixed</td>\n<td>折中</td>\n<td>折中</td>\n<td><code>MySQL</code>会判断这条<code>SQL</code>语句是否可能引起数据不一致，如果是，就用<code>row</code>格式，否则就用<code>statement</code>格式。</td>\n</tr>\n</tbody>\n</table>\n</details>\n<h3 id=\"主从复制\"> 主从复制</h3>\n<details><summary>answer</summary>\n<p><strong>主从复制</strong>：是指将主数据库的<code>DDL</code>和<code>DML</code>操作通过二进制日志传到从库服务器中，然后在从库上对这些日志重新执行（也叫重做），从而建立一个和主数据库完全一样的数据库环境。</p>\n<p><strong>复制的优点</strong>：</p>\n<ul>\n<li>主库出现问题，可以快速切换到从库提供服务</li>\n<li>实现读写分离，降低主库的访问压力</li>\n<li>可以在从库中执行备份，以避免备份期间影响主库服务</li>\n</ul>\n</details>\n<h3 id=\"主从复制的原理\"> 主从复制的原理</h3>\n<details><summary>answer</summary>\n<p><img src=\"https://cdn.jsdelivr.net/gh/River-Cold/vuepress-theme-hope-image/img/MySQL主从复制.png\" alt=\"\" loading=\"lazy\"></p>\n<ol>\n<li>主库将数据库中数据的变化写入到<code>binlog</code></li>\n<li>从库连接主库</li>\n<li>从库创建一个<code>I/O</code>线程向主库请求更新的<code>binlog</code></li>\n<li>主库会创建一个<code>binlog dump</code>线程来发送<code>binlog</code>，从库中的<code>I/O</code>线程负责接收</li>\n<li>从库的I/O线程将接收的<code>binlog</code>写入到<code>relay log</code>中</li>\n<li>从库的SQL线程读取<code>relay log</code>同步数据到本地（即重新执行一遍SQL）</li>\n</ol>\n<p><img src=\"https://cdn.jsdelivr.net/gh/River-Cold/vuepress-theme-hope-image/img/MySQL主从复制2.png\" alt=\"\" loading=\"lazy\"></p>\n<p>从上图来看，复制分成三步：</p>\n<ol>\n<li>Master 主库在事务提交时，会把数据变更记录在二进制日志文件 Binlog 中</li>\n<li>从库读取主库的二进制日志文件 Binlog ，写入到从库的中继日志 Relay Log</li>\n<li>slave重做中继日志中的事件，将改变反映它自己的数据。</li>\n</ol>\n</details>\n<h3 id=\"关于数据库中如何存储时间的一点思考\"> 关于数据库中如何存储时间的一点思考</h3>\n<details><summary>answer</summary>\n<p><strong>为什么不要用字符串存储日期？</strong></p>\n<details><summary>answer</summary>\n<ol>\n<li>\n<p>字符串占用的空间更大</p>\n</li>\n<li>\n<p>字符串存储的日期效率比较低（逐个字符进行比对），无法用日期相关的API进行计算和比较</p>\n</li>\n</ol>\n<p><strong>Datetime和Timestamp的优缺点对比？</strong></p>\n<table>\n<thead>\n<tr>\n<th>日期类型</th>\n<th>存储空间</th>\n<th>日期格式</th>\n<th>日期范围</th>\n<th>是否存在时区问题</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Datetime</td>\n<td>8字节</td>\n<td>YYYY-MM-DD HH:MM:SS</td>\n<td>1000-01-01 00:00:00<br>~9999-12-31 23:59:59</td>\n<td>是</td>\n</tr>\n<tr>\n<td>TimeStamp</td>\n<td>4字节</td>\n<td>YYYY-MM-DD HH:MM:SS</td>\n<td>1970-01-01 00:00:00<br>~2037-12-31 23:59:59</td>\n<td>否</td>\n</tr>\n<tr>\n<td>时间戳</td>\n<td>4字节</td>\n<td>全数字</td>\n<td>1970-01-01 00:00:01之后的时间</td>\n<td>否</td>\n</tr>\n</tbody>\n</table>\n</details>\n</details>\n<p>::::</p>\n<h2 id=\"参考文献\"> 参考文献</h2>\n<p><a href=\"https://zhuanlan.zhihu.com/p/65743530\" target=\"_blank\" rel=\"noopener noreferrer\">MySQL binlog的三种格式及区别 - 知乎 (zhihu.com)</a></p>\n",
      "image": "https://cdn.jsdelivr.net/gh/River-Cold/vuepress-theme-hope-image/img/MySQL基础架构.png",
      "date_published": "2022-04-04T14:19:55.000Z",
      "date_modified": "2022-04-04T14:19:55.000Z",
      "authors": [
        {
          "name": "RiverCold"
        }
      ],
      "tags": []
    },
    {
      "title": "数据库",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/interview/basics/database/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/interview/basics/database/",
      "content_html": "<h1 id=\"数据库\"> 数据库</h1>\n<ul>\n<li><a href=\"./数据库基础知识.html\">数据库基础知识</a></li>\n<li><a href=\"./MySQL重要知识点.html\">MySQL重要知识点</a></li>\n<li><a href=\"./MySQL知识点&amp;面试题总结.html\">MySQL知识点&amp;面试题总结</a></li>\n</ul>\n",
      "date_published": "2022-04-04T14:19:55.000Z",
      "date_modified": "2022-04-04T14:19:55.000Z",
      "authors": [
        {
          "name": "RiverCold"
        }
      ],
      "tags": []
    },
    {
      "title": "数据库知识手册",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/interview/basics/database/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/interview/basics/database/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/",
      "content_html": "<h1 id=\"数据库知识手册\"> 数据库知识手册</h1>\n<h2 id=\"数据库基础概念\"> 数据库基础概念</h2>\n<h3 id=\"什么是数据库-数据库管理系统-数据库系统-数据库管理员\"> 什么是数据库？数据库管理系统？数据库系统？数据库管理员？</h3>\n<details><summary>answer</summary>\n<p><strong>数据库</strong>：数据库（Database）是保存有组织的数据的容器（通常是一个文件或一组文件），是通过数据库管理系统（DataBase-Management System，DBMS）创建和操纵的容器。</p>\n<p><strong>数据库管理系统</strong>：一种操纵和管理数据库的大型软件，（DataBase Management System，简称DBMS）。</p>\n<p><strong>数据库系统</strong>：数据库系统（DataBase System，简称DBS）通常由软件、数据库（DataBase）和数据库管理员（DBA）组成。其软件主要包括操作系统、宿主语言、实用程序以及数据库管理系统。</p>\n<p><strong>数据库管理员</strong>：数据库管理员（Database Administrator，简称DBA）负责全面管理和控制数据库系统。</p>\n</details>\n<h3 id=\"为什么要使用数据库\"> 为什么要使用数据库？</h3>\n<details><summary>answer</summary>\n<ol>\n<li>数据可永久保存且数据安全性高</li>\n<li>使用SQL语句，查询方便效率高</li>\n<li>便于数据管理和数据分析</li>\n</ol>\n</details>\n<h3 id=\"sql和mysql有什么区别\"> SQL和MySQL有什么区别？</h3>\n<details><summary>answer</summary>\n<p>SQL是一种结构化查询语言，用于在数据库上执行各种操作。</p>\n<p>MySQL是一个关系型数据库管理系统（RDBMS），使用SQL执行所有数据库操作。</p>\n</details>\n<h3 id=\"数据库三大范式是什么\"> 数据库三大范式是什么？</h3>\n<details><summary>answer</summary>\n<p>数据库范式是设计数据库时，需要遵循的一些规范。越高的范式数据库冗余越小。常用的数据库三大范式为：</p>\n<ul>\n<li>**第一范式（1NF）：**每个列都不可以再拆分，强调列的原子性。第一范式要求数据库中的表都是二维表。</li>\n<li>**第二范式（2NF）：**在第一范式的基础上，一个表必须有一个主键，非主键列（非主属性）<strong>完全依赖</strong>于主键，而不能是依赖于主键的一部分。</li>\n<li>**第三范式（3NF）：**在第二范式的基础上，非主键列（非主属性）只依赖于（直接依赖）于主键，不依赖于其他非主键。</li>\n</ul>\n<p><strong>函数依赖（functional dependency）</strong>：在一张表中，在属性（或属性组）X的值确定的情况下，必定能确定属性Y的值，那么就可以说Y函数依赖于X，写作X-&gt;Y。</p>\n<p><strong>部分函数依赖（partial functional dependency）</strong>：如果X-&gt;Y，并且存在X的一个真子集X0，使得X0-&gt;Y，则称Y对X部分函数依赖。</p>\n<p><strong>完全函数依赖（fully functional dependency）</strong>：在一个关系中，若某个非主属性数据项依赖于全部关键字则称为完全函数依赖。</p>\n<p><strong>传递函数依赖（transitive functional dependency）</strong>：在关系模式R (U) 中, 如果X→Y, Y→Z, Z不是Y的子集, Y不函数决定X, 则称Z对X传递函数依赖 (Transitive Functional Dependency) 。</p>\n<p><strong>总结</strong></p>\n<ul>\n<li>1NF：属性不可再分</li>\n<li>2NF：1NF的基础之上，消除了非主属性对于码的部分函数依赖</li>\n<li>3NF：2NF的基础之上，消除了非主属性对于码的传递函数依赖</li>\n</ul>\n</details>\n<h3 id=\"什么是er图\"> 什么是ER图？</h3>\n<details><summary>answer</summary>\n<p><strong>E-R图</strong> 也称为实体-联系图（Entity Relationship Diagram），提供了表示实体类型、属性和联系的方法，用来描述现实世界的概念模型。</p>\n<p><strong>矩形框</strong>：表示实体</p>\n<p><strong>菱形框</strong>：表示联系</p>\n<p><strong>椭圆形框</strong>：表示实体或联系的属性</p>\n<p>下图是一个学生选课的 ER 图，每个学生可以选若干门课程，同一门课程也可以被若干人选择，所以它们之间的关系是多对多（M: N）。另外，还有其他两种关系是：1 对 1（1:1）、1 对多（1: N）。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/4717673e36966e0e4b33fccfd753f6ea.png\" alt=\"ER图示例\" loading=\"lazy\"></p>\n</details>\n<h3 id=\"数据库设计通常分为哪几步\"> 数据库设计通常分为哪几步？</h3>\n<details><summary>answer</summary>\n<ol>\n<li>\n<p><strong>需求分析</strong>：分析用户需求，包括数据、功能和性能需求</p>\n</li>\n<li>\n<p><strong>概念结构设计</strong>：主要采用E-R模型进行设计，包括画E-R图</p>\n</li>\n<li>\n<p><strong>逻辑结构设计</strong>：通过将E-R图转换成表，实现从E-R模型到关系模型的转换</p>\n</li>\n<li>\n<p><strong>物理结构设计</strong>：为所设计的数据库选择合适的存储结构和存取路径</p>\n</li>\n<li>\n<p><strong>数据库实施</strong>：包括编程、测试和试运行</p>\n</li>\n<li>\n<p><strong>数据库的运行和维护</strong>：系统的运行与数据库的日常维护</p>\n</li>\n</ol>\n</details>\n<h2 id=\"索引\"> 索引</h2>\n<h3 id=\"索引的优缺点\"> 索引的优缺点</h3>\n<details><summary>answer</summary>\n<p><strong>索引的优点</strong></p>\n<ul>\n<li>通过创建<strong>唯一性索引</strong>，可以<strong>保证每一行数据的唯一性</strong>；</li>\n<li>加快数据的<strong>检索速度</strong></li>\n<li>加速<strong>表与表之间的连接</strong></li>\n</ul>\n<p><strong>索引的缺点</strong></p>\n<ul>\n<li>时间上，创建和维护索引都需要耗费时间，这种时间随数据量增加而增加</li>\n<li>空间上，索引需要占<strong>物理空间</strong>，除了数据表占数据空间外，每个索引还要占一定的物理空间，如果要建立聚簇索引，需要的空间就更大。</li>\n</ul>\n</details>\n<h3 id=\"索引的数据结构有哪些\"> 索引的数据结构有哪些？</h3>\n<details><summary>answer</summary>\n<p>数据库索引按照结构分类，主要有<strong>B树索引、Hash索引和位图索引</strong>三种</p>\n<p><strong>B树索引</strong></p>\n<p>又称<strong>平衡树索引</strong>。以树结构组织，有一个或多个分支结点，分支结点又指向单级叶结点。其中分支结点用于遍历树，叶结点则保存真正的值和位置信息。</p>\n<p><strong>Hash索引</strong></p>\n<p>哈希索引采取一定的哈希算法（常见哈希算法有直接定址法，平方取中法，折叠法，除数取余法，随机数法），将数据库字段转换成定长的Hash值，与这条数据的行指针一并存入Hash表的对应位置，如果发生Hash冲突（两个不同关键字的Hash值相同），则在对应Hash键下以链表形式存储。</p>\n<p><strong>位图索引</strong></p>\n<p>位图索引为存储在某列中的每一个值生成一个位图。位图索引适合只有几个固定值的列，需要注意位图索引适合静态数据，不适合索引频繁更新的列。</p>\n</details>\n<h3 id=\"b树的特点\"> B树的特点</h3>\n<details><summary>answer</summary>\n<p><img src=\"https://cdn.jsdelivr.net/gh/River-Cold/vuepress-theme-hope-image/img/B-树.png\" alt=\"\" loading=\"lazy\"></p>\n<p>B树是所有结点的平衡因子均等于0的多路平衡查找树</p>\n<ul>\n<li>每个节点最多m个子结点（m棵子树），即<strong>至多含有<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span>m</span><span style=\"margin-right:0.2222em;\"></span><span>−</span><span style=\"margin-right:0.2222em;\"></span></span><span><span style=\"height:0.6444em;\"></span><span>1</span></span></span></span>个关键字</strong></li>\n<li>如果根节点没有关键字就没有子树，此时B树为空；如果根节点有关键字，则其子树必然大于等于两棵</li>\n<li>除了根节点和叶子结点外，每个结点至少有<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>⌈</span><span><span>m</span><span>/2</span><span>⌉</span></span></span></span></span>（向上取整）个子结点</li>\n<li>所有叶子结点位于同一层，按照关键字大小顺序排列</li>\n<li>每个节点既存放关键字信息也存放具体数据</li>\n</ul>\n</details>\n<h3 id=\"b-树的特点\"> B+树的特点</h3>\n<details><summary>answer</summary>\n<p>B+ 树是在 B 树基础上的一种优化，使其更适合实现存储索引结构。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/River-Cold/vuepress-theme-hope-image/img/B+树.png\" alt=\"\" loading=\"lazy\"></p>\n<ul>\n<li>每个节点最多m个子结点（m棵子树），即<strong>至多含有<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.4306em;\"></span><span>m</span></span></span></span>个关键字</strong></li>\n<li>如果根节点没有关键字就没有子树，此时B树为空；如果根节点有关键字，则其子树必然大于等于两棵</li>\n<li>除了根节点和叶子结点外，每个结点至少有<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>⌈</span><span><span>m</span><span>/2</span><span>⌉</span></span></span></span></span>（向上取整）个子结点</li>\n<li>所有叶子结点位于同一层，按照关键字大小顺序排列，<strong>并且相邻叶结点之间有一个链指针</strong></li>\n<li>非叶结点只起到索引作用，只存放关键字，不存放数据，只有叶子结点既存放关键字也存放数据</li>\n</ul>\n</details>\n<h3 id=\"b-树和b-树的区别\"> B+树和B-树的区别？</h3>\n<details><summary>answer</summary>\n<ul>\n<li>B树每个节点的子节点个数=关键字个数+1，B+树每个节点的子节点个数=关键字个数</li>\n<li>B树的相邻叶结点都是独立的，B+树的相邻叶结点之间有链指针</li>\n<li>B树的每个节点既存放关键字也存放数据，B+树的非叶结点只起到索引作用，只存放关键字，不存放数据，只有叶子结点既存放关键字也存放数据</li>\n</ul>\n</details>\n<h3 id=\"使用b-树的好处\"> 使用B+树的好处?</h3>\n<details><summary>answer</summary>\n<p><strong>更少的IO次数</strong>：B+树的内部结点只存放键，不存放值，因此，一次读取，可以在同一内存页中获取更多的键，有利于更快的缩小查找范围。</p>\n<p><strong>更适用于范围查询：<strong>B+树的叶结点由一条链相连，因此当需要进行一次</strong>全数据遍历</strong>的时候，B+树只需要使用<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span style=\"margin-right:0.02778em;\">O</span><span>(</span><span style=\"margin-right:0.01968em;\">l</span><span>o</span><span style=\"margin-right:0.03588em;\">g</span><span style=\"margin-right:0.10903em;\">N</span><span>)</span></span></span></span>时间找到最小结点，然后通过链进行<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span style=\"margin-right:0.02778em;\">O</span><span>(</span><span style=\"margin-right:0.10903em;\">N</span><span>)</span></span></span></span>的顺序遍历即可。或者在找<strong>大于某个关键字或者小于某个关键字的数据</strong>的时候，B+树只需要找到该关键字然后沿着链表遍历即可。</p>\n</details>\n<h3 id=\"hash索引和b-树索引的区别\"> Hash索引和B+树索引的区别？</h3>\n<details><summary>answer</summary>\n<ul>\n<li>**范围查询：**Hash索引不支持范围查询，B+树支持范围查询</li>\n<li>**排序：**Hash索引不支持排序，B+树索引支持排序，因为Hash索引指向的数据是无序的，而B+树索引指向的数据是有序的</li>\n<li>**模糊查询和最左前缀匹配：**Hash索引不支持模糊查询以及多列索引的最左前缀匹配，原因是Hash函数的不可预测，AAAA和AAAAB的索引没有相关性，B+树索引支持模糊查询以及多列索引的最左前缀匹配</li>\n<li>**查询效率：**Hash索引虽然在等值查询上较快，但是不稳定，当某个键值存在大量重复的时候，发生Hash碰撞，此时效率可能极差；B+树的查询效率比较稳定，对于所有的查询都是从根节点到叶子结点，且树的高度较低</li>\n</ul>\n</details>\n<h3 id=\"什么是前缀索引\"> 什么是前缀索引？</h3>\n<details><summary>answer</summary>\n<p>有时需要索引很长的字符列，它会使索引变大且变慢，一个策略就是使用索引开始的几个字符，而不是全部值，即被称为<strong>前缀索引</strong>，以节约空间并获得好的性能。</p>\n</details>\n<h3 id=\"什么是联合索引\"> 什么是联合索引？</h3>\n<details><summary>answer</summary>\n<p>联合索引就是由两个或以上的字段共同构成的索引。</p>\n</details>\n<h3 id=\"什么是最左前缀匹配原则\"> 什么是最左前缀匹配原则？</h3>\n<details><summary>answer</summary>\n<p>在MySQL建立联合索引（多列索引）时会遵循最左前缀匹配原则，即<strong>最左优先</strong>，在检索数据时从联合索引的最左边一列开始匹配（也就是where子句中一定要有联合索引的第一个字段，并且where子句中字段的顺序可以任意调整）。</p>\n<p>例如有一个3列索引（a,b,c），则已经对(a)、(a,b)、(a,b,c)上建立了索引。所以在创建<strong>多列索引</strong>时，要根据业务需求，<code>where</code>子句中使用最频繁的一列放在最左边。</p>\n<p>**根据最左前缀匹配原则，MySQL 会一直向右匹配直到遇到 范围查询（&gt;、&lt;、between、like）就停止匹配，**比如采用查询条件 where a = 1 and b = 2 and c &gt; 3 and d = 4 时，如果建立（a,b,c,d）顺序的索引，d 是用不到索引的，如果建立（a,b,d,c）的索引则都可以用到，并且 where 子句中 a、b、d 的顺序可以任意调整。</p>\n</details>\n<h3 id=\"添加索引的原则\"> 添加索引的原则</h3>\n<details><summary>answer</summary>\n<ul>\n<li>**在查询中很少使用或者参考的列不要创建索引：**由于这些列很少使用到，增加索引反而会降低系统的维护速度和增大空间需求。</li>\n<li>**只有很少数据值的列不创建索引：**区分度太低，增加索引并不能明显加快检索速度</li>\n<li><strong>修改性能远远大于检索性能时，不应该创建索引</strong>：二者相互矛盾，当增加索引时，会提高索引性能，但是会降低修改性能。</li>\n<li><strong>定义为外键的数据列一定要创建索引</strong>：如果不加索引，则删除主表记录或主子表关联查询，都会进行字表的全表扫描。</li>\n</ul>\n</details>\n<h3 id=\"聚集索引和非聚集索引\"> 聚集索引和非聚集索引</h3>\n<details><summary>answer</summary>\n<p><strong>聚集索引，又称为聚集索引，首先并不是一种索引类型，而是一种数据存储方式，即索引结构和数据一起存放。</strong></p>\n<p>聚集索引的特点</p>\n<ol>\n<li>聚集索引的检索效率更高</li>\n<li>聚集索引的磁盘IO次数更少</li>\n<li>一个数据表只能有一个聚集索引</li>\n<li>一般而言，会在频繁使用、排序的字段上创建聚集索引</li>\n</ol>\n<p><strong>非聚集索引即索引结构和数据分开存放，非聚集索引中并不存放真正的数据行，只包含一个指向数据行的指针。</strong></p>\n<p>非聚簇索引的创建也是以此为根据的，分为<strong>复合索引</strong>和<strong>覆盖索引</strong></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/River-Cold/vuepress-theme-hope-image/img/聚簇索引和非聚簇索引.png\" alt=\"\" loading=\"lazy\"></p>\n</details>\n<h2 id=\"事务管理\"> 事务管理</h2>\n<h3 id=\"什么是数据库事务\"> 什么是数据库事务？</h3>\n<details><summary>answer</summary>\n<p>数据库的<strong>事务</strong>（Transaction）是一种机制、一个操作序列，包含了一组数据库操作命令，其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。</p>\n<p>事务把所有的命令作为一个整体一起向系统提交或撤销操作请求，即这一组数据库命令要么都执行，要么都不执行，因此事务是一个不可分割的工作逻辑单元。如果任意一个操作失败，那么整组操作即为失败，会回到操作前状态或者上一个节点。</p>\n</details>\n<h3 id=\"有哪些事务状态\"> 有哪些事务状态？</h3>\n<details><summary>answer</summary>\n<p>事务在其生命周期中会经历不同的状态，这些状态被称为<strong>事务状态</strong>。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/River-Cold/vuepress-theme-hope-image/img/事务状态.png\" alt=\"\" loading=\"lazy\"></p>\n<p><a href=\"https://www.geeksforgeeks.org/transaction-states-in-dbms/\" target=\"_blank\" rel=\"noopener noreferrer\">Transaction States in DBMS - GeeksforGeeks</a></p>\n<p><strong>活跃状态（Active State）</strong>：事务的第一个状态，任何正在执行的事务都处于此状态，所做的<strong>更改</strong>存储在<strong>主内存（本地）的缓冲区</strong>中。</p>\n<p><strong>部分提交状态（Partially Commited State）</strong>：执行操作后，事务进入部分提交状态。之所以是部分提交，是因为所做的更改仍然在<strong>主内存（本地）的缓冲区</strong>中。</p>\n<p><strong>失败状态（Failed State）</strong>：如果事务在活动状态或者部分提交状态发生一些错误，并且事务无法进一步执行，则事务进入失败状态。</p>\n<p><strong>中止状态（Aborted State）</strong>：如果任何事务已达到失败状态，撤销失败事务对当前数据库造成的影响，恢复管理器将数据库回滚到开始执行的原始状态。</p>\n<p><strong>提交状态（Commited State）</strong>：如果所有操作成功执行，数据永久写入到磁盘上的数据库中，则来自部分提交状态的事务进入提交状态，无法从此状态回滚，它是一个新的<strong>一致状态</strong>。</p>\n</details>\n<h3 id=\"事务的四大特性\"> 事务的四大特性？</h3>\n<details><summary>answer</summary>\n<p>事务具有4个特性：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability），这4个特性通常简称为ACID，<strong>关系型数据库</strong>需要遵循ACID规则。</p>\n<p>**原子性：**事务是最小的执行单位，不可分割的（原子的）。事务的原子性确保动作要么全部执行，要么全部不执行。</p>\n<p>**一致性：**事务执行前后数据的完整性保持一致。</p>\n<p>**隔离性：**并发访问数据库时，一个用户的事务不被其他事务所干扰，各个事务不干涉内部的数据。</p>\n<p>**持久性：**一个事务被提交之后，对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</p>\n</details>\n<h3 id=\"如何实现事务的acid特性\"> 如何实现事务的ACID特性？</h3>\n<details><summary>answer</summary>\n<p>事务的ACID特性是由关系型数据库管理系统来实现的。</p>\n<p>DBMS采用<strong>日志</strong>来保证事务的<strong>原子性、一致性、持久性</strong>。日志记录了事务对数据库所做的操作，如果某个事务在执行过程中发生错误，就可以根据日志，撤销事务对数据库已做的操作，使数据库退回到执行事务之前的初始状态。</p>\n<p>DBMS采用<strong>锁机制</strong>来保证事务的隔离性。当多个事务同时更新数据库中相同的数据时，只允许<strong>持有锁的事务</strong>能更新该数据，其他事务必须等待，直到前一个事务释放了锁，其他事务才有机会更新该数据。</p>\n<p><a href=\"https://www.cnblogs.com/kismetv/p/10331633.html\" target=\"_blank\" rel=\"noopener noreferrer\">深入学习MySQL事务：ACID特性的实现原理 - 编程迷思 - 博客园 (cnblogs.com)</a></p>\n</details>\n<h3 id=\"并发事务之间的相互影响\"> 并发事务之间的相互影响</h3>\n<details><summary>answer</summary>\n<p><strong>脏读（Dirty Read）</strong>：<strong>A事务读取到了B事务还未提交的数据</strong>。</p>\n<p><strong>不可重复读（Non-repeatable Read）</strong>：<strong>A事务读取到了B事务提交的更改数据</strong>。在一个事务范围内，两次相同的查询返回两个不同的数据，这是因为在此间隔内有其他事务对数据进行了修改并提交。</p>\n<p><strong>幻读（Phantom Read）</strong>：<strong>A事务读取到了B事务提交的新增数据</strong>。例如有一个事务对表中的数据进行了修改并提交，这种修改是向表中<strong>插入一行新数据</strong>。那么，当第一个事务的用户发现表中还有没有修改的数据行，就好像发生了幻觉一样。</p>\n<p><strong>丢失更新（Lost Update）</strong>：</p>\n<p><strong>第一类丢失更新（回滚丢失，Lost update）</strong></p>\n<p>A事务撤销时，把已经提交的B事务的更新数据覆盖了</p>\n<p><strong>第二类丢失更新（覆盖丢失/两次更新问题，Second lost update）</strong></p>\n<p>A事务覆盖B事务已经提交的数据，造成B事务所做操作丢失</p>\n<p>两个事务同时读取同一条记录，事务A先修改记录，事务B也修改记录（B是不知道A修改过），当B提交数据后，其修改结果覆盖了A的修改结果，导致事务A更新丢失。</p>\n<p>不可重复读的重点是修改，幻读的重点在于新增或删除。</p>\n</details>\n<h3 id=\"什么是事务的隔离级别\"> 什么是事务的隔离级别？</h3>\n<details><summary>answer</summary>\n<p>读取未提交（READ-UNCOMMITTED）</p>\n<p>读取已提交（READ-COMMITTED）</p>\n<p>可重复读（REPEATABLE-READ）</p>\n<p>可串行化（SERIALIZABLE）</p>\n<table>\n<thead>\n<tr>\n<th>隔离级别</th>\n<th>脏读</th>\n<th>不可重复读</th>\n<th>幻读</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>读取未提交</td>\n<td>是</td>\n<td>是</td>\n<td>是</td>\n</tr>\n<tr>\n<td>读取已提交</td>\n<td>否</td>\n<td>是</td>\n<td>是</td>\n</tr>\n<tr>\n<td>可重复读</td>\n<td>否</td>\n<td>否</td>\n<td>是</td>\n</tr>\n<tr>\n<td>可串行化</td>\n<td>否</td>\n<td>否</td>\n<td>否</td>\n</tr>\n</tbody>\n</table>\n</details>\n<h2 id=\"锁\"> 锁</h2>\n<h3 id=\"锁的分类\"> 锁的分类</h3>\n<details><summary>answer</summary>\n<p>从数据库系统角度分为三种：</p>\n<p><strong>共享锁（S）</strong>：又叫<strong>读锁</strong>。可以并发读取数据，但不能修改数据。也就是说当数据资源上存在共享锁时，所有的事务都不能对该数据进行修改（不能加排他锁），直到数据读取完成，共享锁释放。</p>\n<p><strong>排他锁（X）</strong>：又叫<strong>独占锁、写锁</strong>。对数据资源进行增删改时，不允许其他事务操作这块资源（读取或修改），直到排他锁被释放，从而防止同时对同一资源进行多重操作。</p>\n<p><strong>更新锁（U）</strong>：防止出现<strong>死锁</strong>的锁模式。两个事务对一个数据资源进行先读取再修改的情况下，使用共享锁和排他锁有时会出现死锁现象，而使用更新锁就可以避免死锁的出现。</p>\n<p><strong>死锁</strong>：如果有两个或多个事务同时对一个数据资源申请了共享锁，在修改数据时，这些事务都要将共享锁升级为排他锁。这时，这些事务都不会释放共享锁，而是一直等待对方释放，这样就造成了死锁。</p>\n</details>\n<h3 id=\"什么是死锁-如何解决死锁\"> 什么是死锁？如何解决死锁？</h3>\n<details><summary>answer</summary>\n<p>死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。</p>\n<ol>\n<li>\n<p>不同的程序并发存取多个表，尽量约定以<strong>相同的顺序访问表</strong>。</p>\n</li>\n<li>\n<p>在同一个事务中，尽可能做到<strong>一次锁定事务所需要的所有资源</strong>。</p>\n</li>\n<li>\n<p>对于非常容易产生死锁的业务部分，可以尝试<strong>升级锁定粒度</strong>，设置<strong>表级锁</strong>。</p>\n</li>\n</ol>\n</details>\n<h2 id=\"常用sql语句\"> 常用SQL语句</h2>\n<h3 id=\"sql语句主要分为哪些类别\"> SQL语句主要分为哪些类别？</h3>\n<details><summary>answer</summary>\n<ol>\n<li>数据定义语言DDL（Data Definition Language）：例如<code>CREATE</code>，<code>DROP</code>，<code>ALTER</code>等，对逻辑结构有操作的，其中包括表结构，视图和索引。</li>\n<li>数据查询语言DQL（Data Query Language）：即查询操作，以<code>SELECT</code>为主，各种简单查询、连接查询都属于DQL</li>\n<li>数据操作语言DML（Data Manipulation Lanuage）：例如<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>等，对数据进行操作的。DQL和DML共同构建了常用的<strong>增删改查</strong>操作。</li>\n<li>数据控制语言DCL（Data Control Language）：例如<code>GRANT</code>、<code>REVOKE</code>、<code>COMMIT</code>、<code>ROLLBACK</code>等，对数据库安全性、完整性等有操作的，可以简单的理解为权限控制等。</li>\n</ol>\n</details>\n<h3 id=\"什么是元组-键-超键-候选键-主键-外键-主属性-非主属性\"> 什么是元组？键？超键？候选键？主键？外键？主属性？非主属性？</h3>\n<details><summary>answer</summary>\n<p><strong>元组</strong>：元组（tuple）是关系数据库中的基本概念，关系是一张表，表中的每行（即数据库中的每条记录）就是一个元组。在二维表中，元组也称为行。</p>\n<p><strong>键</strong>：能唯一标识元组的属性，对应表中的列</p>\n<p>**超键：**在关系中，能唯一标识元组的属性集称为关系模式的超键。一个属性可以作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。</p>\n<p>**候选键：**是最小超键，即没有冗余元素的超键。</p>\n<p>**主键：**主关键字（主键，Primary key）是中被挑选出来的候选键，作为表的行的唯一标识。主键不能有重复，不能为空（NULL）。</p>\n<p>**外键：**在一个表（关系）中存在的另一个表（关系）的主键称为此表的外键，外键可以有重复的，可以是空值。外键是用来和其他表建立联系用的。</p>\n<p><strong>主属性</strong>：候选键中出现过的属性称为主属性。</p>\n<p><strong>非主属性</strong>：不包含在任何一个候选键中的属性称为非主属性。</p>\n</details>\n<h3 id=\"主键和外键有什么区别\"> 主键和外键有什么区别？</h3>\n<details><summary>answer</summary>\n<p><strong>主键</strong>：主键用于唯一标识一个元组，不能有重复，不允许为空。一个表只能有一个主键。</p>\n<p><strong>外键</strong>：外键用于和其他表建立联系用，外键是另一表的主键，外键是可以有重复的，可以是空值。一个表可以有多个外键。</p>\n</details>\n<h3 id=\"char和varchar的区别\"> char和varchar的区别？</h3>\n<details><summary>answer</summary>\n<ol>\n<li>\n<p>char表示定长字符串，长度是固定的，最多能存放的字符个数为255；varchar表示可变长字符串，长度是可变的，最多能存放的字符个数为65532</p>\n</li>\n<li>\n<p>使用char时，如果插入数据的长度小于char的固定长度时，用空格填充</p>\n</li>\n<li>\n<p>char的存取速度比varchar快很多，缺点是会占用多余空间，属于以空间换时间</p>\n</li>\n</ol>\n</details>\n<h3 id=\"sql约束有哪几种类型\"> SQL约束有哪几种类型</h3>\n<details><summary>answer</summary>\n<p>约束是一种简单地强加于表中一列或多列（字段）的限制，从而保证表中数据一致性（准确和可靠）。以下为六大约束：</p>\n<ul>\n<li><strong>非空约束（NOT NULL）</strong>：保证字段不为空</li>\n<li><strong>唯一约束（UNIQUE）</strong>：限制一列或多列的值，保证字段值在表内的唯一性，可以为空（主键约束是一种特殊类型的唯一约束）</li>\n<li><strong>主键约束（PRIMARY KEY）</strong>：标志一列或多列，保证其值在表中的唯一性，不能为空，相当于非空约束和唯一约束的组合</li>\n<li><strong>外键约束（FOREIGN KEY）</strong>：限制一列或多列中的值必须被包含在另一表的外键列中，并且在级联更新或级联删除规则建立后也可以限制其他表中的可用值</li>\n<li><strong>默认约束（DEFAULT）</strong>：保证字段有默认值</li>\n<li><strong>检查约束（CHECK）</strong>：限制一列的可用值范围</li>\n</ul>\n</details>\n<h3 id=\"有哪些关联查询\"> 有哪些关联查询？</h3>\n<details><summary>answer</summary>\n<p><strong>交叉连接（CROSS JOIN）</strong></p>\n<ul>\n<li>返回被连接的两个表所有数据行的<strong>笛卡尔积</strong>，返回的数据行数等于第一个表中符合查询条件的数据行数<strong>乘以</strong>第二个表中符合查询条件的数据行数，以下两个表达式等价：\n<ul>\n<li><code>SELECT * FROM A, B</code></li>\n<li><code>SELECT * FROM A CROSS JOIN B</code></li>\n</ul>\n</li>\n</ul>\n<p><strong>内连接（INNER JOIN）</strong></p>\n<ul>\n<li>\n<p>等值连接</p>\n<ul>\n<li><code>ON A.id=B.id</code></li>\n</ul>\n</li>\n<li>\n<p>不等值连接</p>\n<ul>\n<li><code>ON A.id &gt; B.id</code></li>\n</ul>\n</li>\n<li>\n<p>自连接</p>\n<ul>\n<li><code>SELECT * FROM A T1 INNER JOIN A T2 ON T1.id=T2.id</code></li>\n</ul>\n</li>\n<li>\n<p>外连接（LEFT JOIN/RIGHT JOIN）</p>\n<ul>\n<li>\n<p>左外连接</p>\n<ul>\n<li>以左表为主，先查询出左表，按照<code>ON</code>后的关联条件匹配右表，没有匹配到的用<code>NULL</code>填充，可以简写成<code>LEFT JOIN</code></li>\n</ul>\n</li>\n<li>\n<p>右外连接</p>\n<ul>\n<li>以左表为主，先查询出右表，按照<code>ON</code>后的关联条件匹配左表，没有匹配到的用<code>NULL</code>填充，可以简写成<code>RIGHT JOIN</code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><strong>全连接（FULL JOIN）</strong></p>\n<p><strong>联合查询（UNION与UNION ALL）</strong></p>\n<ul>\n<li><code>SELECT * FROM A UNION SELECT * FROM B UNION ...</code></li>\n</ul>\n</details>\n<h3 id=\"什么是子查询\"> 什么是子查询？</h3>\n<details><summary>answer</summary>\n<p>多条MySQL语句嵌套使用时，内部的MySQL查询语句称为子查询。</p>\n<p>子查询是一个<code>SELECT</code>语句，它嵌套在另一个<code>SELECT</code>、<code>SELECT...INTO</code>、<code>INSERT...INTO</code>、<code>DELETE</code>、<code>UPDATE</code>语句或嵌套在另一子查询中。</p>\n</details>\n<h3 id=\"drop、delete与truncate的区别\"> DROP、DELETE与TRUNCATE的区别？</h3>\n<blockquote>\n<p>用法不同、属于不同的数据库语言、执行速度不同</p>\n</blockquote>\n<details><summary>answer</summary>\n<p>drop（丢弃数据）</p>\n<p>属于DDL语言，<code>drop table 表名</code>删除整张表，不保留表的结构（定义），不能回滚，删除速度快。</p>\n<p>truncate（清空数据）</p>\n<p>属于DDL语言，<code>truncate table 表名</code>保留表的结构（定义）但删除表的所有数据，不能回滚，删除速度快</p>\n<p>delete（删除数据）</p>\n<p>属于DML语言，<code>delete from 表名 where 列名=值</code>删除表的部分数据行，如果不加<code>where</code>子句和<code>truncate table 表名</code>作用类似，可以回滚，删除速度慢</p>\n</details>\n<h3 id=\"union和union-all的区别\"> UNION和UNION ALL的区别？</h3>\n<details><summary>answer</summary>\n<p><code>UNION</code>和<code>UNION ALL</code>用于把来自多个<code>SELECT</code>语句的结果组合到一个结果集合中，<code>UNION</code>会把结果集合中重复的记录行删掉只保留一行，使用<code>UNION ALL</code>则会将所有记录返回，效率高于<code>UNION</code>。</p>\n</details>\n<h2 id=\"参考文献\"> 参考文献</h2>\n<p><a href=\"https://blog.csdn.net/trusause/article/details/79487807\" target=\"_blank\" rel=\"noopener noreferrer\">(37条消息) 死锁，更新锁，共享锁，排它锁，意向锁，乐观锁，悲观锁等名词解释及案例详解_trusause的博客-CSDN博客</a></p>\n<p><a href=\"https://baike.baidu.com/item/%E7%BA%A7%E8%81%94%E6%9B%B4%E6%96%B0/11036500?fr=aladdin.\" target=\"_blank\" rel=\"noopener noreferrer\">级联更新_百度百科 (baidu.com)</a></p>\n<p><a href=\"https://baike.baidu.com/item/%E6%A3%80%E6%9F%A5%E7%BA%A6%E6%9D%9F/10272981?fr=aladdin\" target=\"_blank\" rel=\"noopener noreferrer\">检查约束_百度百科 (baidu.com)</a></p>\n",
      "image": "https://img-blog.csdnimg.cn/img_convert/4717673e36966e0e4b33fccfd753f6ea.png",
      "date_published": "2022-04-04T14:19:55.000Z",
      "date_modified": "2022-04-04T14:19:55.000Z",
      "authors": [
        {
          "name": "RiverCold"
        }
      ],
      "tags": []
    },
    {
      "title": "计算机网络",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/interview/basics/network/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/interview/basics/network/",
      "content_html": "<h1 id=\"计算机网络\"> 计算机网络</h1>\n<ul>\n<li><a href=\"./计算机网络面试突击.html\">计算机网络面试突击</a></li>\n</ul>\n",
      "date_published": "2022-04-04T14:19:55.000Z",
      "date_modified": "2022-04-04T14:19:55.000Z",
      "authors": [
        {
          "name": "RiverCold"
        }
      ],
      "tags": []
    },
    {
      "title": "计算机网络面试突击",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/interview/basics/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/interview/basics/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB/",
      "content_html": "<h1 id=\"计算机网络面试突击\"> 计算机网络面试突击</h1>\n<h2 id=\"第三部分-传输层\"> 第三部分：传输层</h2>\n<h3 id=\"三次握手和四次挥手机制\"> 三次握手和四次挥手机制</h3>\n<p><strong>三次握手机制</strong></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/River-Cold/vuepress-theme-hope-image/img/三次握手.png\" alt=\"\" loading=\"lazy\"></p>\n<details><summary>answer1</summary>\n<p>三次握手是TCP连接的建立过程。在握手之前，主动打开连接的客户端结束CLOSE阶段，被动打开的服务端结束CLOSE阶段，并进入LISTEN阶段。随后进入三次握手阶段：</p>\n<ol>\n<li>客户端向服务器端发送连接请求报文，等待服务器确认</li>\n<li>服务器接收到客户端发送的连接请求报文，如果同意连接则回送确认报文</li>\n<li>客户端收到服务器回送的确认报文段后，还要向服务器给出确认，当服务器端收到客户端发送的确认收到服务器端回送报文的确认报文后，建立连接，完成三次握手。</li>\n</ol>\n</details>\n<p><strong>四次挥手机制</strong></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/River-Cold/vuepress-theme-hope-image/img/四次挥手.png\" alt=\"\" loading=\"lazy\"></p>\n<details><summary>answer1</summary>\n<p>四次挥手即TCP连接的释放，这里假设客户端主动释放连接。在挥手之前主动释放连接的客户端结束ESTABLISHED阶段，随后开始四次挥手：</p>\n<ol>\n<li>客户端向服务器端发送连接释放报文段，停止发送数据，客户端主动关闭TCP连接</li>\n<li>服务器端收到客户端发送的连接释放报文段，回送给客户端确认报文段，客户端收到服务器发送的确认报文段，客户端到服务器端方向的连接就释放了，连接半关闭</li>\n<li>若服务器端没有还要传送的数据，则向客户端发送连接释放报文段，服务器主动关闭TCP连接</li>\n<li>客户端收到服务器端的连接释放报文段，回送给服务器端确认报文段，等到时间达到计时器设置的2MSL（最长报文段寿命）后，连接彻底关闭</li>\n</ol>\n</details>\n<h3 id=\"为什么要进行三次握手-两次握手可以吗\"> 为什么要进行三次握手？两次握手可以吗？</h3>\n<p><strong>三次握手的目的</strong></p>\n<details><summary>answer1</summary>\n<p>三次握手的主要目的是确认自己和对方的发送和接收都是正常的，从而保证了双方能够进行可靠通信。</p>\n<p>若采用两次握手，当第二次握手后就建立连接的话，此时客户端知道服务器能够正常接收到自己发送的数据，而服务器并不知道客户端能否收到自己发送的数据</p>\n</details>\n<details><summary>answer2</summary>\n<p>保证双方都是双工通信</p>\n<p>第一次握手，服务端确认客户端的发送正常</p>\n<p>第二次握手，客户端确认服务端的收发正常</p>\n<p>第三次握手，服务端确认客户端的接收正常</p>\n</details>\n<p><strong>不使用两次握手的原因</strong></p>\n<details><summary>answer</summary>\n<p>防止已失效的连接请求报文段突然又传送到了服务端，造成双方的不同步，导致服务端资源浪费。</p>\n</details>\n<p><strong>不使用四次握手的原因</strong></p>\n<details><summary>answer</summary>\n<p>三次握手理论上已经可以建立可靠连接，使用更多的次数会造成资源浪费。</p>\n</details>\n<h3 id=\"为什么要四次挥手\"> 为什么要四次挥手</h3>\n<details><summary>answer1</summary>\n<p>TCP的连接是全双工的，两个方向的连接需要单独关闭。</p>\n</details>\n<details><summary>answer2</summary>\n<p>释放TCP连接时之所以需要四次挥手，是因为ACK确认报文和FIN释放连接报文是分别在两次握手中传输的。</p>\n<p>当主动方在数据传送结束后发出释放连接的通知，由于被动方可能还有必要的数据要处理，所以会先返回ACK确认收到报文。当被动方也没有数据再发送的时候，则发出连接释放通知，对方确认后才完全关闭TCP连接。</p>\n</details>\n<h3 id=\"tcp和udp的区别\"> TCP和UDP的区别</h3>\n<details><summary>answer</summary>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>是否面向连接</th>\n<th>传输可靠性</th>\n<th>传输形式</th>\n<th>传输效率</th>\n<th>所需资源</th>\n<th>应用场景</th>\n<th>首部字节</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>TCP</td>\n<td>是</td>\n<td>可靠，保证数据有序</td>\n<td>字节流</td>\n<td>低（慢）</td>\n<td>多</td>\n<td>文件传输、邮件传输</td>\n<td>20-60</td>\n</tr>\n<tr>\n<td>UDP</td>\n<td>否</td>\n<td>不可靠，不保证数据有序</td>\n<td>数据报文段</td>\n<td>高（快）</td>\n<td>少</td>\n<td>即时通讯、域名转换</td>\n<td>8个字节</td>\n</tr>\n</tbody>\n</table>\n</details>\n<h3 id=\"tcp协议如何保证可靠传输\"> TCP协议如何保证可靠传输？</h3>\n<details><summary>answer</summary>\n<p>（<strong>校序重流拥</strong>）</p>\n<ol>\n<li>数据分块：应用数据被分割成TCP认为最合适发送的数据块</li>\n<li>校验和：TCP将保持它首部和数据的校验和。这是一个端到端的校验和，**目的是检测数据在传输过程中的任何变化。**如果接收端的校验和有差错，TCP将丢弃这个报文段和不确认收到此报文段。</li>\n<li>序列号和确认应答：**TCP给发送的每一个字节进行编号，在传输的过程中，每次接收方收到数据后，都会对传输方进行确认应答，即发送ACK报文，这个ACK报文中有对应的确认序列号ack，告诉发送方成功接收了哪些数据以及下一次的数据从哪里开始发。**除此之外，接收方可以根据序列号对数据报进行排序，把有序数据传送给应用层，并丢弃重复的数据。</li>\n<li>超时重传：**当TCP发出一个报文段后，它启动一个定时器，等待目的端确认收到这个报文段。**如果超过某个时间还没有收到确认，将重发这个报文段。</li>\n<li>流量控制：**TCP连接的双方都有一个固定大小的缓冲空间，发送方发送的数据不能超过接收端缓冲区的大小，**当接收方来不及处理发送方的数据，会提示发送方降低发送的速率，防止产生丢包。<strong>TCP通过滑动窗口协议来支持流量控制机制。</strong></li>\n<li>拥塞控制：当网络中某个节点发生拥塞时，减少数据的发送。</li>\n<li>自动重传请求（Automatic Repeat-reQuest，ARQ）是OSI模型中数据链路层和传输层的错误纠正协议之一。<strong>它通过确认和超时两个机制，基本原理是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</strong></li>\n</ol>\n</details>\n",
      "image": "https://cdn.jsdelivr.net/gh/River-Cold/vuepress-theme-hope-image/img/三次握手.png",
      "date_published": "2022-04-04T14:19:55.000Z",
      "date_modified": "2022-04-04T14:19:55.000Z",
      "authors": [
        {
          "name": "RiverCold"
        }
      ],
      "tags": []
    },
    {
      "title": "自定义布局",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/layout/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/layout/",
      "content_html": "<p>您可以使用带有 Markdown 支持的插槽来自定义页面布局。</p>\n<div><p>注意</p>\n<p>此处仅仅是一个演示，你应该自行根据需求添加样式。</p>\n\n\n</div>\n<template #page-top><p>页面顶部内容</p>\n</template><template #page-bottom><p>页面底部内容</p>\n</template><template #content-top><p>内容顶部内容</p>\n</template><template #content-bottom><p>内容底部内容</p>\n</template><template #navbar-start><p>导航栏起始内容</p>\n</template><template #navbar-center><p>导航栏中部内容</p>\n</template><template #navbar-end><p>导航栏末尾内容</p>\n</template><template #sidebar-top><p>侧边栏顶部内容</p>\n</template><template #sidebar-center><p>侧边栏中部内容</p>\n</template><template #sidebar-bottom><p>侧边栏底部内容</p>\n</template><p>更多详情，详见 <a href=\"https://vuepress-theme-hope.github.io/zh/guide/layout/custom/\" target=\"_blank\" rel=\"noopener noreferrer\">自定义布局</a>.</p>\n",
      "date_published": "2022-04-04T14:19:55.000Z",
      "date_modified": "2022-04-04T14:19:55.000Z",
      "authors": [
        {
          "name": "RiverCold"
        }
      ],
      "tags": []
    },
    {
      "title": "readme",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/life/Annual-Summary/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/life/Annual-Summary/",
      "content_html": "<h1 id=\"readme\"> readme</h1>\n",
      "date_published": "2022-04-04T14:19:55.000Z",
      "date_modified": "2022-04-04T14:19:55.000Z",
      "authors": [
        {
          "name": "RiverCold"
        }
      ],
      "tags": []
    },
    {
      "title": "readme",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/life/Travel-Records/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/life/Travel-Records/",
      "content_html": "<h1 id=\"readme\"> readme</h1>\n",
      "date_published": "2022-04-04T14:19:55.000Z",
      "date_modified": "2022-04-04T14:19:55.000Z",
      "authors": [
        {
          "name": "RiverCold"
        }
      ],
      "tags": []
    },
    {
      "title": "博客主页",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/",
      "content_html": "<p>这是一个博客主页。</p>\n<p>要使用此布局，您应该在页面前端设置 <code>blog: true</code> 和 <code>home: true</code>。</p>\n<p>相关配置文档请见 <a href=\"https://vuepress-theme-hope.github.io/zh/guide/blog/home/\" target=\"_blank\" rel=\"noopener noreferrer\">博客主页</a></p>\n",
      "date_published": "2022-04-04T14:19:55.000Z",
      "date_modified": "2022-04-04T14:19:55.000Z",
      "authors": [
        {
          "name": "RiverCold"
        }
      ],
      "tags": []
    },
    {
      "title": "readme",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/school/high-school/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/school/high-school/",
      "content_html": "<h1 id=\"readme\"> readme</h1>\n<p>Hello High-School!</p>\n",
      "date_published": "2022-04-04T14:19:55.000Z",
      "date_modified": "2022-04-04T14:19:55.000Z",
      "authors": [
        {
          "name": "RiverCold"
        }
      ],
      "tags": []
    },
    {
      "title": "readme",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/school/junior-high-school/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/school/junior-high-school/",
      "content_html": "<h1 id=\"readme\"> readme</h1>\n<p>Hello Junior-High-School!</p>\n",
      "date_published": "2022-04-04T14:19:55.000Z",
      "date_modified": "2022-04-04T14:19:55.000Z",
      "authors": [
        {
          "name": "RiverCold"
        }
      ],
      "tags": []
    },
    {
      "title": "readme",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/school/master/paper/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/school/master/paper/",
      "content_html": "<h1 id=\"readme\"> readme</h1>\n<p>Hello Master-School!</p>\n<ul>\n<li><a href=\"./文献阅读笔记模板.html\">文献阅读笔记模板</a></li>\n</ul>\n",
      "date_published": "2022-04-04T14:19:55.000Z",
      "date_modified": "2022-04-04T14:19:55.000Z",
      "authors": [
        {
          "name": "RiverCold"
        }
      ],
      "tags": []
    },
    {
      "title": "{Title}（文章标题）{Year}, {Authors}, {Journal Name}{引用格式}",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/school/master/paper/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E6%A8%A1%E6%9D%BF/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/school/master/paper/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E6%A8%A1%E6%9D%BF/",
      "content_html": "<h1 id=\"title-文章标题-year-authors-journal-name-引用格式\"> {Title}（文章标题）{Year}, {Authors}, {Journal Name}{引用格式}</h1>\n<h2 id=\"summary\"> Summary</h2>\n<p>写完笔记之后最后填，概述文章的内容，以后查阅笔记的时候先看这一段。注：写文章summary切记需要通过自己的思考，用自己的语言描述。忌讳直接Ctrl + c原文。</p>\n<h2 id=\"research-objective-s\"> Research Objective(s)</h2>\n<p>作者的研究目标是什么？</p>\n<h2 id=\"background-problem-statement\"> Background / Problem Statement</h2>\n<p>研究的背景以及问题陈述：作者需要解决的问题是什么？</p>\n<h2 id=\"method-s\"> Method(s)</h2>\n<p>作者解决问题的方法/算法是什么？是否基于前人的方法？基于了哪些？</p>\n<h2 id=\"evaluation\"> Evaluation</h2>\n<p>作者如何评估自己的方法？实验的setup是什么样的？感兴趣实验数据和结果有哪些？有没有问题或者可以借鉴的地方？</p>\n<h2 id=\"conclusion\"> Conclusion</h2>\n<p>作者给出了哪些结论？哪些是strong conclusions, 哪些又是weak的<a href=\"https://www.zhihu.com/search?q=conclusions&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A142802496%7D\" target=\"_blank\" rel=\"noopener noreferrer\">conclusions</a>（即作者并没有通过实验提供evidence，只在<a href=\"https://www.zhihu.com/search?q=discussion&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A142802496%7D\" target=\"_blank\" rel=\"noopener noreferrer\">discussion</a>中提到；或实验的数据并没有给出充分的evidence）?</p>\n<h2 id=\"notes\"> Notes</h2>\n<p>(optional) 不在以上列表中，但需要特别记录的笔记。</p>\n<h2 id=\"references\"> References</h2>\n<p>(optional) 列出相关性高的文献，以便之后可以继续track下去。</p>\n<p><img src=\"https://pic1.zhimg.com/v2-656b65c906c28f9f6ea6fa9ed7521933_r.jpg?source=3af55fa1\" alt=\"preview\" loading=\"lazy\"></p>\n",
      "image": "https://pic1.zhimg.com/v2-656b65c906c28f9f6ea6fa9ed7521933_r.jpg?source=3af55fa1",
      "date_published": "2022-04-04T14:19:55.000Z",
      "date_modified": "2022-04-04T14:19:55.000Z",
      "authors": [
        {
          "name": "RiverCold"
        }
      ],
      "tags": []
    },
    {
      "title": "readme in school",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/school/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/school/",
      "content_html": "<h1 id=\"readme-in-school\"> readme in school</h1>\n",
      "date_published": "2022-04-04T14:19:55.000Z",
      "date_modified": "2022-04-04T14:19:55.000Z",
      "authors": [
        {
          "name": "RiverCold"
        }
      ],
      "tags": []
    },
    {
      "title": "readme",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/school/university/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/school/university/",
      "content_html": "<h1 id=\"readme\"> readme</h1>\n<p>Hello University!</p>\n",
      "date_published": "2022-04-04T14:19:55.000Z",
      "date_modified": "2022-04-04T14:19:55.000Z",
      "authors": [
        {
          "name": "RiverCold"
        }
      ],
      "tags": []
    },
    {
      "title": "幻灯片页",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/slides/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/slides/",
      "content_html": "\n<i>Not supported content</i>",
      "image": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/logo.svg",
      "date_published": "2022-04-04T14:19:55.000Z",
      "date_modified": "2022-04-04T14:19:55.000Z",
      "authors": [
        {
          "name": "RiverCold"
        }
      ],
      "tags": []
    },
    {
      "title": "JavaDoc",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/software/programming/jetbrains/idea%E6%8F%92%E4%BB%B6/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/software/programming/jetbrains/idea%E6%8F%92%E4%BB%B6/",
      "content_html": "<h1 id=\"javadoc\"> JavaDoc</h1>\n<h2 id=\"概念\"> 概念</h2>\n<p>Javadoc 是 Sun 公司提供的一种工具，它可以从程序源代码中抽取类、方法、成员等注释，然后形成一个和源代码配套的 API 帮助文档。也就是说，只要在编写程序时以一套特定的标签注释，在程序编写完成后，通过 Javadoc 就形成了程序的 API 帮助文档。</p>\n<h2 id=\"插件名称\"> 插件名称</h2>\n<p>easy-javadoc</p>\n<h2 id=\"参考文献\"> 参考文献</h2>\n<p><a href=\"http://c.biancheng.net/view/6262.html\" target=\"_blank\" rel=\"noopener noreferrer\">Javadoc（文档注释）详解 (biancheng.net)</a></p>\n<p><a href=\"https://www.jianshu.com/p/bac203e34578\" target=\"_blank\" rel=\"noopener noreferrer\">编程工具-idea配置-JavaDoc官方插件 - 简书 (jianshu.com)</a></p>\n",
      "date_published": "2022-04-04T14:19:55.000Z",
      "date_modified": "2022-04-04T14:19:55.000Z",
      "authors": [
        {
          "name": "RiverCold"
        }
      ],
      "tags": []
    },
    {
      "title": "File -> Setting -> Editor -> General",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/software/programming/jetbrains/idea%E8%AE%BE%E7%BD%AE/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/software/programming/jetbrains/idea%E8%AE%BE%E7%BD%AE/",
      "content_html": "<h2 id=\"file-setting-editor-general\"> File -&gt; Setting -&gt; Editor -&gt; General</h2>\n<p><img src=\"https://cdn.jsdelivr.net/gh/River-Cold/vuepress-theme-hope-image/img/idea鼠标控制放大缩小.png\" alt=\"\" loading=\"lazy\"></p>\n",
      "image": "https://cdn.jsdelivr.net/gh/River-Cold/vuepress-theme-hope-image/img/idea鼠标控制放大缩小.png",
      "date_published": "2022-04-04T14:19:55.000Z",
      "date_modified": "2022-04-04T14:19:55.000Z",
      "authors": [
        {
          "name": "RiverCold"
        }
      ],
      "tags": []
    },
    {
      "title": "maven安装",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/software/programming/maven/maven%E5%AE%89%E8%A3%85/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/software/programming/maven/maven%E5%AE%89%E8%A3%85/",
      "content_html": "<h1 id=\"maven安装\"> maven安装</h1>\n<h3 id=\"参考文献\"> 参考文献</h3>\n<p><a href=\"https://blog.csdn.net/qq_41895190/article/details/89741123\" target=\"_blank\" rel=\"noopener noreferrer\">(44条消息) win10下 Maven的安装与配置(配置本地仓库路径)_qq_41895190的博客-CSDN博客_maven配置本地仓库</a></p>\n",
      "date_published": "2022-04-04T14:19:55.000Z",
      "date_modified": "2022-04-04T14:19:55.000Z",
      "authors": [
        {
          "name": "RiverCold"
        }
      ],
      "tags": []
    },
    {
      "title": "maven踩坑",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/software/programming/maven/maven%E8%B8%A9%E5%9D%91/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/software/programming/maven/maven%E8%B8%A9%E5%9D%91/",
      "content_html": "<h1 id=\"maven踩坑\"> maven踩坑</h1>\n<p>maven下载不到源码：Cannot download sources Sources not found for:</p>\n<h2 id=\"参考文献\"> 参考文献</h2>\n<p><a href=\"https://blog.csdn.net/maoyuanming0806/article/details/120079191\" target=\"_blank\" rel=\"noopener noreferrer\">(63条消息) maven下载不到源码：Cannot download sources Sources not found for:_小明同学YYDS的博客-CSDN博客</a></p>\n",
      "date_published": "2022-04-04T14:19:55.000Z",
      "date_modified": "2022-04-04T14:19:55.000Z",
      "authors": [
        {
          "name": "RiverCold"
        }
      ],
      "tags": []
    },
    {
      "title": "编程软件",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/software/programming/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/software/programming/",
      "content_html": "<h1 id=\"编程软件\"> 编程软件</h1>\n<h2 id=\"代码编辑器\"> 代码编辑器</h2>\n<ul>\n<li><a href=\"./jetbrains/\">jetbrains</a></li>\n</ul>\n<h2 id=\"其他工具\"> 其他工具</h2>\n<ul>\n<li><a href=\"./maven/\">maven</a></li>\n<li><a href=\"./vmware/\">vmware</a></li>\n</ul>\n",
      "date_published": "2022-04-04T14:19:55.000Z",
      "date_modified": "2022-04-04T14:19:55.000Z",
      "authors": [
        {
          "name": "RiverCold"
        }
      ],
      "tags": []
    },
    {
      "title": "Ubuntu18.04 IP固定设置",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/software/programming/vmware/ip/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/software/programming/vmware/ip/",
      "content_html": "<h1 id=\"ubuntu18-04-ip固定设置\"> Ubuntu18.04 IP固定设置</h1>\n<h2 id=\"_1-操作步骤\"> 1. 操作步骤</h2>\n<h3 id=\"_1-1-选择有线设置\"> 1.1 选择有线设置</h3>\n<p><img src=\"https://cdn.jsdelivr.net/gh/River-Cold/vuepress-theme-hope-image/img/固定ip_01.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_1-2-打开有线连接设置\"> 1.2 打开有线连接设置</h3>\n<p><img src=\"https://cdn.jsdelivr.net/gh/River-Cold/vuepress-theme-hope-image/img/固定ip_02.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_1-3-选择ipv4\"> 1.3 选择IPv4</h3>\n<p><img src=\"https://cdn.jsdelivr.net/gh/River-Cold/vuepress-theme-hope-image/img/固定ip_03.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_1-4-选择手动、填写ip、子网掩码、网关、dns-并选择应用\"> 1.4 选择手动、填写IP、子网掩码、网关、DNS，并选择应用</h3>\n<p><img src=\"https://cdn.jsdelivr.net/gh/River-Cold/vuepress-theme-hope-image/img/固定ip_04.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_2-参考文献\"> 2. 参考文献</h2>\n<p><a href=\"https://blog.csdn.net/didadidame/article/details/120759975\" target=\"_blank\" rel=\"noopener noreferrer\">Ubuntu18.04 IP固定设置</a></p>\n",
      "image": "https://cdn.jsdelivr.net/gh/River-Cold/vuepress-theme-hope-image/img/固定ip_01.png",
      "date_published": "2022-04-04T14:19:55.000Z",
      "date_modified": "2022-04-04T14:19:55.000Z",
      "authors": [
        {
          "name": "RiverCold"
        }
      ],
      "tags": []
    },
    {
      "title": "剑指offer",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/solution/leetcode/CodingInterview/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/solution/leetcode/CodingInterview/",
      "content_html": "<h1 id=\"剑指offer\"> 剑指offer</h1>\n<ul>\n<li><a href=\"./二维数组中的查找.html\">二维数组中的查找</a></li>\n</ul>\n",
      "date_published": "2022-04-04T14:19:55.000Z",
      "date_modified": "2022-04-04T14:19:55.000Z",
      "authors": [
        {
          "name": "RiverCold"
        }
      ],
      "tags": []
    },
    {
      "title": "二维数组中的查找",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/solution/leetcode/CodingInterview/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/solution/leetcode/CodingInterview/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/",
      "content_html": "<h1 id=\"二维数组中的查找\"> <a href=\"https://www.nowcoder.com/practice/abc3fe2ce8e146608e868a70efebf62e?tpId=13&amp;&amp;tqId=11154&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking\" target=\"_blank\" rel=\"noopener noreferrer\">二维数组中的查找</a></h1>\n<h2 id=\"题目描述\"> 题目描述</h2>\n<p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>\n<h2 id=\"示例1\"> 示例1</h2>\n<blockquote>\n<p>输入</p>\n<div><pre><code>7,[[1,2,8,9],[2,4,9,12],[4,7,10,13],[6,8,11,15]]\n</code></pre>\n<div><span>1</span><br></div></div><p>返回值</p>\n<div><pre><code>true\n</code></pre>\n<div><span>1</span><br></div></div></blockquote>\n<h2 id=\"分析\"> 分析</h2>\n<h3 id=\"方案一-二分\"> 方案一：二分</h3>\n<p>数组每一行均为有序数组，满足使用二分查找的前提条件</p>\n<p>依次对数组每一行进行二分查找，若找到则返回true，遍历完所有行均未找到则返回false</p>\n<h3 id=\"代码\"> 代码</h3>\n<div><pre><code><span>/**\n复杂度分析\n1.时间复杂度:O(nlogn)\n2.空间复杂度:O(1)\n**/</span>\n<span>bool</span> <span>Find</span><span>(</span><span>int</span> target<span>,</span> vector<span>&lt;</span>vector<span>&lt;</span><span>int</span><span>>></span> array<span>)</span>\n<span>{</span>\n    <span>int</span> rows <span>=</span> array<span>.</span><span>size</span><span>(</span><span>)</span><span>;</span><span>//rows:数组行数</span>\n    <span>// 依次对数组每一行进行二分查找</span>\n    <span>for</span><span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> rows<span>;</span> i<span>++</span><span>)</span><span>{</span>\n        <span>// 若待查找元素在第i行找到，则提前终止查找，返回true; 否则继续查找下一行</span>\n        <span>if</span><span>(</span><span>binary_search</span><span>(</span>array<span>[</span>i<span>]</span><span>.</span><span>begin</span><span>(</span><span>)</span><span>,</span> array<span>[</span>i<span>]</span><span>.</span><span>end</span><span>(</span><span>)</span><span>,</span> target<span>)</span><span>)</span><span>{</span>\n            <span>return</span> <span>true</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n    <span>// 若待查找元素在所有行中都未找到，则返回false</span>\n    <span>return</span> <span>false</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h3 id=\"方案二-利用数组性质\"> 方案二：利用数组性质</h3>\n<p>每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序</p>\n<p>从矩阵的左下角看，上方的数字都比其小，右方的数字都比其大</p>\n<p>设当前数字为 cur，目标数字为 target</p>\n<ul>\n<li>\n<p>当 target &lt; cur 时，行数减1，cur 更新为其上面一行的数字</p>\n</li>\n<li>\n<p>当 target &gt; cur 时，列数加1，cur 更新为其右侧一列的数字</p>\n</li>\n<li>\n<p>当 cur == target 时则返回 true</p>\n</li>\n<li>\n<p>否则当行数或列数超过矩阵边界时返回 false</p>\n</li>\n</ul>\n<h3 id=\"代码-2\"> 代码</h3>\n<div><pre><code><span>/**\n复杂度分析\n1.时间复杂度:O(m+n)\n2.空间复杂度:O(1)\n**/</span>\n<span>bool</span> <span>Find</span><span>(</span><span>int</span> target<span>,</span> vector<span>&lt;</span>vector<span>&lt;</span><span>int</span><span>>></span> array<span>)</span>\n<span>{</span>\n    <span>int</span> rows <span>=</span> array<span>.</span><span>size</span><span>(</span><span>)</span><span>;</span><span>//rows:数组行数</span>\n    <span>int</span> cols <span>=</span> array<span>[</span><span>0</span><span>]</span><span>.</span><span>size</span><span>(</span><span>)</span><span>;</span><span>//cols:数组列数</span>\n    <span>int</span> i <span>=</span> rows <span>-</span> <span>1</span><span>,</span> j <span>=</span> <span>0</span><span>;</span><span>//i:行坐标,j:列坐标,初始位置为左下角元素</span>\n    <span>while</span> <span>(</span>i <span>>=</span> <span>0</span> <span>&amp;&amp;</span> j <span>&lt;</span> cols<span>)</span>\n    <span>{</span>\n        <span>int</span> cur <span>=</span> array<span>[</span>i<span>]</span><span>[</span>j<span>]</span><span>;</span>\n        <span>// 当 target &lt; cur 时，行数减1，cur 更新为其上面一行的数字</span>\n        <span>if</span> <span>(</span>target <span>&lt;</span> cur<span>)</span>\n        <span>{</span>\n            i<span>--</span><span>;</span>\n        <span>}</span>\n        <span>// 当 target > cur 时，列数加1，cur 更新为其右侧一列的数字</span>\n        <span>else</span> <span>if</span> <span>(</span>target <span>></span> cur<span>)</span>\n        <span>{</span>\n            j<span>++</span><span>;</span>\n        <span>}</span>\n        <span>// 当 cur == target 时返回 true</span>\n        <span>else</span>\n        <span>{</span>\n            <span>return</span> <span>true</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n    <span>// 当行数或列数超过矩阵边界时返回 false</span>\n    <span>return</span> <span>false</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br></div></div>",
      "date_published": "2022-04-04T14:19:55.000Z",
      "date_modified": "2022-04-04T14:19:55.000Z",
      "authors": [
        {
          "name": "RiverCold"
        }
      ],
      "tags": []
    },
    {
      "title": "1.md",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/solution/leetcode/Cracking-the-Coding-Interview/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/solution/leetcode/Cracking-the-Coding-Interview/",
      "content_html": "<h1 id=\"_1-md\"> 1.md</h1>\n<p>Cracking-the-Coding-Interview!</p>\n",
      "date_published": "2022-04-04T14:19:55.000Z",
      "date_modified": "2022-04-04T14:19:55.000Z",
      "authors": [
        {
          "name": "RiverCold"
        }
      ],
      "tags": []
    },
    {
      "title": "1.两数之和",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/solution/leetcode/LeetCode-hot-topic-HOT-100/1.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/solution/leetcode/LeetCode-hot-topic-HOT-100/1.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/",
      "content_html": "<h1 id=\"_1-两数之和\"> <a href=\"https://leetcode-cn.com/problems/two-sum/\" target=\"_blank\" rel=\"noopener noreferrer\">1.两数之和</a></h1>\n<p><img src=\"https://cdn.jsdelivr.net/gh/River-Cold/pictureBed/vuepress-blog/solution/leetcode/LeetCode-hot-topic-HOT-100/1.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"方法一-哈希表\"> 方法一：哈希表</h2>\n<div><p>提示</p>\n<p>创建一个哈希表，对于每一个 <code>x</code>，我们首先查询哈希表中是否存在 <code>target - x</code>，然后将 <code>x</code> 插入到哈希表中，即可保证不会让 <code>x</code> 和自己匹配。</p>\n</div>\n<h2 id=\"参考代码\"> 参考代码</h2>\n<CodeGroup>\n<CodeGroupItem title=\"c++\">\n<div><pre><code><span>class</span> <span>Solution</span> <span>{</span>\n<span>public</span><span>:</span>\n    vector<span>&lt;</span><span>int</span><span>></span> <span>twoSum</span><span>(</span>vector<span>&lt;</span><span>int</span><span>></span><span>&amp;</span> nums<span>,</span> <span>int</span> target<span>)</span> <span>{</span>\n        <span>// 使用map记录所有出现过的数字最后一次出现的下标</span>\n        unordered_map<span>&lt;</span><span>int</span><span>,</span> <span>int</span><span>></span> dic<span>;</span>\n        <span>for</span><span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> nums<span>.</span><span>size</span><span>(</span><span>)</span><span>;</span> i<span>++</span><span>)</span><span>{</span>\n            dic<span>[</span>nums<span>[</span>i<span>]</span><span>]</span> <span>=</span> i<span>;</span>\n        <span>}</span>\n        <span>// 然后查找target - num的元素是否在map中出现过</span>\n        <span>for</span><span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> nums<span>.</span><span>size</span><span>(</span><span>)</span><span>;</span> i<span>++</span><span>)</span><span>{</span>\n            <span>int</span> num2 <span>=</span> target <span>-</span> nums<span>[</span>i<span>]</span><span>;</span>\n            <span>// 如果出现过，则返回两个元素的数组下标</span>\n            <span>if</span><span>(</span>dic<span>[</span>num2<span>]</span> <span>&amp;&amp;</span> dic<span>[</span>num2<span>]</span> <span>!=</span> i<span>)</span><span>{</span>\n                <span>return</span> <span>{</span>i<span>,</span> dic<span>[</span>num2<span>]</span><span>}</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n        <span>return</span> <span>{</span><span>}</span><span>;</span>\n    <span>}</span>\n<span>}</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div></CodeGroupItem>\n<CodeGroupItem title=\"c++\" active>\n<div><pre><code><span>class</span> <span>Solution</span> <span>{</span>\n<span>public</span><span>:</span>\n    vector<span>&lt;</span><span>int</span><span>></span> <span>twoSum</span><span>(</span>vector<span>&lt;</span><span>int</span><span>></span><span>&amp;</span> nums<span>,</span> <span>int</span> target<span>)</span> <span>{</span>\n        <span>int</span> n <span>=</span> nums<span>.</span><span>size</span><span>(</span><span>)</span><span>;</span>\n        <span>// 使用map记录所有出现过的数字出现的下标</span>\n        unordered_map<span>&lt;</span><span>int</span><span>,</span> <span>int</span><span>></span> dic<span>;</span>\n        <span>for</span><span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> n<span>;</span> i<span>++</span><span>)</span><span>{</span>\n            <span>int</span> num <span>=</span> target <span>-</span> nums<span>[</span>i<span>]</span><span>;</span>\n            <span>// 查询哈希表中是否存在 target - nums[i]，若存在直接返回下标</span>\n            <span>if</span><span>(</span>dic<span>.</span><span>find</span><span>(</span>num<span>)</span> <span>!=</span> dic<span>.</span><span>end</span><span>(</span><span>)</span><span>)</span><span>{</span>\n                <span>return</span> <span>{</span>i<span>,</span> dic<span>[</span>num<span>]</span><span>}</span><span>;</span>\n            <span>}</span>\n            <span>// 如果不存在则将当前元素和其下标插入哈希表</span>\n            dic<span>[</span>nums<span>[</span>i<span>]</span><span>]</span> <span>=</span> i<span>;</span>\n        <span>}</span>\n        <span>return</span> <span>{</span><span>}</span><span>;</span>\n    <span>}</span>\n<span>}</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div></CodeGroupItem>\n</CodeGroup>\n",
      "image": "https://cdn.jsdelivr.net/gh/River-Cold/pictureBed/vuepress-blog/solution/leetcode/LeetCode-hot-topic-HOT-100/1.png",
      "date_published": "2022-04-04T14:19:55.000Z",
      "date_modified": "2022-04-04T14:19:55.000Z",
      "authors": [
        {
          "name": "RiverCold"
        }
      ],
      "tags": []
    },
    {
      "title": "121.买卖股票的最佳时机",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/solution/leetcode/LeetCode-hot-topic-HOT-100/121.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/solution/leetcode/LeetCode-hot-topic-HOT-100/121.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/",
      "content_html": "<h1 id=\"_121-买卖股票的最佳时机\"> 121.买卖股票的最佳时机</h1>\n<p>https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/River-Cold/pictureBed/vuepress-blog/solution/leetcode/LeetCode-hot-topic-HOT-100/121.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"方法一-动态规划\"> 方法一：动态规划</h2>\n<h3 id=\"思路分析\"> 思路分析</h3>\n<div><p>提示</p>\n<p>考虑每次如何获取最大收益？第i天的最大收益只需要知道前i天的最低点就可以算出来了。而第i天以前（包括第i天）的最低点和i-1天的最低点有关。则设<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>d</span><span>p</span><span>[</span><span>i</span><span>]</span></span></span></span>代表第i天以前（包括第i天）的最低点，状态转移方程为：</p>\n<p class='katex-block'><span><span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>d</span><span>p</span><span>[</span><span>i</span><span>]</span><span style=\"margin-right:0.2778em;\"></span><span>=</span><span style=\"margin-right:0.2778em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>min</span><span>(</span><span>d</span><span>p</span><span>[</span><span>i</span><span style=\"margin-right:0.2222em;\"></span><span>−</span><span style=\"margin-right:0.2222em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>1</span><span>]</span><span>,</span><span style=\"margin-right:0.1667em;\"></span><span>p</span><span style=\"margin-right:0.02778em;\">r</span><span>i</span><span>ce</span><span>[</span><span>i</span><span>])</span></span></span></span></span></p>\n<p>在第<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.6595em;\"></span><span>i</span></span></span></span>天能卖出股票得到的利润为</p>\n<p class='katex-block'><span><span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>p</span><span style=\"margin-right:0.02778em;\">r</span><span>i</span><span>ces</span><span>[</span><span>i</span><span>]</span><span style=\"margin-right:0.2222em;\"></span><span>−</span><span style=\"margin-right:0.2222em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>d</span><span>p</span><span>[</span><span>i</span><span style=\"margin-right:0.2222em;\"></span><span>−</span><span style=\"margin-right:0.2222em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>1</span><span>]</span></span></span></span></span></p>\n</div>\n<h3 id=\"参考代码\"> 参考代码</h3>\n<CodeGroup>\n<CodeGroupItem title=\"c++\">\n<div><pre><code><span>class</span> <span>Solution</span> <span>{</span>\n<span>public</span><span>:</span>\n    <span>int</span> <span>maxProfit</span><span>(</span>vector<span>&lt;</span><span>int</span><span>></span><span>&amp;</span> prices<span>)</span> <span>{</span>\n        <span>int</span> n <span>=</span> prices<span>.</span><span>size</span><span>(</span><span>)</span><span>;</span>\n        <span>int</span> maxprofit <span>=</span> <span>0</span><span>;</span>\n\n        vector<span>&lt;</span><span>int</span><span>></span> <span>dp</span><span>(</span>n<span>)</span><span>;</span>\n        dp<span>[</span><span>0</span><span>]</span> <span>=</span> prices<span>[</span><span>0</span><span>]</span><span>;</span>\n\n        <span>for</span><span>(</span><span>int</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;</span> n<span>;</span> i<span>++</span><span>)</span><span>{</span>\n            dp<span>[</span>i<span>]</span> <span>=</span> <span>(</span>dp<span>[</span>i <span>-</span> <span>1</span><span>]</span> <span>&lt;</span> prices<span>[</span>i<span>]</span><span>)</span> <span>?</span> dp<span>[</span>i <span>-</span> <span>1</span><span>]</span> <span>:</span> prices<span>[</span>i<span>]</span><span>;</span>\n            maxprofit <span>=</span> <span>(</span>prices<span>[</span>i<span>]</span> <span>-</span> dp<span>[</span>i<span>]</span><span>)</span> <span>></span> maxprofit <span>?</span> prices<span>[</span>i<span>]</span> <span>-</span> dp<span>[</span>i<span>]</span> <span>:</span> maxprofit<span>;</span>\n        <span>}</span>\n        \n        <span>return</span> maxprofit<span>;</span>\n    <span>}</span>\n<span>}</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div></CodeGroupItem>\n</CodeGroup>\n<h2 id=\"方法一-空间优化\"> 方法一：空间优化</h2>\n<h3 id=\"思路分析-2\"> 思路分析</h3>\n<div><p>提示</p>\n<p>方法一的每次状态转移只使用到了<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>d</span><span>p</span><span>[</span><span>i</span><span style=\"margin-right:0.2222em;\"></span><span>−</span><span style=\"margin-right:0.2222em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>1</span><span>]</span></span></span></span>这一个空间，因此可以使用单个变量<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.854em;vertical-align:-0.1944em;\"></span><span>min</span><span>p</span><span style=\"margin-right:0.02778em;\">r</span><span>i</span><span>ce</span></span></span></span>来存储截止到第<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.6595em;\"></span><span>i</span></span></span></span>天（不包括第<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.6595em;\"></span><span>i</span></span></span></span>天）的价格最低点。</p>\n</div>\n<h3 id=\"参考代码-2\"> 参考代码</h3>\n<CodeGroup>\n<CodeGroupItem title=\"c++\">\n<div><pre><code><span>class</span> <span>Solution</span> <span>{</span>\n<span>public</span><span>:</span>\n    <span>int</span> <span>maxProfit</span><span>(</span>vector<span>&lt;</span><span>int</span><span>></span><span>&amp;</span> prices<span>)</span> <span>{</span>\n        <span>int</span> inf <span>=</span> <span>1e9</span><span>;</span>\n        <span>int</span> minprice <span>=</span> inf<span>,</span> maxprofit <span>=</span> <span>0</span><span>;</span>\n        <span>for</span><span>(</span><span>int</span> price <span>:</span> prices<span>)</span><span>{</span>\n            maxprofit <span>=</span> <span>max</span><span>(</span>maxprofit<span>,</span> price <span>-</span> minprice<span>)</span><span>;</span>\n            minprice <span>=</span> <span>min</span><span>(</span>minprice<span>,</span> price<span>)</span><span>;</span>\n        <span>}</span>\n        <span>return</span> maxprofit<span>;</span>\n    <span>}</span>\n<span>}</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div></CodeGroupItem>\n</CodeGroup>\n",
      "image": "https://cdn.jsdelivr.net/gh/River-Cold/pictureBed/vuepress-blog/solution/leetcode/LeetCode-hot-topic-HOT-100/121.png",
      "date_published": "2022-04-04T14:19:55.000Z",
      "date_modified": "2022-04-04T14:19:55.000Z",
      "authors": [
        {
          "name": "RiverCold"
        }
      ],
      "tags": []
    },
    {
      "title": "139.单词拆分",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/solution/leetcode/LeetCode-hot-topic-HOT-100/139.%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/solution/leetcode/LeetCode-hot-topic-HOT-100/139.%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86/",
      "content_html": "<h1 id=\"_139-单词拆分\"> 139.单词拆分</h1>\n<p>https://leetcode-cn.com/problems/word-break/</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/River-Cold/pictureBed/vuepress-blog/solution/leetcode/LeetCode-hot-topic-HOT-100/139.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"方法一-字典树-dfs-记忆化\"> 方法一：字典树+dfs+记忆化</h2>\n<h3 id=\"思路分析\"> 思路分析</h3>\n<div><p>提示</p>\n<p>设字符串s的长度为n，单词列表wordDict的长度为m，单词列表中每个单词的最大长度为len</p>\n<p>首先暴力的想法是枚举字符串s的从起点startPos开始截取的所有可能子串，将子串和wordDict中的单词一一匹配，成功则继续递归搜索，直到搜索到s的末尾时结束。但是这样的时间复杂度最坏会达到<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span style=\"margin-right:0.02778em;\">O</span><span>(</span><span><span>n</span><span><span><span><span style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span>2</span></span></span></span></span></span></span></span><span style=\"margin-right:0.2222em;\"></span><span>∗</span><span style=\"margin-right:0.2222em;\"></span></span><span><span style=\"height:0.4653em;\"></span><span>m</span><span style=\"margin-right:0.2222em;\"></span><span>∗</span><span style=\"margin-right:0.2222em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span style=\"margin-right:0.01968em;\">l</span><span>e</span><span>n</span><span>)</span></span></span></span>，会产生TLE超时错误。</p>\n<p>根据提示中s和WordDict[i]仅有小写英文字母组成，我们可以想到使用字典树<code>trie</code>来进行单词的快速查找，这样可以将时间复杂度降到<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span style=\"margin-right:0.02778em;\">O</span><span>(</span><span><span>n</span><span><span><span><span style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span>2</span></span></span></span></span></span></span></span><span style=\"margin-right:0.2222em;\"></span><span>∗</span><span style=\"margin-right:0.2222em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span style=\"margin-right:0.01968em;\">l</span><span>e</span><span>n</span><span>)</span></span></span></span>，但是当面对类似下面的</p>\n<div><pre><code>&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab&quot;\n[&quot;a&quot;,&quot;aa&quot;,&quot;aaa&quot;,&quot;aaaa&quot;,&quot;aaaaa&quot;,&quot;aaaaaa&quot;,&quot;aaaaaaa&quot;,&quot;aaaaaaaa&quot;,&quot;aaaaaaaaa&quot;,&quot;aaaaaaaaaa&quot;]\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>测试用例时仍然会产生超时错误，这是因为在搜索过程中如果匹配失败返回之后会产生很多的重复判断，此时需要使用记忆化数组<code>failMemo</code>来记录dfs没有匹配成功时对应的s中的index</p>\n</div>\n<h3 id=\"参考代码\"> 参考代码</h3>\n<CodeGroup>\n<CodeGroupItem title=\"c++\">\n<div><pre><code><span>class</span> <span>Trie</span><span>{</span>\n<span>public</span><span>:</span>\n    Trie<span>*</span> next<span>[</span><span>26</span><span>]</span><span>;</span>\n    <span>bool</span> isEnd<span>;</span>\n    <span>Trie</span><span>(</span><span>)</span><span>{</span>\n        <span>memset</span><span>(</span>next<span>,</span> <span>0</span><span>,</span> <span>sizeof</span><span>(</span>next<span>)</span><span>)</span><span>;</span>\n        isEnd <span>=</span> <span>false</span><span>;</span>\n    <span>}</span>\n    <span>void</span> <span>insert</span><span>(</span>string word<span>)</span><span>{</span>\n        Trie<span>*</span> node <span>=</span> <span>this</span><span>;</span>\n        <span>for</span><span>(</span><span>char</span> ch <span>:</span> word<span>)</span><span>{</span>\n            <span>if</span><span>(</span>node<span>-></span>next<span>[</span>ch <span>-</span> <span>'a'</span><span>]</span> <span>==</span> <span>NULL</span><span>)</span><span>{</span>\n                node<span>-></span>next<span>[</span>ch <span>-</span> <span>'a'</span><span>]</span> <span>=</span> <span>new</span> <span>Trie</span><span>(</span><span>)</span><span>;</span>\n            <span>}</span>\n            node <span>=</span> node<span>-></span>next<span>[</span>ch <span>-</span> <span>'a'</span><span>]</span><span>;</span>\n        <span>}</span>\n        node<span>-></span>isEnd <span>=</span> <span>true</span><span>;</span>\n    <span>}</span>\n<span>}</span><span>;</span>\n<span>class</span> <span>Solution</span> <span>{</span>\n    Trie<span>*</span> root<span>;</span>\n    <span>int</span> failMemo<span>[</span><span>301</span><span>]</span><span>;</span>  <span>//记录dfs中失败时对应的s中的index</span>\n<span>public</span><span>:</span>\n    <span>bool</span> <span>dfs</span><span>(</span>string <span>&amp;</span>s<span>,</span> <span>int</span> startPos<span>)</span><span>{</span>\n        <span>if</span><span>(</span>failMemo<span>[</span>startPos<span>]</span> <span>==</span> <span>1</span><span>)</span><span>{</span>\n            <span>return</span> <span>false</span><span>;</span>\n        <span>}</span>\n        <span>if</span><span>(</span>startPos <span>==</span> s<span>.</span><span>size</span><span>(</span><span>)</span><span>)</span><span>{</span>\n            <span>return</span> <span>true</span><span>;</span>\n        <span>}</span>\n        Trie<span>*</span> node <span>=</span> root<span>;</span>\n        <span>for</span><span>(</span><span>int</span> i <span>=</span> startPos<span>;</span> i <span>&lt;</span> s<span>.</span><span>size</span><span>(</span><span>)</span><span>;</span> i<span>++</span><span>)</span><span>{</span>\n            <span>char</span> ch <span>=</span> s<span>[</span>i<span>]</span><span>;</span>\n            <span>if</span><span>(</span>node<span>-></span>next<span>[</span>ch <span>-</span> <span>'a'</span><span>]</span> <span>!=</span> <span>NULL</span><span>)</span><span>{</span>\n                node <span>=</span> node<span>-></span>next<span>[</span>ch <span>-</span> <span>'a'</span><span>]</span><span>;</span>\n                <span>if</span><span>(</span>node<span>-></span>isEnd <span>==</span> <span>true</span> <span>&amp;&amp;</span> <span>dfs</span><span>(</span>s<span>,</span> i <span>+</span> <span>1</span><span>)</span><span>)</span><span>{</span>\n                    <span>return</span> <span>true</span><span>;</span>\n                <span>}</span>\n            <span>}</span><span>else</span><span>{</span>\n                <span>break</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n        failMemo<span>[</span>startPos<span>]</span> <span>=</span> <span>1</span><span>;</span>\n        <span>return</span> <span>false</span><span>;</span>\n    <span>}</span>\n    <span>bool</span> <span>wordBreak</span><span>(</span>string s<span>,</span> vector<span>&lt;</span>string<span>></span><span>&amp;</span> wordDict<span>)</span> <span>{</span>\n        root <span>=</span> <span>new</span> <span>Trie</span><span>(</span><span>)</span><span>;</span>\n        <span>// 建立字典树</span>\n        <span>for</span><span>(</span><span>auto</span> <span>&amp;&amp;</span> word <span>:</span> wordDict<span>)</span><span>{</span>\n            root<span>-></span><span>insert</span><span>(</span>word<span>)</span><span>;</span>\n        <span>}</span>\n        <span>return</span> <span>dfs</span><span>(</span>s<span>,</span> <span>0</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br></div></div></CodeGroupItem>\n</CodeGroup>\n<h2 id=\"方法二-动态规划\"> 方法二：动态规划</h2>\n<h3 id=\"思路分析-2\"> 思路分析</h3>\n<div><p>提示</p>\n<p>状态定义:</p>\n<p><span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>d</span><span>p</span><span>[</span><span>i</span><span>]</span></span></span></span>表示字符串s前i个字符组成的字符串<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>s</span><span>[</span><span>0...</span><span>i</span><span style=\"margin-right:0.2222em;\"></span><span>−</span><span style=\"margin-right:0.2222em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>1</span><span>]</span></span></span></span>是否能被空格拆分成若干个字典中出现的单词</p>\n<p><span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>c</span><span>h</span><span>ec</span><span style=\"margin-right:0.03148em;\">k</span><span>(</span><span>s</span><span>)</span></span></span></span>表示判断子串s是否出现在字典中</p>\n<p>状态转移方程:</p>\n<p class='katex-block'><span><span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>d</span><span>p</span><span>[</span><span>i</span><span>]</span><span style=\"margin-right:0.2778em;\"></span><span>=</span><span style=\"margin-right:0.2778em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>d</span><span>p</span><span>[</span><span style=\"margin-right:0.05724em;\">j</span><span>]</span><span>&amp;&amp;</span><span>c</span><span>h</span><span>ec</span><span style=\"margin-right:0.03148em;\">k</span><span>(</span><span>s</span><span>[</span><span style=\"margin-right:0.05724em;\">j</span><span>...</span><span>i</span><span style=\"margin-right:0.2222em;\"></span><span>−</span><span style=\"margin-right:0.2222em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>1</span><span>])</span></span></span></span></span></p>\n<p>边界条件：</p>\n<p class='katex-block'><span><span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>d</span><span>p</span><span>[</span><span>0</span><span>]</span><span style=\"margin-right:0.2778em;\"></span><span>=</span><span style=\"margin-right:0.2778em;\"></span></span><span><span style=\"height:0.6151em;\"></span><span>t</span><span style=\"margin-right:0.02778em;\">r</span><span>u</span><span>e</span></span></span></span></span></p>\n</div>\n<h3 id=\"参考代码-2\"> 参考代码</h3>\n<CodeGroup>\n<CodeGroupItem title=\"c++\">\n<div><pre><code><span>class</span> <span>Solution</span> <span>{</span>\n<span>public</span><span>:</span>\n    <span>/*\n\n    */</span>\n    <span>bool</span> <span>wordBreak</span><span>(</span>string s<span>,</span> vector<span>&lt;</span>string<span>></span><span>&amp;</span> wordDict<span>)</span> <span>{</span>\n        <span>auto</span> wordDictSet <span>=</span> <span><span>unordered_set</span><span><span>&lt;</span>string<span>></span></span></span><span>(</span><span>)</span><span>;</span>\n        <span>for</span><span>(</span><span>auto</span> word <span>:</span> wordDict<span>)</span><span>{</span>\n            wordDictSet<span>.</span><span>insert</span><span>(</span>word<span>)</span><span>;</span>\n        <span>}</span>\n\n        <span>auto</span> dp <span>=</span> <span><span>vector</span><span><span>&lt;</span><span>bool</span><span>></span></span></span><span>(</span>s<span>.</span><span>size</span><span>(</span><span>)</span> <span>+</span> <span>1</span><span>)</span><span>;</span>\n        dp<span>[</span><span>0</span><span>]</span> <span>=</span> <span>true</span><span>;</span>   <span>//表示空串且合法</span>\n        <span>for</span><span>(</span><span>int</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;=</span> s<span>.</span><span>size</span><span>(</span><span>)</span><span>;</span> i<span>++</span><span>)</span><span>{</span>\n            <span>for</span><span>(</span><span>int</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> i<span>;</span> j<span>++</span><span>)</span><span>{</span>\n                <span>if</span><span>(</span>dp<span>[</span>j<span>]</span> <span>&amp;&amp;</span> wordDictSet<span>.</span><span>count</span><span>(</span>s<span>.</span><span>substr</span><span>(</span>j<span>,</span> i <span>-</span> j<span>)</span><span>)</span><span>)</span><span>{</span>\n                    dp<span>[</span>i<span>]</span> <span>=</span> <span>true</span><span>;</span>\n                    <span>break</span><span>;</span>\n                <span>}</span>\n            <span>}</span>\n        <span>}</span>\n\n        <span>return</span> dp<span>[</span>s<span>.</span><span>size</span><span>(</span><span>)</span><span>]</span><span>;</span>\n    <span>}</span>\n<span>}</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div></CodeGroupItem>\n</CodeGroup>\n",
      "image": "https://cdn.jsdelivr.net/gh/River-Cold/pictureBed/vuepress-blog/solution/leetcode/LeetCode-hot-topic-HOT-100/139.png",
      "date_published": "2022-04-04T14:19:55.000Z",
      "date_modified": "2022-04-04T14:19:55.000Z",
      "authors": [
        {
          "name": "RiverCold"
        }
      ],
      "tags": []
    },
    {
      "title": "146.LRU缓存",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/solution/leetcode/LeetCode-hot-topic-HOT-100/146.LRU%E7%BC%93%E5%AD%98/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/solution/leetcode/LeetCode-hot-topic-HOT-100/146.LRU%E7%BC%93%E5%AD%98/",
      "content_html": "<h1 id=\"_146-lru缓存\"> 146.LRU缓存</h1>\n<p>https://leetcode-cn.com/problems/lru-cache/</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/River-Cold/pictureBed/vuepress-blog/solution/leetcode/LeetCode-hot-topic-HOT-100/146.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"方法一-哈希表-双向链表-c-实现\"> 方法一：哈希表+双向链表（C++实现）</h2>\n<h3 id=\"思路分析\"> 思路分析</h3>\n<div><p>提示</p>\n<p>用一个哈希表和一个双向链表维护所有在缓存中的键值对。</p>\n<p>双向链表按照被使用的顺序存储了这些键值对，靠近头部的键值对是最近使用的，而靠近尾部的键值对是最久未使用的。</p>\n<p>哈希表即为普通的哈希映射（HashMap），通过缓存数据的键映射到其在双向链表中的位置。</p>\n<Mermaid id=\"mermaid-382ee169\" data-code=\"graph%0A%09subgraph%20get%E5%87%BD%E6%95%B0%0A%09%09direction%20TB%0A%20%20%20%20%20%20%20%20b1%5B%E5%88%A4%E6%96%ADkey%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%5D%0A%20%20%20%20%20%20%20%20b2%5B%E5%A6%82%E6%9E%9Ckey%E4%B8%8D%E5%AD%98%E5%9C%A8%5D%0A%20%20%20%20%20%20%20%20b3%5B%E8%BF%94%E5%9B%9E-1%5D%0A%20%20%20%20%20%20%20%09b4%5B%E5%A6%82%E6%9E%9Ckey%E5%AD%98%E5%9C%A8%2C%E9%80%9A%E8%BF%87%E5%93%88%E5%B8%8C%E8%A1%A8%E5%AE%9A%E4%BD%8D%E5%88%B0%E8%AF%A5%E8%8A%82%E7%82%B9%E5%9C%A8%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E4%BD%8D%E7%BD%AE%3Cbr%3E%E5%B0%86%E5%85%B6%E7%A7%BB%E5%8A%A8%E5%88%B0%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%B4%E9%83%A8%5D%0A%20%20%20%20%20%20%20%09b5%5B%E8%BF%94%E5%9B%9E%E8%AF%A5%E8%8A%82%E7%82%B9%E7%9A%84%E5%80%BC%5D%0A%20%20%20%20%20%20%20%20b1--%3Eb2--%3Eb3%0A%20%20%20%20%20%20%20%20b1--%3Eb4--%3Eb5%0A%20%20%20%20end%0A\"></Mermaid><Mermaid id=\"mermaid-382ee16a\" data-code=\"flowchart%0A%09subgraph%20put%E5%87%BD%E6%95%B0%0A%09%09direction%20TB%0A%20%20%20%20%20%20%20%20b1%5B%E5%88%A4%E6%96%ADkey%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%5D%0A%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20b2%5B%E5%A6%82%E6%9E%9Ckey%E4%B8%8D%E5%AD%98%E5%9C%A8%5D%0A%20%20%20%20%20%20%20%20b3%5B%E4%BD%BF%E7%94%A8key%E5%92%8Cvalue%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E8%8A%82%E7%82%B9%3Cbr%3E%E5%9C%A8%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%B4%E9%83%A8%E6%B7%BB%E5%8A%A0%E8%AF%A5%E8%8A%82%E7%82%B9%3Cbr%3E%E5%B0%86key%E5%92%8C%E8%AF%A5%E8%8A%82%E7%82%B9%E6%B7%BB%E5%8A%A0%E8%BF%9B%E5%93%88%E5%B8%8C%E8%A1%A8%E4%B8%AD%5D%0A%20%20%20%20%20%20%20%20b4%5B%E5%88%A4%E6%96%AD%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9%E6%95%B0%E6%98%AF%E5%90%A6%E8%B6%85%E5%87%BA%E5%AE%B9%E9%87%8F%5D%0A%20%20%20%20%20%20%20%20b5%5B%E5%A6%82%E6%9E%9C%E8%B6%85%E5%87%BA%E5%AE%B9%E9%87%8F%2C%E5%88%A0%E9%99%A4%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E5%B0%BE%E9%83%A8%E8%8A%82%E7%82%B9%3Cbr%3E%E5%88%A0%E9%99%A4%E5%93%88%E5%B8%8C%E8%A1%A8%E4%B8%AD%E5%AF%B9%E5%BA%94%E7%9A%84%E9%A1%B9%5D%0A%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%09b7%5B%E5%A6%82%E6%9E%9Ckey%E5%AD%98%E5%9C%A8%5D%0A%20%20%20%20%20%20%20%20b8%5B%E9%80%9A%E8%BF%87%E5%93%88%E5%B8%8C%E8%A1%A8%E5%AE%9A%E4%BD%8D%E5%88%B0%E8%AF%A5%E8%8A%82%E7%82%B9%E5%9C%A8%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E4%BD%8D%E7%BD%AE%3Cbr%3E%E5%B0%86%E8%8A%82%E7%82%B9%E7%9A%84%E5%80%BC%E6%9B%B4%E6%96%B0%E4%B8%BAvalue%3Cbr%3E%E5%B0%86%E5%85%B6%E7%A7%BB%E5%8A%A8%E5%88%B0%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%B4%E9%83%A8%2C%E6%9C%80%E5%90%8E%E8%BF%94%E5%9B%9E%E8%AF%A5%E8%8A%82%E7%82%B9%E7%9A%84%E5%80%BC%5D%0A%20%20%20%20%20%20%20%20b1--%3Eb2--%3Eb3--%3Eb4--%3Eb5%0A%20%20%20%20%20%20%20%20b1--%3Eb7--%3Eb8%0A%20%20%20%20end%0A\"></Mermaid></div>\n<h3 id=\"参考代码\"> 参考代码</h3>\n<CodeGroup>\n<CodeGroupItem title=\"c++\">\n<div><pre><code><span>struct</span> <span>DLinkedNode</span> <span>{</span>\n    <span>int</span> key<span>,</span> value<span>;</span>\n    DLinkedNode<span>*</span> prev<span>;</span>\n    DLinkedNode<span>*</span> next<span>;</span>\n    <span>DLinkedNode</span><span>(</span><span>)</span><span>:</span> <span>key</span><span>(</span><span>0</span><span>)</span><span>,</span> <span>value</span><span>(</span><span>0</span><span>)</span><span>,</span> <span>prev</span><span>(</span><span>nullptr</span><span>)</span><span>,</span> <span>next</span><span>(</span><span>nullptr</span><span>)</span> <span>{</span><span>}</span>\n    <span>DLinkedNode</span><span>(</span><span>int</span> _key<span>,</span> <span>int</span> _value<span>)</span> <span>:</span> <span>key</span><span>(</span>_key<span>)</span><span>,</span> <span>value</span><span>(</span>_value<span>)</span><span>,</span> <span>prev</span><span>(</span><span>nullptr</span><span>)</span><span>,</span> <span>next</span><span>(</span><span>nullptr</span><span>)</span> <span>{</span><span>}</span>\n<span>}</span><span>;</span>\n\n<span>class</span> <span>LRUCache</span> <span>{</span>\n<span>private</span><span>:</span>\n    unordered_map<span>&lt;</span><span>int</span><span>,</span> DLinkedNode<span>*</span><span>></span> cache<span>;</span>\n    DLinkedNode<span>*</span> head<span>;</span>\n    DLinkedNode<span>*</span> tail<span>;</span>\n    <span>int</span> size<span>;</span>\n    <span>int</span> capacity<span>;</span>\n\n<span>public</span><span>:</span>\n    <span>LRUCache</span><span>(</span><span>int</span> _capacity<span>)</span> <span>:</span> <span>capacity</span><span>(</span>_capacity<span>)</span><span>,</span> <span>size</span><span>(</span><span>0</span><span>)</span> <span>{</span>\n        <span>// 使用伪头部和伪尾部节点</span>\n        head <span>=</span> <span>new</span> <span>DLinkedNode</span><span>(</span><span>)</span><span>;</span>\n        tail <span>=</span> <span>new</span> <span>DLinkedNode</span><span>(</span><span>)</span><span>;</span>\n        head<span>-></span>next <span>=</span> tail<span>;</span>\n        tail<span>-></span>prev <span>=</span> head<span>;</span>    \n    <span>}</span>\n    \n    <span>int</span> <span>get</span><span>(</span><span>int</span> key<span>)</span> <span>{</span>\n        <span>if</span><span>(</span><span>!</span>cache<span>.</span><span>count</span><span>(</span>key<span>)</span><span>)</span><span>{</span>\n            <span>return</span> <span>-</span><span>1</span><span>;</span>\n        <span>}</span>\n        <span>// 如果key存在，先通过哈希表定位，再移到头部</span>\n        DLinkedNode<span>*</span> node <span>=</span> cache<span>[</span>key<span>]</span><span>;</span>\n        <span>moveToHead</span><span>(</span>node<span>)</span><span>;</span>\n        <span>return</span> node<span>-></span>value<span>;</span>\n    <span>}</span>\n    \n    <span>void</span> <span>put</span><span>(</span><span>int</span> key<span>,</span> <span>int</span> value<span>)</span> <span>{</span>\n        <span>if</span><span>(</span><span>!</span>cache<span>.</span><span>count</span><span>(</span>key<span>)</span><span>)</span><span>{</span>\n            <span>// 如果key不存在，创建一个新的节点</span>\n            DLinkedNode<span>*</span> node <span>=</span> <span>new</span> <span>DLinkedNode</span><span>(</span>key<span>,</span> value<span>)</span><span>;</span>\n            <span>// 添加进哈希表</span>\n            cache<span>[</span>key<span>]</span> <span>=</span> node<span>;</span>\n            <span>// 添加至双向链表的头部</span>\n            <span>addToHead</span><span>(</span>node<span>)</span><span>;</span>\n            <span>++</span>size<span>;</span>\n            <span>if</span><span>(</span>size <span>></span> capacity<span>)</span><span>{</span>\n                <span>// 如果超过容量，删除双向链表的尾部节点</span>\n                DLinkedNode<span>*</span> removed <span>=</span> <span>removeTail</span><span>(</span><span>)</span><span>;</span>\n                <span>// 删除哈希表中对应的项</span>\n                cache<span>.</span><span>erase</span><span>(</span>removed<span>-></span>key<span>)</span><span>;</span>\n                <span>// 防止内存泄露</span>\n                <span>delete</span> removed<span>;</span>\n                <span>--</span>size<span>;</span>\n            <span>}</span>\n        <span>}</span>\n        <span>else</span><span>{</span>\n            <span>// 如果key存在，先通过哈希表定位，再修改value，并移到头部</span>\n            DLinkedNode<span>*</span> node <span>=</span> cache<span>[</span>key<span>]</span><span>;</span>\n            node<span>-></span>value <span>=</span> value<span>;</span>\n            <span>moveToHead</span><span>(</span>node<span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n    <span>// 将节点添加到链表头部</span>\n    <span>void</span> <span>addToHead</span><span>(</span>DLinkedNode<span>*</span> node<span>)</span><span>{</span>\n        node<span>-></span>prev <span>=</span> head<span>;</span>\n        node<span>-></span>next <span>=</span> head<span>-></span>next<span>;</span>\n        head<span>-></span>next<span>-></span>prev <span>=</span> node<span>;</span>\n        head<span>-></span>next <span>=</span> node<span>;</span>\n    <span>}</span>\n    <span>// 删除链表中的节点</span>\n    <span>void</span> <span>removeNode</span><span>(</span>DLinkedNode<span>*</span> node<span>)</span><span>{</span>\n        node<span>-></span>prev<span>-></span>next <span>=</span> node<span>-></span>next<span>;</span>\n        node<span>-></span>next<span>-></span>prev <span>=</span> node<span>-></span>prev<span>;</span>\n    <span>}</span>\n    <span>// 将链表中的节点移动到头部</span>\n    <span>void</span> <span>moveToHead</span><span>(</span>DLinkedNode<span>*</span> node<span>)</span><span>{</span>\n        <span>removeNode</span><span>(</span>node<span>)</span><span>;</span>\n        <span>addToHead</span><span>(</span>node<span>)</span><span>;</span>\n    <span>}</span>\n    <span>// 删除双向链表的尾部节点</span>\n    DLinkedNode<span>*</span> <span>removeTail</span><span>(</span><span>)</span> <span>{</span>\n        DLinkedNode<span>*</span> node <span>=</span> tail<span>-></span>prev<span>;</span>\n        <span>removeNode</span><span>(</span>node<span>)</span><span>;</span>\n        <span>return</span> node<span>;</span>\n    <span>}</span>\n<span>}</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br></div></div></CodeGroupItem>\n</CodeGroup>\n<h2 id=\"方法二-哈希表-双向链表-java实现\"> 方法二：哈希表+双向链表（Java实现）</h2>\n<div><p>提示</p>\n</div>\n<CodeGroup>\n<CodeGroupItem title=\"java\">\n<div><pre><code><span>// 自定义节点类</span>\n<span>class</span> <span>Node</span> <span>{</span>\n    <span>public</span> <span>int</span> key<span>,</span> val<span>;</span>\n    <span>// 双向指针：next表示下一个，prev表示前一个</span>\n    <span>public</span> <span>Node</span> next<span>,</span> prev<span>;</span>\n    <span>public</span> <span>Node</span><span>(</span><span>int</span> k<span>,</span> <span>int</span> v<span>)</span><span>{</span>\n        <span>this</span><span>.</span>key <span>=</span> k<span>;</span>\n        <span>this</span><span>.</span>val <span>=</span> v<span>;</span>\n    <span>}</span>\n<span>}</span>\n<span>// 自定义双向链表</span>\n<span>class</span> <span>DoubleList</span><span>{</span>\n    <span>// 头尾虚节点</span>\n    <span>private</span> <span>Node</span> head<span>,</span> tail<span>;</span>\n    <span>// 链表元素数</span>\n    <span>private</span> <span>int</span> size<span>;</span>\n\n    <span>public</span> <span>DoubleList</span><span>(</span><span>)</span> <span>{</span>\n        <span>// 初始化双向链表的数据</span>\n        head <span>=</span> <span>new</span> <span>Node</span><span>(</span><span>0</span><span>,</span> <span>0</span><span>)</span><span>;</span>\n        tail <span>=</span> <span>new</span> <span>Node</span><span>(</span><span>0</span><span>,</span> <span>0</span><span>)</span><span>;</span>\n        head<span>.</span>next <span>=</span> tail<span>;</span>\n        tail<span>.</span>prev <span>=</span> head<span>;</span>\n        size <span>=</span> <span>0</span><span>;</span>\n    <span>}</span>\n\n    <span>// 在链表尾部添加节点x,时间O(1)</span>\n    <span>public</span> <span>void</span> <span>addLast</span><span>(</span><span>Node</span> x<span>)</span> <span>{</span>\n        <span>// 设置插入节点的prev和next指针</span>\n        x<span>.</span>prev <span>=</span> tail<span>.</span>prev<span>;</span>\n        x<span>.</span>next <span>=</span> tail<span>;</span>\n        <span>// 设置插入节点前一个节点的next指针</span>\n        tail<span>.</span>prev<span>.</span>next <span>=</span> x<span>;</span>\n        <span>// 设置尾节点的prev指针</span>\n        tail<span>.</span>prev <span>=</span> x<span>;</span>\n        size<span>++</span><span>;</span>\n    <span>}</span>\n    \n    <span>// 删除链表中的x节点(x一定存在)</span>\n    <span>// 由于是双链表且给的是目标Node节点，时间O(1)</span>\n    <span>public</span> <span>void</span> <span>remove</span><span>(</span><span>Node</span> x<span>)</span><span>{</span>\n        x<span>.</span>prev<span>.</span>next <span>=</span> x<span>.</span>next<span>;</span>\n        x<span>.</span>next<span>.</span>prev <span>=</span> x<span>.</span>prev<span>;</span>\n        size<span>--</span><span>;</span>\n    <span>}</span>\n\n    <span>// 删除链表中第一个节点，并返回该节点，时间O(1)</span>\n    <span>public</span> <span>Node</span> <span>removeFirst</span><span>(</span><span>)</span><span>{</span>\n        <span>if</span><span>(</span>head<span>.</span>next <span>==</span> tail<span>)</span><span>{</span>\n            <span>return</span> <span>null</span><span>;</span>\n        <span>}</span>\n        <span>Node</span> first <span>=</span> head<span>.</span>next<span>;</span>\n        <span>remove</span><span>(</span>first<span>)</span><span>;</span>\n        <span>return</span> first<span>;</span>\n    <span>}</span>\n\n    <span>// 返回链表长度，时间O(1)</span>\n    <span>public</span> <span>int</span> <span>size</span><span>(</span><span>)</span><span>{</span>\n        <span>return</span> size<span>;</span>\n    <span>}</span>\n<span>}</span>\n<span>class</span> <span>LRUCache</span> <span>{</span>\n    <span>int</span> cap<span>;</span>\n    <span>LinkedHashMap</span><span><span>&lt;</span><span>Integer</span><span>,</span> <span>Integer</span><span>></span></span> cache <span>=</span> <span>new</span> <span>LinkedHashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n    <span>public</span> <span>LRUCache</span><span>(</span><span>int</span> capacity<span>)</span> <span>{</span> \n        <span>this</span><span>.</span>cap <span>=</span> capacity<span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>int</span> <span>get</span><span>(</span><span>int</span> key<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span><span>!</span>cache<span>.</span><span>containsKey</span><span>(</span>key<span>)</span><span>)</span> <span>{</span>\n            <span>return</span> <span>-</span><span>1</span><span>;</span>\n        <span>}</span>\n        <span>// 将 key 变为最近使用</span>\n        <span>makeRecently</span><span>(</span>key<span>)</span><span>;</span>\n        <span>return</span> cache<span>.</span><span>get</span><span>(</span>key<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>void</span> <span>put</span><span>(</span><span>int</span> key<span>,</span> <span>int</span> val<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>cache<span>.</span><span>containsKey</span><span>(</span>key<span>)</span><span>)</span> <span>{</span>\n            <span>// 修改 key 的值</span>\n            cache<span>.</span><span>put</span><span>(</span>key<span>,</span> val<span>)</span><span>;</span>\n            <span>// 将 key 变为最近使用</span>\n            <span>makeRecently</span><span>(</span>key<span>)</span><span>;</span>\n            <span>return</span><span>;</span>\n        <span>}</span>\n        <span>if</span> <span>(</span>cache<span>.</span><span>size</span><span>(</span><span>)</span> <span>>=</span> <span>this</span><span>.</span>cap<span>)</span> <span>{</span>\n            <span>// 链表头部就是最久未使用的 key</span>\n            <span>// 删除最久未使用的元素</span>\n            <span>int</span> oldestKey <span>=</span> cache<span>.</span><span>keySet</span><span>(</span><span>)</span><span>.</span><span>iterator</span><span>(</span><span>)</span><span>.</span><span>next</span><span>(</span><span>)</span><span>;</span>\n            cache<span>.</span><span>remove</span><span>(</span>oldestKey<span>)</span><span>;</span>\n        <span>}</span>\n        <span>// 将新的 key 添加链表尾部</span>\n        <span>// 添加为最近使用的元素</span>\n        cache<span>.</span><span>put</span><span>(</span>key<span>,</span> val<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>private</span> <span>void</span> <span>makeRecently</span><span>(</span><span>int</span> key<span>)</span> <span>{</span>\n        <span>int</span> val <span>=</span> cache<span>.</span><span>get</span><span>(</span>key<span>)</span><span>;</span>\n        <span>// 删除 key，重新插入到队尾</span>\n        cache<span>.</span><span>remove</span><span>(</span>key<span>)</span><span>;</span>\n        cache<span>.</span><span>put</span><span>(</span>key<span>,</span> val<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br></div></div></CodeGroupItem>\n</CodeGroup>\n<h2 id=\"参考文献\"> 参考文献</h2>\n<p><a href=\"https://leetcode-cn.com/problems/lru-cache/solution/lruhuan-cun-ji-zhi-by-leetcode-solution/\" target=\"_blank\" rel=\"noopener noreferrer\">LRU缓存机制 - LRU 缓存 - 力扣（LeetCode） (leetcode-cn.com)</a></p>\n<p><a href=\"https://leetcode-cn.com/problems/lru-cache/solution/lru-ce-lue-xiang-jie-he-shi-xian-by-labuladong/\" target=\"_blank\" rel=\"noopener noreferrer\">LRU 策略详解和实现 - LRU 缓存 - 力扣（LeetCode） (leetcode-cn.com)</a></p>\n",
      "image": "https://cdn.jsdelivr.net/gh/River-Cold/pictureBed/vuepress-blog/solution/leetcode/LeetCode-hot-topic-HOT-100/146.png",
      "date_published": "2022-04-04T14:19:55.000Z",
      "date_modified": "2022-04-04T14:19:55.000Z",
      "authors": [
        {
          "name": "RiverCold"
        }
      ],
      "tags": []
    },
    {
      "title": "647.回文子串",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/solution/leetcode/LeetCode-hot-topic-HOT-100/148.%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/solution/leetcode/LeetCode-hot-topic-HOT-100/148.%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/",
      "content_html": "<h1 id=\"_647-回文子串\"> 647.回文子串</h1>\n<p>https://leetcode-cn.com/problems/sort-list/</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/River-Cold/pictureBed/vuepress-blog/docs/solution/leetcode/LeetCode-hot-topic-HOT-100/148.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"方法一-自顶向下归并排序\"> 方法一：自顶向下归并排序</h2>\n<h3 id=\"思路分析\"> 思路分析</h3>\n<div><p>提示</p>\n<p><strong>递归过程</strong>：</p>\n<ol>\n<li><strong>分割</strong>：找到链表的<code>中间节点</code>，以<code>中点</code>为分界，将链表拆分成两个子链表，寻找两个子链表的<code>中点</code>可以用快慢指针的方法</li>\n<li><strong>递归</strong>：然后对两个子链表分别排序</li>\n<li><strong>合并</strong>：将两个排序后的子链表合并，得到完整的排序后的链表</li>\n</ol>\n<p><strong>递归终止条件</strong>：</p>\n<p>链表的节点个数小于或等于1，即当链表为空或者链表只包含1个节点时，不需要对链表进行拆分和排序。</p>\n<p>在分割操作中，<strong>快慢指针的方法</strong>有两种：</p>\n<p><strong>方法1</strong>：指向中间节点的后一个节点</p>\n<ol>\n<li>初始时快指针<code>fast</code>和慢指针<code>slow</code>初始时都指向头结点</li>\n<li>快指针<code>fast</code>每次移动2步，慢指针<code>slow</code>每次移动1步</li>\n<li>当快指针<code>fast</code>到达链表末尾时，慢指针<code>slow</code>指向的链表节点即为链表的中点</li>\n</ol>\n<p><strong>方法2</strong>：指向中间节点的前一个节点</p>\n<ol>\n<li>初始时快指针<code>fast</code>指向头结点的下一个节点，慢指针<code>slow</code>指向头结点</li>\n<li>快指针<code>fast</code>每次移动2步，慢指针<code>slow</code>每次移动1步</li>\n<li>当快指针<code>fast</code>到达链表末尾时，慢指针<code>slow</code>指向的链表节点即为链表的中点（其中奇数个节点直接找到最中间的那个点，偶数个节点找到中心两个节点左边的节点）</li>\n</ol>\n<p>以偶数个节点链表<code>[4,2,1,3]</code>为例，方法1中的慢指针<code>slow</code>最终指向的中点是1，方法2中的慢指针<code>slow</code>最终指向的中点是2</p>\n<p>以奇数个节点链表<code>[-1,5,3,4,0]</code>为例，方法1中的慢指针<code>slow</code>分割操作后指向的中点是3，方法2中的慢指针<code>slow</code>分割操作后指向的中点是3</p>\n</div>\n<h3 id=\"参考代码\"> 参考代码</h3>\n<CodeGroup>\n<CodeGroupItem title=\"c++\">\n<div><pre><code><span>class</span> <span>Solution</span> <span>{</span>\n<span>public</span><span>:</span>\n    ListNode<span>*</span> <span>sortList</span><span>(</span>ListNode<span>*</span> head<span>)</span> <span>{</span>\n        <span>return</span> <span>sortList</span><span>(</span>head<span>,</span> <span>nullptr</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    ListNode<span>*</span> <span>sortList</span><span>(</span>ListNode<span>*</span> head<span>,</span> ListNode<span>*</span> tail<span>)</span><span>{</span>\n        <span>if</span><span>(</span>head <span>==</span> <span>nullptr</span><span>)</span><span>{</span>\n            <span>return</span> head<span>;</span>\n        <span>}</span>\n        <span>if</span><span>(</span>head<span>-></span>next <span>==</span> tail<span>)</span><span>{</span>\n            head<span>-></span>next <span>=</span> <span>nullptr</span><span>;</span>\n            <span>return</span> head<span>;</span>\n        <span>}</span>\n        <span>// 慢指针每次移动2步，慢指针每次移动1步</span>\n        ListNode<span>*</span> slow <span>=</span> head<span>,</span> <span>*</span>fast <span>=</span> head<span>;</span>\n        <span>// 找到链表的中点</span>\n        <span>while</span><span>(</span>fast <span>!=</span> tail<span>)</span><span>{</span>\n            slow <span>=</span> slow<span>-></span>next<span>;</span>\n            fast <span>=</span> fast<span>-></span>next<span>;</span>\n            <span>if</span><span>(</span>fast <span>!=</span> tail<span>)</span><span>{</span>\n                fast <span>=</span> fast<span>-></span>next<span>;</span>\n            <span>}</span>\n        <span>}</span>\n        ListNode<span>*</span> mid <span>=</span> slow<span>;</span>\n        <span>// 对两个排序后的子链表合并</span>\n        <span>return</span> <span>merge</span><span>(</span><span>sortList</span><span>(</span>head<span>,</span> mid<span>)</span><span>,</span> <span>sortList</span><span>(</span>mid<span>,</span> tail<span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>// 归并排序</span>\n    ListNode<span>*</span> <span>merge</span><span>(</span>ListNode<span>*</span> head1<span>,</span> ListNode<span>*</span> head2<span>)</span><span>{</span>\n        ListNode<span>*</span> dummy <span>=</span> <span>new</span> <span>ListNode</span><span>(</span><span>0</span><span>)</span><span>;</span>\n        ListNode<span>*</span> ret <span>=</span> dummy<span>;</span>\n        <span>while</span><span>(</span>head1 <span>&amp;&amp;</span> head2<span>)</span><span>{</span>\n            <span>if</span><span>(</span>head1<span>-></span>val <span>&lt;</span> head2<span>-></span>val<span>)</span><span>{</span>\n                dummy<span>-></span>next <span>=</span> head1<span>;</span>\n                head1 <span>=</span> head1<span>-></span>next<span>;</span>\n            <span>}</span><span>else</span><span>{</span>\n                dummy<span>-></span>next <span>=</span> head2<span>;</span>\n                head2 <span>=</span> head2<span>-></span>next<span>;</span>\n            <span>}</span>\n            dummy <span>=</span> dummy<span>-></span>next<span>;</span>\n        <span>}</span>\n        <span>if</span><span>(</span>head1<span>)</span><span>{</span>\n            dummy<span>-></span>next <span>=</span> head1<span>;</span>\n        <span>}</span>\n        <span>if</span><span>(</span>head2<span>)</span><span>{</span>\n            dummy<span>-></span>next <span>=</span> head2<span>;</span>\n        <span>}</span>\n        <span>return</span> ret<span>-></span>next<span>;</span>\n    <span>}</span>\n<span>}</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br></div></div></CodeGroupItem>\n<CodeGroupItem title=\"c++\">\n<div><pre><code><span>class</span> <span>Solution</span> <span>{</span>\n<span>public</span><span>:</span>\n    ListNode<span>*</span> <span>sortList</span><span>(</span>ListNode<span>*</span> head<span>)</span> <span>{</span>\n        <span>// 链表为空或者只剩下一个节点时，直接返回head</span>\n        <span>if</span><span>(</span>head <span>==</span> <span>nullptr</span> <span>||</span> head<span>-></span>next <span>==</span> <span>nullptr</span><span>)</span><span>{</span>\n            <span>return</span> head<span>;</span>\n        <span>}</span>\n        ListNode<span>*</span> slow <span>=</span> head<span>,</span> <span>*</span>fast <span>=</span> head<span>-></span>next<span>;</span>\n        <span>while</span><span>(</span>fast <span>!=</span> <span>nullptr</span> <span>&amp;&amp;</span> fast<span>-></span>next <span>!=</span> <span>nullptr</span><span>)</span><span>{</span>\n            slow <span>=</span> slow<span>-></span>next<span>;</span>\n            fast <span>=</span> fast<span>-></span>next<span>-></span>next<span>;</span>\n        <span>}</span>\n        ListNode<span>*</span> tmp <span>=</span> slow<span>-></span>next<span>;</span>\n        slow<span>-></span>next <span>=</span> <span>nullptr</span><span>;</span>\n        ListNode<span>*</span> left <span>=</span> <span>sortList</span><span>(</span>head<span>)</span><span>;</span>\n        ListNode<span>*</span> right <span>=</span> <span>sortList</span><span>(</span>tmp<span>)</span><span>;</span>\n        <span>return</span> <span>merge</span><span>(</span>left<span>,</span> right<span>)</span><span>;</span>\n    <span>}</span>\n    ListNode<span>*</span> <span>merge</span><span>(</span>ListNode<span>*</span> head1<span>,</span> ListNode<span>*</span> head2<span>)</span><span>{</span>\n        ListNode<span>*</span> ret <span>=</span> <span>new</span> <span>ListNode</span><span>(</span><span>0</span><span>)</span><span>;</span>\n        ListNode<span>*</span> dummy <span>=</span> ret<span>;</span>\n        <span>while</span><span>(</span>head1 <span>&amp;&amp;</span> head2<span>)</span><span>{</span>\n            <span>if</span><span>(</span>head1<span>-></span>val <span>&lt;</span> head2<span>-></span>val<span>)</span><span>{</span>\n                dummy<span>-></span>next <span>=</span> head1<span>;</span>\n                head1 <span>=</span> head1<span>-></span>next<span>;</span>\n            <span>}</span><span>else</span><span>{</span>\n                dummy<span>-></span>next <span>=</span> head2<span>;</span>\n                head2 <span>=</span> head2<span>-></span>next<span>;</span>\n            <span>}</span>\n            dummy <span>=</span> dummy<span>-></span>next<span>;</span>\n        <span>}</span>\n        dummy<span>-></span>next <span>=</span> head1 <span>?</span> head1 <span>:</span> head2<span>;</span>\n        <span>return</span> ret<span>-></span>next<span>;</span>\n    <span>}</span>\n<span>}</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br></div></div></CodeGroupItem>\n</CodeGroup>\n<h2 id=\"方法二-自底向上归并排序\"> 方法二：自底向上归并排序</h2>\n<div><p>提示</p>\n</div>\n<div><pre><code>\n</code></pre>\n<div><span>1</span><br></div></div><p>:::</p>\n<p>::::</p>\n<h2 id=\"参考文献\"> 参考文献</h2>\n<p><a href=\"https://leetcode-cn.com/problems/sort-list/solution/pai-xu-lian-biao-by-leetcode-solution/\" target=\"_blank\" rel=\"noopener noreferrer\">排序链表 - 排序链表 - 力扣（LeetCode） (leetcode-cn.com)</a></p>\n<p><a href=\"https://leetcode-cn.com/problems/sort-list/solution/sort-list-gui-bing-pai-xu-lian-biao-by-jyd/\" target=\"_blank\" rel=\"noopener noreferrer\">Sort List （归并排序链表） - 排序链表 - 力扣（LeetCode） (leetcode-cn.com)</a></p>\n",
      "image": "https://cdn.jsdelivr.net/gh/River-Cold/pictureBed/vuepress-blog/docs/solution/leetcode/LeetCode-hot-topic-HOT-100/148.png",
      "date_published": "2022-04-04T14:19:55.000Z",
      "date_modified": "2022-04-04T14:19:55.000Z",
      "authors": [
        {
          "name": "RiverCold"
        }
      ],
      "tags": []
    },
    {
      "title": "206.反转链表",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/solution/leetcode/LeetCode-hot-topic-HOT-100/206.%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/solution/leetcode/LeetCode-hot-topic-HOT-100/206.%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/",
      "content_html": "<h1 id=\"_206-反转链表\"> 206.反转链表</h1>\n<p>https://leetcode-cn.com/problems/reverse-linked-list/</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/River-Cold/pictureBed/vuepress-blog/docs/solution/leetcode/LeetCode-hot-topic-HOT-100/206.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"方法一-递归\"> 方法一：递归</h2>\n<h3 id=\"思路分析\"> 思路分析</h3>\n<div><p>提示</p>\n<p><strong>递归函数</strong></p>\n<p><code>reverserList(ListNode* head)</code>：返回反转后的链表头结点</p>\n<p><strong>节点反转示意图</strong></p>\n<p>以节点1为例，结点1之后的结点，经过递归公式<code>reverserList</code>处理后的结果如下图所示：</p>\n<p><img src=\"https://pic.leetcode-cn.com/1611457360-ZminDz-image.png\" alt=\"image.png\" loading=\"lazy\"></p>\n<p>接着需要做的就是反转结点1，也就是将head指向的结点作为下一个结点的下一个结点，即<code>head.next.next=head</code></p>\n<p><img src=\"https://pic.leetcode-cn.com/1611457400-xIhTwQ-image.png\" alt=\"image.png\" loading=\"lazy\"></p>\n<p>最后，将head指向的结点的下一个结点置为null，就完成了整个链表的反转。</p>\n<p><img src=\"https://pic.leetcode-cn.com/1611457409-hQkmzj-image.png\" alt=\"image.png\" loading=\"lazy\"></p>\n<p><strong>递归过程示意图</strong></p>\n<p><img src=\"https://pic.leetcode-cn.com/8951bc3b8b7eb4da2a46063c1bb96932e7a69910c0a93d973bd8aa5517e59fc8.gif\" alt=\"img\" loading=\"lazy\"></p>\n</div>\n<h3 id=\"参考代码\"> 参考代码</h3>\n<CodeGroup>\n<CodeGroupItem title=\"c++\">\n<div><pre><code><span>class</span> <span>Solution</span> <span>{</span>\n<span>public</span><span>:</span>\n    ListNode<span>*</span> <span>reverseList</span><span>(</span>ListNode<span>*</span> head<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>head <span>==</span> <span>NULL</span> <span>||</span> head<span>-></span>next <span>==</span> <span>NULL</span><span>)</span> <span>{</span>\n            <span>return</span> head<span>;</span>\n        <span>}</span>\n        ListNode<span>*</span> ret <span>=</span> <span>reverseList</span><span>(</span>head<span>-></span>next<span>)</span><span>;</span>\n        head<span>-></span>next<span>-></span>next <span>=</span> head<span>;</span>\n        head<span>-></span>next <span>=</span> <span>NULL</span><span>;</span>\n        <span>return</span> ret<span>;</span>\n    <span>}</span>\n<span>}</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div></CodeGroupItem>\n</CodeGroup>\n<h2 id=\"方法二-迭代\"> 方法二：迭代</h2>\n<div><p>提示</p>\n<p>定义两个指针：<code>pre</code>和<code>cur</code>，<code>pre</code>初始时指向空<code>nullptr</code>，<code>cur</code>指向头结点</p>\n<ul>\n<li>每次让<code>pre</code>的下一个节点指针<code>next</code>指向<code>cur</code></li>\n<li><code>pre</code>和<code>cur</code>同时向后移动一个位置</li>\n<li>直到<code>pre</code>到达链表尾部结束，此时<code>cur</code>指向空<code>nullptr</code></li>\n<li>返回<code>pre</code>即为反转链表的头结点</li>\n</ul>\n</div>\n<CodeGroupItem title=\"c++\">\n<div><pre><code><span>class</span> <span>Solution</span> <span>{</span>\n<span>public</span><span>:</span>\n    ListNode<span>*</span> <span>reverseList</span><span>(</span>ListNode<span>*</span> head<span>)</span> <span>{</span>\n        <span>if</span><span>(</span>head <span>==</span> <span>nullptr</span><span>)</span><span>{</span>\n            <span>return</span> <span>nullptr</span><span>;</span>\n        <span>}</span>\n        ListNode<span>*</span> pre <span>=</span> <span>nullptr</span><span>,</span> <span>*</span>cur <span>=</span> head<span>;</span>\n        <span>while</span><span>(</span>cur<span>)</span><span>{</span>\n            ListNode<span>*</span> next <span>=</span> cur<span>-></span>next<span>;</span>\n            cur<span>-></span>next <span>=</span> pre<span>;</span>\n            pre <span>=</span> cur<span>;</span>\n            cur <span>=</span> next<span>;</span>\n        <span>}</span>\n        <span>return</span> pre<span>;</span>\n    <span>}</span>\n<span>}</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div></CodeGroupItem>\n<p>::::</p>\n<h2 id=\"参考文献\"> 参考文献</h2>\n<p><a href=\"https://leetcode-cn.com/problems/reverse-linked-list/solution/yi-bu-yi-bu-jiao-ni-ru-he-yong-di-gui-si-67c3/\" target=\"_blank\" rel=\"noopener noreferrer\">一步一步教你如何用递归思想反转链表 - 反转链表 - 力扣（LeetCode） (leetcode-cn.com)</a></p>\n<p><a href=\"https://leetcode-cn.com/problems/reverse-linked-list/solution/fan-zhuan-lian-biao-shuang-zhi-zhen-di-gui-yao-mo-/\" target=\"_blank\" rel=\"noopener noreferrer\">【反转链表】：双指针，递归，妖魔化的双指针 - 反转链表 - 力扣（LeetCode） (leetcode-cn.com)</a></p>\n",
      "image": "https://cdn.jsdelivr.net/gh/River-Cold/pictureBed/vuepress-blog/docs/solution/leetcode/LeetCode-hot-topic-HOT-100/206.png",
      "date_published": "2022-04-04T14:19:55.000Z",
      "date_modified": "2022-04-04T14:19:55.000Z",
      "authors": [
        {
          "name": "RiverCold"
        }
      ],
      "tags": []
    },
    {
      "title": "236.二叉树的最近公共祖先",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/solution/leetcode/LeetCode-hot-topic-HOT-100/236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/solution/leetcode/LeetCode-hot-topic-HOT-100/236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/",
      "content_html": "<h1 id=\"_236-二叉树的最近公共祖先\"> 236.二叉树的最近公共祖先</h1>\n<p>https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/River-Cold/pictureBed/vuepress-blog/docs/solution/leetcode/LeetCode-hot-topic-HOT-100/236.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"方法一-递归\"> 方法一：递归</h2>\n<h3 id=\"思路分析\"> 思路分析</h3>\n<div><p>提示</p>\n<p>定义子问题：<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span style=\"margin-right:0.10764em;\">f</span></span></span></span> 表示左右子树分别包含<code>p,q</code></p>\n<p>定义 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span><span style=\"margin-right:0.10764em;\">f</span><span><span><span><span style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span><span>x</span></span></span></span></span><span>​</span></span><span><span style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 表示 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.4306em;\"></span><span>x</span></span></span></span> 节点的子树中是否包含 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span>p</span></span></span></span> 节点或 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span style=\"margin-right:0.03588em;\">q</span></span></span></span> 节点，如果包含为 <code>true</code>，否则为<code>false</code>。</p>\n<p>符合条件的最近公共祖先 <code>x</code> 一定满足条件：</p>\n<p class='katex-block'><span><span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>(</span><span><span style=\"margin-right:0.10764em;\">f</span><span><span><span><span style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span><span style=\"margin-right:0.01968em;\">l</span><span>so</span><span>n</span></span></span></span></span><span>​</span></span><span><span style=\"height:0.15em;\"><span></span></span></span></span></span></span><span>&amp;&amp;</span><span><span style=\"margin-right:0.10764em;\">f</span><span><span><span><span style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span><span>rso</span><span>n</span></span></span></span></span><span>​</span></span><span><span style=\"height:0.15em;\"><span></span></span></span></span></span></span><span>)</span><span>∣∣</span><span>(</span><span>x</span><span style=\"margin-right:0.2778em;\"></span><span>==</span><span style=\"margin-right:0.2778em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>p</span><span>∣∣</span><span>x</span><span style=\"margin-right:0.2778em;\"></span><span>==</span><span style=\"margin-right:0.2778em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span style=\"margin-right:0.03588em;\">q</span><span>)</span><span>&amp;&amp;</span><span>(</span><span><span style=\"margin-right:0.10764em;\">f</span><span><span><span><span style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span><span style=\"margin-right:0.01968em;\">l</span><span>so</span><span>n</span></span></span></span></span><span>​</span></span><span><span style=\"height:0.15em;\"><span></span></span></span></span></span></span><span>∣∣</span><span><span style=\"margin-right:0.10764em;\">f</span><span><span><span><span style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span><span>rso</span><span>n</span></span></span></span></span><span>​</span></span><span><span style=\"height:0.15em;\"><span></span></span></span></span></span></span><span>)</span></span></span></span></span></p>\n<p>其中 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.6944em;\"></span><span style=\"margin-right:0.01968em;\">l</span><span>so</span><span>n</span></span></span></span> 和 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.4306em;\"></span><span>rso</span><span>n</span></span></span></span> 分别代表 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.4306em;\"></span><span>x</span></span></span></span> 节点的左孩子和右孩子。</p>\n<ul>\n<li><span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>(</span><span><span style=\"margin-right:0.10764em;\">f</span><span><span><span><span style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span><span style=\"margin-right:0.01968em;\">l</span><span>so</span><span>n</span></span></span></span></span><span>​</span></span><span><span style=\"height:0.15em;\"><span></span></span></span></span></span></span><span>&amp;&amp;</span><span><span style=\"margin-right:0.10764em;\">f</span><span><span><span><span style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span><span>rso</span><span>n</span></span></span></span></span><span>​</span></span><span><span style=\"height:0.15em;\"><span></span></span></span></span></span></span><span>)</span></span></span></span> 说明左子树和右子树均包含 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span>p</span></span></span></span> 节点或 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span style=\"margin-right:0.03588em;\">q</span></span></span></span> 节点</li>\n<li><span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>(</span><span>x</span><span style=\"margin-right:0.2778em;\"></span><span>==</span><span style=\"margin-right:0.2778em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>p</span><span>∣∣</span><span>x</span><span style=\"margin-right:0.2778em;\"></span><span>==</span><span style=\"margin-right:0.2778em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span style=\"margin-right:0.03588em;\">q</span><span>)</span><span>&amp;&amp;</span><span>(</span><span><span style=\"margin-right:0.10764em;\">f</span><span><span><span><span style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span><span style=\"margin-right:0.01968em;\">l</span><span>so</span><span>n</span></span></span></span></span><span>​</span></span><span><span style=\"height:0.15em;\"><span></span></span></span></span></span></span><span>∣∣</span><span><span style=\"margin-right:0.10764em;\">f</span><span><span><span><span style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span><span>rso</span><span>n</span></span></span></span></span><span>​</span></span><span><span style=\"height:0.15em;\"><span></span></span></span></span></span></span><span>)</span></span></span></span>说明 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.4306em;\"></span><span>x</span></span></span></span> 恰好是 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span>p</span></span></span></span> 节点或 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span style=\"margin-right:0.03588em;\">q</span></span></span></span> 节点且它的左子树或右子树有一个包含了另一个节点的情况</li>\n</ul>\n</div>\n<h3 id=\"参考代码\"> 参考代码</h3>\n<CodeGroup>\n<CodeGroupItem title=\"c++\">\n<div><pre><code><span>class</span> <span>Solution</span> <span>{</span>\n<span>public</span><span>:</span>\n    TreeNode<span>*</span> ans<span>;</span>\n    <span>bool</span> <span>dfs</span><span>(</span>TreeNode<span>*</span> root<span>,</span> TreeNode<span>*</span> p<span>,</span> TreeNode<span>*</span> q<span>)</span><span>{</span>\n        <span>if</span><span>(</span>root <span>==</span> <span>nullptr</span><span>)</span><span>{</span>\n            <span>return</span> <span>false</span><span>;</span>\n        <span>}</span>\n        <span>bool</span> flson <span>=</span> <span>dfs</span><span>(</span>root<span>-></span>left<span>,</span> p<span>,</span> q<span>)</span><span>;</span>\n        <span>bool</span> frson <span>=</span> <span>dfs</span><span>(</span>root<span>-></span>right<span>,</span> p<span>,</span> q<span>)</span><span>;</span>\n        <span>if</span><span>(</span><span>(</span>flson <span>&amp;&amp;</span> frson<span>)</span> <span>||</span> <span>(</span>root<span>-></span>val <span>==</span> p<span>-></span>val <span>||</span> root<span>-></span>val <span>==</span> q<span>-></span>val<span>)</span> <span>&amp;&amp;</span> <span>(</span>flson <span>||</span> frson<span>)</span><span>)</span><span>{</span>\n            ans <span>=</span> root<span>;</span>\n        <span>}</span>\n        <span>return</span> root<span>-></span>val <span>==</span> p<span>-></span>val <span>||</span> root<span>-></span>val <span>==</span> q<span>-></span>val <span>||</span> flson <span>||</span> frson<span>;</span>\n    <span>}</span>\n    TreeNode<span>*</span> <span>lowestCommonAncestor</span><span>(</span>TreeNode<span>*</span> root<span>,</span> TreeNode<span>*</span> p<span>,</span> TreeNode<span>*</span> q<span>)</span> <span>{</span>\n        <span>if</span><span>(</span>root <span>==</span> <span>nullptr</span><span>)</span><span>{</span>\n            <span>return</span> <span>nullptr</span><span>;</span>\n        <span>}</span>\n        <span>dfs</span><span>(</span>root<span>,</span> p<span>,</span> q<span>)</span><span>;</span>\n        <span>return</span> ans<span>;</span>\n    <span>}</span>\n<span>}</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div></CodeGroupItem>\n</CodeGroup>\n<h2 id=\"参考文献\"> 参考文献</h2>\n<p><a href=\"https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/solution/er-cha-shu-de-zui-jin-gong-gong-zu-xian-by-leetc-2/\" target=\"_blank\" rel=\"noopener noreferrer\">二叉树的最近公共祖先 - 二叉树的最近公共祖先 - 力扣（LeetCode） (leetcode-cn.com)</a></p>\n",
      "image": "https://cdn.jsdelivr.net/gh/River-Cold/pictureBed/vuepress-blog/docs/solution/leetcode/LeetCode-hot-topic-HOT-100/236.png",
      "date_published": "2022-04-04T14:19:55.000Z",
      "date_modified": "2022-04-04T14:19:55.000Z",
      "authors": [
        {
          "name": "RiverCold"
        }
      ],
      "tags": []
    },
    {
      "title": "297.二叉树的序列化与反序列化",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/solution/leetcode/LeetCode-hot-topic-HOT-100/297.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/solution/leetcode/LeetCode-hot-topic-HOT-100/297.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/",
      "content_html": "<h1 id=\"_297-二叉树的序列化与反序列化\"> 297.二叉树的序列化与反序列化</h1>\n<p>https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/River-Cold/pictureBed/vuepress-blog/solution/leetcode/LeetCode-hot-topic-HOT-100/297.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"方法一-先序遍历dfs\"> 方法一：先序遍历DFS</h2>\n<h3 id=\"思路分析\"> 思路分析</h3>\n<div><p>提示</p>\n<p>深度优先搜索策略区分为先序遍历、中序遍历、后序遍历，这里采用先序遍历的编码方式对二叉树进行序列化</p>\n<p><strong>序列化</strong></p>\n<ul>\n<li>遇到空子树时序列化为<code>NULL</code></li>\n<li>遇到非空子树时首先序列化根节点root为<code>root-&gt;val</code>，递归序列化这棵树的左子树和右子树。</li>\n</ul>\n<p><strong>反序列化</strong></p>\n<ul>\n<li>根据空格将二叉树的先序遍历序列分割得到先序遍历的元素列表，从左向右遍历这个序列\n<ul>\n<li>遇到元素为<code>NULL</code>时反序列化为空树</li>\n<li>遇到元素为数值时创建根节点<code>root</code>为<code>stoi(str)</code>，继续递归反序列化<code>root</code>的左右子树</li>\n</ul>\n</li>\n</ul>\n</div>\n<h3 id=\"参考代码\"> 参考代码</h3>\n<CodeGroup>\n<CodeGroupItem title=\"c++\">\n<div><pre><code><span>class</span> <span>Codec</span> <span>{</span>\n<span>public</span><span>:</span>\n    <span>void</span> <span>rserialize</span><span>(</span>TreeNode<span>*</span> root<span>,</span> string<span>&amp;</span> str<span>)</span><span>{</span>\n        <span>if</span><span>(</span>root <span>==</span> <span>NULL</span><span>)</span><span>{</span>\n            str <span>+=</span> <span>\"null \"</span><span>;</span>\n        <span>}</span> <span>else</span><span>{</span>\n            str <span>+=</span> <span>to_string</span><span>(</span>root<span>-></span>val<span>)</span> <span>+</span> <span>\" \"</span><span>;</span>\n            <span>rserialize</span><span>(</span>root<span>-></span>left<span>,</span> str<span>)</span><span>;</span>\n            <span>rserialize</span><span>(</span>root<span>-></span>right<span>,</span> str<span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>// Encodes a tree to a single string.</span>\n    string <span>serialize</span><span>(</span>TreeNode<span>*</span> root<span>)</span> <span>{</span>\n        string ret<span>;</span>\n        <span>rserialize</span><span>(</span>root<span>,</span> ret<span>)</span><span>;</span>\n        <span>return</span> ret<span>;</span>\n    <span>}</span>\n\n    TreeNode<span>*</span> <span>rdeserialize</span><span>(</span>list<span>&lt;</span>string<span>></span><span>&amp;</span> dataArray<span>)</span><span>{</span>\n        <span>if</span><span>(</span>dataArray<span>.</span><span>front</span><span>(</span><span>)</span> <span>==</span> <span>\"null\"</span><span>)</span><span>{</span>\n            dataArray<span>.</span><span>erase</span><span>(</span>dataArray<span>.</span><span>begin</span><span>(</span><span>)</span><span>)</span><span>;</span>\n            <span>return</span> <span>NULL</span><span>;</span>\n        <span>}</span>\n\n        TreeNode<span>*</span> root <span>=</span> <span>new</span> <span>TreeNode</span><span>(</span><span>stoi</span><span>(</span>dataArray<span>.</span><span>front</span><span>(</span><span>)</span><span>)</span><span>)</span><span>;</span>\n        dataArray<span>.</span><span>erase</span><span>(</span>dataArray<span>.</span><span>begin</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        root<span>-></span>left <span>=</span> <span>rdeserialize</span><span>(</span>dataArray<span>)</span><span>;</span>\n        root<span>-></span>right <span>=</span> <span>rdeserialize</span><span>(</span>dataArray<span>)</span><span>;</span>\n        <span>return</span> root<span>;</span>\n    <span>}</span>\n\n    <span>// Decodes your encoded data to tree.</span>\n    TreeNode<span>*</span> <span>deserialize</span><span>(</span>string data<span>)</span> <span>{</span>\n        list<span>&lt;</span>string<span>></span> dataArray<span>;</span>\n        string str<span>;</span>\n        stringstream <span>ss</span><span>(</span>data<span>)</span><span>;</span>\n        <span>while</span><span>(</span>ss <span>>></span> str<span>)</span><span>{</span>\n            dataArray<span>.</span><span>emplace_back</span><span>(</span>str<span>)</span><span>;</span>\n        <span>}</span>\n        <span>return</span> <span>rdeserialize</span><span>(</span>dataArray<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br></div></div></CodeGroupItem>\n</CodeGroup>\n<h2 id=\"方法二-层次遍历bfs\"> 方法二：层次遍历BFS</h2>\n<h3 id=\"思路分析-2\"> 思路分析</h3>\n<div><p>提示</p>\n<p><strong>序列化</strong></p>\n<p>对树进行层次遍历，维护一个队列<code>q</code>，初始时让根节点入队，考察出队节点：</p>\n<ul>\n<li>如果出队节点为<code>null</code>，将符号<code>null</code>加入<code>encode</code></li>\n<li>如果出队节点为数值，将节点值加入<code>encode</code>，并将其左右子节点入队（子节点为NULL也要入队，它对应<code>null</code>，需要被记录）</li>\n</ul>\n<p>循环出队入队过程直到队列为空，遍历完所有节点，完成序列化。</p>\n<p><strong>反序列化</strong></p>\n<p>维护一个队列<code>q</code>，初始时用序列化字符串<code>encode</code>的第一个子串<code>encode[0]</code>创建根节点，并将根节点入队。</p>\n<ul>\n<li>\n<p>将队首元素<code>top</code>出队，然后利用<code>encode</code>串的接下来两个元素创建左右节点，并让<code>top</code>指向左右子节点</p>\n</li>\n<li>\n<p>如果子节点不为空，则将子节点继续入队</p>\n</li>\n</ul>\n<p>循环出队入队过程直到队列为空，遍历完<code>encode</code>串，完成反序列化。</p>\n</div>\n<h3 id=\"参考代码-2\"> 参考代码</h3>\n<CodeGroup>\n<CodeGroupItem title=\"c++\">\n<div><pre><code><span>class</span> <span>Codec</span> <span>{</span>\n<span>public</span><span>:</span>\n\n    <span>// Encodes a tree to a single string.</span>\n    string <span>serialize</span><span>(</span>TreeNode<span>*</span> root<span>)</span> <span>{</span>\n        string encode <span>=</span> <span>\"\"</span><span>;</span>\n\n        queue<span>&lt;</span>TreeNode<span>*</span><span>></span> q<span>;</span>\n        <span>if</span><span>(</span>root <span>==</span> <span>NULL</span><span>)</span><span>{</span>\n            encode <span>=</span> <span>\"null\"</span><span>;</span>\n            <span>return</span> encode<span>;</span>\n        <span>}</span>\n        \n        q<span>.</span><span>push</span><span>(</span>root<span>)</span><span>;</span>\n        \n        <span>while</span><span>(</span><span>!</span>q<span>.</span><span>empty</span><span>(</span><span>)</span><span>)</span><span>{</span>\n            <span>auto</span> top <span>=</span> q<span>.</span><span>front</span><span>(</span><span>)</span><span>;</span>\n            q<span>.</span><span>pop</span><span>(</span><span>)</span><span>;</span>\n            <span>if</span><span>(</span>top <span>==</span> <span>NULL</span><span>)</span><span>{</span>\n                encode <span>+=</span> <span>\" null\"</span><span>;</span>\n                <span>continue</span><span>;</span>\n            <span>}</span>\n            <span>if</span><span>(</span>top <span>!=</span> root<span>)</span>\n                encode <span>+=</span> <span>\" \"</span><span>;</span>\n            encode <span>+=</span> <span>to_string</span><span>(</span>top<span>-></span>val<span>)</span><span>;</span>\n            q<span>.</span><span>push</span><span>(</span>top<span>-></span>left<span>)</span><span>;</span>\n            q<span>.</span><span>push</span><span>(</span>top<span>-></span>right<span>)</span><span>;</span>\n        <span>}</span>\n\n        <span>// cout &lt;&lt; \"encode = \" &lt;&lt; encode &lt;&lt; endl;</span>\n        <span>return</span> encode<span>;</span>       \n    <span>}</span>\n\n    <span>// Decodes your encoded data to tree.</span>\n    TreeNode<span>*</span> <span>deserialize</span><span>(</span>string data<span>)</span> <span>{</span>\n        stringstream <span>ss</span><span>(</span>data<span>)</span><span>;</span>\n        string str<span>;</span>\n        \n        ss <span>>></span> str<span>;</span>\n        <span>if</span><span>(</span>str <span>==</span> <span>\"null\"</span><span>)</span><span>{</span>\n            <span>return</span> <span>NULL</span><span>;</span>\n        <span>}</span>\n\n        <span>// cout &lt;&lt; \"str = \" &lt;&lt; str &lt;&lt; endl;</span>\n        TreeNode<span>*</span> root <span>=</span> <span>new</span> <span>TreeNode</span><span>(</span><span>stoi</span><span>(</span>str<span>)</span><span>)</span><span>;</span>\n        queue<span>&lt;</span>TreeNode<span>*</span><span>></span> q<span>;</span>\n        q<span>.</span><span>push</span><span>(</span>root<span>)</span><span>;</span>\n        <span>while</span><span>(</span><span>!</span>q<span>.</span><span>empty</span><span>(</span><span>)</span><span>)</span><span>{</span>\n            <span>auto</span> top <span>=</span> q<span>.</span><span>front</span><span>(</span><span>)</span><span>;</span>\n            q<span>.</span><span>pop</span><span>(</span><span>)</span><span>;</span>\n\n            TreeNode<span>*</span> root <span>=</span> top<span>;</span>\n            \n            ss <span>>></span> str<span>;</span>\n            TreeNode<span>*</span> left <span>=</span> <span>(</span>str <span>==</span> <span>\"null\"</span> <span>?</span> <span>NULL</span> <span>:</span> <span>new</span> <span>TreeNode</span><span>(</span><span>stoi</span><span>(</span>str<span>)</span><span>)</span><span>)</span><span>;</span>\n\n            ss <span>>></span> str<span>;</span>\n            TreeNode<span>*</span> right <span>=</span> <span>(</span>str <span>==</span> <span>\"null\"</span> <span>?</span> <span>NULL</span> <span>:</span> <span>new</span> <span>TreeNode</span><span>(</span><span>stoi</span><span>(</span>str<span>)</span><span>)</span><span>)</span><span>;</span>\n\n            root<span>-></span>left <span>=</span> left<span>,</span> root<span>-></span>right <span>=</span> right<span>;</span>\n\n            <span>if</span><span>(</span>root<span>-></span>left<span>)</span><span>{</span>\n                q<span>.</span><span>push</span><span>(</span>root<span>-></span>left<span>)</span><span>;</span>\n            <span>}</span>\n            <span>if</span><span>(</span>root<span>-></span>right<span>)</span><span>{</span>\n                q<span>.</span><span>push</span><span>(</span>root<span>-></span>right<span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n\n        <span>return</span> root<span>;</span>\n    <span>}</span>\n<span>}</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br></div></div></CodeGroupItem>\n</CodeGroup>\n<h2 id=\"参考文献\"> 参考文献</h2>\n<p><a href=\"https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/solution/er-cha-shu-de-xu-lie-hua-yu-fan-xu-lie-hua-by-le-2/\" target=\"_blank\" rel=\"noopener noreferrer\">二叉树的序列化与反序列化 - 二叉树的序列化与反序列化 - 力扣（LeetCode） (leetcode-cn.com)</a></p>\n<p><a href=\"https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/solution/shou-hui-tu-jie-gei-chu-dfshe-bfsliang-chong-jie-f/\" target=\"_blank\" rel=\"noopener noreferrer\">『手画图解』剖析DFS、BFS解法 | 二叉树的序列化与反序列化 - 二叉树的序列化与反序列化 - 力扣（LeetCode） (leetcode-cn.com)</a></p>\n",
      "image": "https://cdn.jsdelivr.net/gh/River-Cold/pictureBed/vuepress-blog/solution/leetcode/LeetCode-hot-topic-HOT-100/297.png",
      "date_published": "2022-04-04T14:19:55.000Z",
      "date_modified": "2022-04-04T14:19:55.000Z",
      "authors": [
        {
          "name": "RiverCold"
        }
      ],
      "tags": []
    },
    {
      "title": "3.无重复字符的最长子串",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/solution/leetcode/LeetCode-hot-topic-HOT-100/3.%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/solution/leetcode/LeetCode-hot-topic-HOT-100/3.%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/",
      "content_html": "<h1 id=\"_3-无重复字符的最长子串\"> 3.无重复字符的最长子串</h1>\n<p><img src=\"https://cdn.jsdelivr.net/gh/River-Cold/pictureBed/vuepress-blog/docs/solution/leetcode/LeetCode-hot-topic-HOT-100/3.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"方法一-哈希set\"> 方法一：哈希set</h2>\n<h3 id=\"思路分析\"> 思路分析</h3>\n<div><p>提示</p>\n</div>\n<h3 id=\"参考代码\"> 参考代码</h3>\n<CodeGroup>\n<CodeGroupItem title=\"c++\">\n<div><pre><code><span>class</span> <span>Solution</span> <span>{</span>\n<span>public</span><span>:</span>\n    <span>int</span> <span>lengthOfLongestSubstring</span><span>(</span>string s<span>)</span> <span>{</span>\n        <span>// 哈希集合，记录每个字符是否出现过</span>\n        unordered_set<span>&lt;</span><span>char</span><span>></span> occ<span>;</span>\n        <span>int</span> n <span>=</span> s<span>.</span><span>size</span><span>(</span><span>)</span><span>;</span>\n        <span>// 右指针，初始值为-1，相当于我们在字符串的左边界的左侧，还没有开始移动</span>\n        <span>int</span> rk <span>=</span> <span>-</span><span>1</span><span>,</span> ans <span>=</span> <span>0</span><span>;</span>\n        <span>// 枚举左指针的位置，初始值隐性地表示为-1</span>\n        <span>for</span><span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> n<span>;</span> <span>++</span>i<span>)</span><span>{</span>\n            <span>if</span><span>(</span>i <span>!=</span> <span>0</span><span>)</span><span>{</span>\n                <span>// 左指针向右移动一格，移除一个字符</span>\n                occ<span>.</span><span>erase</span><span>(</span>s<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>)</span><span>;</span>\n            <span>}</span>\n            <span>while</span><span>(</span>rk <span>+</span> <span>1</span> <span>&lt;</span> n <span>&amp;&amp;</span> occ<span>.</span><span>count</span><span>(</span>s<span>[</span>rk <span>+</span> <span>1</span><span>]</span><span>)</span> <span>==</span> <span>0</span><span>)</span><span>{</span>\n                <span>// 不断地移动右指针</span>\n                occ<span>.</span><span>insert</span><span>(</span>s<span>[</span>rk <span>+</span> <span>1</span><span>]</span><span>)</span><span>;</span>\n                <span>++</span>rk<span>;</span>\n            <span>}</span>\n            <span>// 第 i 到 rk 个字符是一个极长的无重复字符子串</span>\n            ans <span>=</span> <span>max</span><span>(</span>ans<span>,</span> rk <span>-</span> i <span>+</span> <span>1</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>return</span> ans<span>;</span>\n    <span>}</span>\n<span>}</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div></CodeGroupItem>\n</CodeGroup>\n<h2 id=\"方法二-哈希table\"> 方法二：哈希table</h2>\n<h3 id=\"思路分析-2\"> 思路分析</h3>\n<div><p>提示</p>\n</div>\n<h3 id=\"参考代码-2\"> 参考代码</h3>\n<CodeGroup>\n<CodeGroupItem title=\"c++\">\n<div><pre><code><span>class</span> <span>Solution</span> <span>{</span>\n<span>public</span><span>:</span>\n    <span>int</span> <span>lengthOfLongestSubstring</span><span>(</span>string s<span>)</span> <span>{</span>\n        unordered_map<span>&lt;</span><span>char</span><span>,</span> <span>int</span><span>></span> dic<span>;</span>\n        <span>// 记录最大不重复子串的长度</span>\n        <span>int</span> ans <span>=</span> <span>0</span><span>;</span>\n        <span>// 滑动窗口左指针</span>\n        <span>int</span> left <span>=</span> <span>0</span><span>;</span>\n        <span>// 字符串长度</span>\n        <span>int</span> n <span>=</span> s<span>.</span><span>length</span><span>(</span><span>)</span><span>;</span>\n\n        <span>for</span><span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> n<span>;</span> i<span>++</span><span>)</span><span>{</span>\n            <span>/*\n            1. 首先判断当前字符ch是否包含在dic中，如果不包含，则将该字符添加到dic\n            2. 如果当前字符ch包含在dic中，此时有2种情况:\n                2.1 当前字符包含在当前有效的子段中，如:abca\n                2.2 当前字符不包含在当前最长有效的子段中，如:abba\n            为了统一处理以上2类情况，每次更新left=max(left, dic[ch] + 1)\n            更新left后，不管原来的s[i]是否在最长子段中，都要将s[i]的位置更新为当前的i\n            */</span>\n            <span>if</span><span>(</span>dic<span>.</span><span>count</span><span>(</span>s<span>[</span>i<span>]</span><span>)</span> <span>!=</span> <span>0</span><span>)</span><span>{</span>\n                left <span>=</span> <span>max</span><span>(</span>left<span>,</span> dic<span>[</span>s<span>[</span>i<span>]</span><span>]</span> <span>+</span> <span>1</span><span>)</span><span>;</span>\n            <span>}</span>\n            <span>// 不管是否更新left,都要更新dic[i]的位置!</span>\n            dic<span>[</span>s<span>[</span>i<span>]</span><span>]</span> <span>=</span> i<span>;</span>\n            ans <span>=</span> <span>max</span><span>(</span>ans<span>,</span> i <span>-</span> left <span>+</span> <span>1</span><span>)</span><span>;</span>\n        <span>}</span>\n\n        <span>return</span> ans<span>;</span>\n    <span>}</span>\n<span>}</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div></CodeGroupItem>\n</CodeGroup>\n<h2 id=\"参考文献\"> 参考文献</h2>\n<p><a href=\"https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/solution/wu-zhong-fu-zi-fu-de-zui-chang-zi-chuan-by-leetc-2/\" target=\"_blank\" rel=\"noopener noreferrer\">无重复字符的最长子串 - 无重复字符的最长子串 - 力扣（LeetCode） (leetcode-cn.com)</a></p>\n<p><a href=\"https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/solution/hua-dong-chuang-kou-by-powcai/\" target=\"_blank\" rel=\"noopener noreferrer\">滑动窗口 - 无重复字符的最长子串 - 力扣（LeetCode） (leetcode-cn.com)</a></p>\n<p><a href=\"https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/solution/longest-substring-without-repeating-characters-b-2/\" target=\"_blank\" rel=\"noopener noreferrer\">【无重复字符的最长子串】滑动窗口，精简代码，图解模拟 - 无重复字符的最长子串 - 力扣（LeetCode） (leetcode-cn.com)</a></p>\n",
      "image": "https://cdn.jsdelivr.net/gh/River-Cold/pictureBed/vuepress-blog/docs/solution/leetcode/LeetCode-hot-topic-HOT-100/3.png",
      "date_published": "2022-04-04T14:19:55.000Z",
      "date_modified": "2022-04-04T14:19:55.000Z",
      "authors": [
        {
          "name": "RiverCold"
        }
      ],
      "tags": []
    },
    {
      "title": "309.最佳买卖股票时机含冷冻期",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/solution/leetcode/LeetCode-hot-topic-HOT-100/309.%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/solution/leetcode/LeetCode-hot-topic-HOT-100/309.%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F/",
      "content_html": "<h1 id=\"_309-最佳买卖股票时机含冷冻期\"> 309.最佳买卖股票时机含冷冻期</h1>\n<p><img src=\"https://cdn.jsdelivr.net/gh/River-Cold/pictureBed/vuepress-blog/solution/leetcode/LeetCode-hot-topic-HOT-100/309.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"方法一-动态规划\"> 方法一：动态规划</h2>\n<h3 id=\"思路分析\"> 思路分析</h3>\n<div><p>提示</p>\n<p><strong>状态定义</strong>：</p>\n<p>用 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span style=\"margin-right:0.10764em;\">f</span><span>[</span><span>i</span><span>]</span></span></span></span> 表示第 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.6595em;\"></span><span>i</span></span></span></span> 天结束之后的累计最大收益，根据题意存在三种不同的状态：</p>\n<ul>\n<li><span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span style=\"margin-right:0.10764em;\">f</span><span>[</span><span>i</span><span>]</span><span>[</span><span>0</span><span>]</span></span></span></span>：目前持有一支股票，对应的累计最大收益</li>\n<li><span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span style=\"margin-right:0.10764em;\">f</span><span>[</span><span>i</span><span>]</span><span>[</span><span>1</span><span>]</span></span></span></span>：目前不持有任何股票，并且处于冷冻期中，对应的累计最大收益</li>\n<li><span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span style=\"margin-right:0.10764em;\">f</span><span>[</span><span>i</span><span>]</span><span>[</span><span>2</span><span>]</span></span></span></span>：我们目前不持有任何股票，并且不处于冷冻期中，对应的累计最大收益 。</li>\n</ul>\n<p><strong>状态转移方程</strong>：</p>\n<ul>\n<li>对于 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span style=\"margin-right:0.10764em;\">f</span><span>[</span><span>i</span><span>]</span><span>[</span><span>0</span><span>]</span></span></span></span>，我们目前持有的这一支股票可以是在第 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.7429em;vertical-align:-0.0833em;\"></span><span>i</span><span style=\"margin-right:0.2222em;\"></span><span>−</span><span style=\"margin-right:0.2222em;\"></span></span><span><span style=\"height:0.6444em;\"></span><span>1</span></span></span></span> 天就已经持有的，对应的状态为 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span style=\"margin-right:0.10764em;\">f</span><span>[</span><span>i</span><span style=\"margin-right:0.2222em;\"></span><span>−</span><span style=\"margin-right:0.2222em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>1</span><span>]</span><span>[</span><span>0</span><span>]</span></span></span></span>；或者是第 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.6595em;\"></span><span>i</span></span></span></span> 天买入的，那么第 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.7429em;vertical-align:-0.0833em;\"></span><span>i</span><span style=\"margin-right:0.2222em;\"></span><span>−</span><span style=\"margin-right:0.2222em;\"></span></span><span><span style=\"height:0.6444em;\"></span><span>1</span></span></span></span> 天就不能持有股票并且不处于冷冻期总，对应的状态为 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span style=\"margin-right:0.10764em;\">f</span><span>[</span><span>i</span><span style=\"margin-right:0.2222em;\"></span><span>−</span><span style=\"margin-right:0.2222em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>1</span><span>]</span><span>[</span><span>2</span><span>]</span></span></span></span> 加上买入股票的负收益 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>p</span><span style=\"margin-right:0.02778em;\">r</span><span>i</span><span>ces</span><span>[</span><span>i</span><span>]</span></span></span></span>。因此状态转移方程为：</li>\n</ul>\n<p class='katex-block'><span><span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span style=\"margin-right:0.10764em;\">f</span><span>[</span><span>i</span><span>]</span><span>[</span><span>0</span><span>]</span><span style=\"margin-right:0.2778em;\"></span><span>=</span><span style=\"margin-right:0.2778em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>ma</span><span>x</span><span>(</span><span style=\"margin-right:0.10764em;\">f</span><span>[</span><span>i</span><span style=\"margin-right:0.2222em;\"></span><span>−</span><span style=\"margin-right:0.2222em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>1</span><span>]</span><span>[</span><span>0</span><span>]</span><span>,</span><span style=\"margin-right:0.1667em;\"></span><span style=\"margin-right:0.10764em;\">f</span><span>[</span><span>i</span><span style=\"margin-right:0.2222em;\"></span><span>−</span><span style=\"margin-right:0.2222em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>1</span><span>]</span><span>[</span><span>2</span><span>]</span><span style=\"margin-right:0.2222em;\"></span><span>−</span><span style=\"margin-right:0.2222em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>p</span><span style=\"margin-right:0.02778em;\">r</span><span>i</span><span>ces</span><span>[</span><span>i</span><span>])</span></span></span></span></span></p>\n<ul>\n<li>对于 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span style=\"margin-right:0.10764em;\">f</span><span>[</span><span>i</span><span>]</span><span>[</span><span>1</span><span>]</span></span></span></span>，我们在第 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.6595em;\"></span><span>i</span></span></span></span> 天结束之后处于冷冻期的原因是在当天卖出了股票，那么说明在第 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.7429em;vertical-align:-0.0833em;\"></span><span>i</span><span style=\"margin-right:0.2222em;\"></span><span>−</span><span style=\"margin-right:0.2222em;\"></span></span><span><span style=\"height:0.6444em;\"></span><span>1</span></span></span></span> 天时我们必须持有一支股票，对应的状态为 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span style=\"margin-right:0.10764em;\">f</span><span>[</span><span>i</span><span style=\"margin-right:0.2222em;\"></span><span>−</span><span style=\"margin-right:0.2222em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>1</span><span>]</span><span>[</span><span>0</span><span>]</span></span></span></span> 加上卖出股票的正收益 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>p</span><span style=\"margin-right:0.02778em;\">r</span><span>i</span><span>ces</span><span>[</span><span>i</span><span>]</span></span></span></span>。因此状态转移方程为：</li>\n</ul>\n<p class='katex-block'><span><span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span style=\"margin-right:0.10764em;\">f</span><span>[</span><span>i</span><span>]</span><span>[</span><span>1</span><span>]</span><span style=\"margin-right:0.2778em;\"></span><span>=</span><span style=\"margin-right:0.2778em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span style=\"margin-right:0.10764em;\">f</span><span>[</span><span>i</span><span style=\"margin-right:0.2222em;\"></span><span>−</span><span style=\"margin-right:0.2222em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>1</span><span>]</span><span>[</span><span>0</span><span>]</span><span style=\"margin-right:0.2222em;\"></span><span>+</span><span style=\"margin-right:0.2222em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>p</span><span style=\"margin-right:0.02778em;\">r</span><span>i</span><span>ces</span><span>[</span><span>i</span><span>]</span></span></span></span></span></p>\n<ul>\n<li>对于 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span style=\"margin-right:0.10764em;\">f</span><span>[</span><span>i</span><span>]</span><span>[</span><span>2</span><span>]</span></span></span></span>，我们在第 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.6595em;\"></span><span>i</span></span></span></span> 天结束之后不持有任何股票并且不处于冷冻期，说明当天没有进行任何操作，即第 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.7429em;vertical-align:-0.0833em;\"></span><span>i</span><span style=\"margin-right:0.2222em;\"></span><span>−</span><span style=\"margin-right:0.2222em;\"></span></span><span><span style=\"height:0.6444em;\"></span><span>1</span></span></span></span> 天时不持有任何股票：如果处于冷冻期，对应的状态为 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span style=\"margin-right:0.10764em;\">f</span><span>[</span><span>i</span><span style=\"margin-right:0.2222em;\"></span><span>−</span><span style=\"margin-right:0.2222em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>1</span><span>]</span><span>[</span><span>1</span><span>]</span></span></span></span>；如果不处于冷冻期，对应的状态为 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span style=\"margin-right:0.10764em;\">f</span><span>[</span><span>i</span><span style=\"margin-right:0.2222em;\"></span><span>−</span><span style=\"margin-right:0.2222em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>1</span><span>]</span><span>[</span><span>2</span><span>]</span></span></span></span>。因此状态转移方程为：</li>\n</ul>\n<p class='katex-block'><span><span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span style=\"margin-right:0.10764em;\">f</span><span>[</span><span>i</span><span>]</span><span>[</span><span>2</span><span>]</span><span style=\"margin-right:0.2778em;\"></span><span>=</span><span style=\"margin-right:0.2778em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>ma</span><span>x</span><span>(</span><span style=\"margin-right:0.10764em;\">f</span><span>[</span><span>i</span><span style=\"margin-right:0.2222em;\"></span><span>−</span><span style=\"margin-right:0.2222em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>1</span><span>]</span><span>[</span><span>1</span><span>]</span><span>,</span><span style=\"margin-right:0.1667em;\"></span><span style=\"margin-right:0.10764em;\">f</span><span>[</span><span>i</span><span style=\"margin-right:0.2222em;\"></span><span>−</span><span style=\"margin-right:0.2222em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>1</span><span>]</span><span>[</span><span>2</span><span>])</span></span></span></span></span></p>\n<p>如果一共有 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.4306em;\"></span><span>n</span></span></span></span> 天，最终答案为</p>\n<p class='katex-block'><span><span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>ma</span><span>x</span><span>(</span><span style=\"margin-right:0.10764em;\">f</span><span>[</span><span>n</span><span style=\"margin-right:0.2222em;\"></span><span>−</span><span style=\"margin-right:0.2222em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>1</span><span>]</span><span>[</span><span>0</span><span>]</span><span>,</span><span style=\"margin-right:0.1667em;\"></span><span style=\"margin-right:0.10764em;\">f</span><span>[</span><span>n</span><span style=\"margin-right:0.2222em;\"></span><span>−</span><span style=\"margin-right:0.2222em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>1</span><span>]</span><span>[</span><span>1</span><span>]</span><span>,</span><span style=\"margin-right:0.1667em;\"></span><span style=\"margin-right:0.10764em;\">f</span><span>[</span><span>n</span><span style=\"margin-right:0.2222em;\"></span><span>−</span><span style=\"margin-right:0.2222em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>1</span><span>]</span><span>[</span><span>2</span><span>])</span></span></span></span></span></p>\n<p>注意到如果在最后一天（第 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span>n</span><span style=\"margin-right:0.2222em;\"></span><span>−</span><span style=\"margin-right:0.2222em;\"></span></span><span><span style=\"height:0.6444em;\"></span><span>1</span></span></span></span> 天）结束之后，手上仍然持有股票，那么显然是没有任何意义的。因此更加精确地，最终的答案实际上是 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span style=\"margin-right:0.10764em;\">f</span><span>[</span><span>n</span><span style=\"margin-right:0.2222em;\"></span><span>−</span><span style=\"margin-right:0.2222em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>1</span><span>]</span><span>[</span><span>1</span></span></span></span>] 和 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span style=\"margin-right:0.10764em;\">f</span><span>[</span><span>n</span><span style=\"margin-right:0.2222em;\"></span><span>−</span><span style=\"margin-right:0.2222em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>1</span><span>]</span><span>[</span><span>2</span><span>]</span></span></span></span> 中的较大值，即：</p>\n<p class='katex-block'><span><span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>ma</span><span>x</span><span>(</span><span style=\"margin-right:0.10764em;\">f</span><span>[</span><span>n</span><span style=\"margin-right:0.2222em;\"></span><span>−</span><span style=\"margin-right:0.2222em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>1</span><span>]</span><span>[</span><span>1</span><span>]</span><span>,</span><span style=\"margin-right:0.1667em;\"></span><span style=\"margin-right:0.10764em;\">f</span><span>[</span><span>n</span><span style=\"margin-right:0.2222em;\"></span><span>−</span><span style=\"margin-right:0.2222em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>1</span><span>]</span><span>[</span><span>2</span><span>])</span></span></span></span></span></p>\n<p><strong>边界条件</strong>：</p>\n<p class='katex-block'><span><span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:4.32em;vertical-align:-1.91em;\"></span><span><span><span><span><span><span style=\"height:2.35em;\"><span style=\"top:-2.2em;\"><span style=\"height:3.15em;\"></span><span><span>⎩</span></span></span><span style=\"top:-2.192em;\"><span style=\"height:3.15em;\"></span><span style=\"height:0.316em;width:0.8889em;\"><svg xmlns=\"http://www.w3.org/2000/svg\" width='0.8889em' height='0.316em' style='width:0.8889em' viewBox='0 0 888.89 316' preserveAspectRatio='xMinYMin'><path d='M384 0 H504 V316 H384z M384 0 H504 V316 H384z'/></svg></span></span><span style=\"top:-3.15em;\"><span style=\"height:3.15em;\"></span><span><span>⎨</span></span></span><span style=\"top:-4.292em;\"><span style=\"height:3.15em;\"></span><span style=\"height:0.316em;width:0.8889em;\"><svg xmlns=\"http://www.w3.org/2000/svg\" width='0.8889em' height='0.316em' style='width:0.8889em' viewBox='0 0 888.89 316' preserveAspectRatio='xMinYMin'><path d='M384 0 H504 V316 H384z M384 0 H504 V316 H384z'/></svg></span></span><span style=\"top:-4.6em;\"><span style=\"height:3.15em;\"></span><span><span>⎧</span></span></span></span><span>​</span></span><span><span style=\"height:1.85em;\"><span></span></span></span></span></span></span><span><span><span><span><span><span style=\"height:2.41em;\"><span style=\"top:-4.41em;\"><span style=\"height:3.008em;\"></span><span><span style=\"margin-right:0.10764em;\">f</span><span>[</span><span>0</span><span>]</span><span>[</span><span>0</span><span>]</span><span style=\"margin-right:0.2778em;\"></span><span>=</span><span style=\"margin-right:0.2778em;\"></span><span>−</span><span>p</span><span style=\"margin-right:0.02778em;\">r</span><span>i</span><span>ces</span><span>[</span><span>0</span><span>]</span></span></span><span style=\"top:-2.97em;\"><span style=\"height:3.008em;\"></span><span><span style=\"margin-right:0.10764em;\">f</span><span>[</span><span>0</span><span>]</span><span>[</span><span>1</span><span>]</span><span style=\"margin-right:0.2778em;\"></span><span>=</span><span style=\"margin-right:0.2778em;\"></span><span>0</span></span></span><span style=\"top:-1.53em;\"><span style=\"height:3.008em;\"></span><span><span style=\"margin-right:0.10764em;\">f</span><span>[</span><span>0</span><span>]</span><span>[</span><span>2</span><span>]</span><span style=\"margin-right:0.2778em;\"></span><span>=</span><span style=\"margin-right:0.2778em;\"></span><span>0</span></span></span></span><span>​</span></span><span><span style=\"height:1.91em;\"><span></span></span></span></span></span></span></span><span></span></span></span></span></span></span></p>\n<ul>\n<li><span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span style=\"margin-right:0.10764em;\">f</span><span>[</span><span>0</span><span>]</span><span>[</span><span>0</span><span>]</span></span></span></span>：在第 0 天时，如果持有股票，那么只能是在第 0 天买入的，对应负收益 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>−</span><span>p</span><span style=\"margin-right:0.02778em;\">r</span><span>i</span><span>ces</span><span>[</span><span>0</span><span>]</span></span></span></span>；如果不持有股票，那么收益为零。</li>\n<li><span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span style=\"margin-right:0.10764em;\">f</span><span>[</span><span>0</span><span>]</span><span>[</span><span>1</span><span>]</span></span></span></span>：在第 0 天时，不持有股票（可以理解为在-1天买入在0天卖出）收益为0。</li>\n<li><span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span style=\"margin-right:0.10764em;\">f</span><span>[</span><span>0</span><span>]</span><span>[</span><span>2</span><span>]</span></span></span></span>：在第 0 天时，不持有股票（不买入）收益为0。</li>\n</ul>\n</div>\n<h3 id=\"参考代码\"> 参考代码</h3>\n<CodeGroup>\n<CodeGroupItem title=\"c++\">\n<div><pre><code><span>class</span> <span>Solution</span> <span>{</span>\n<span>public</span><span>:</span>\n    <span>// 尽可能地完成更多的交易（多次买卖一支股票）</span>\n    <span>int</span> <span>maxProfit</span><span>(</span>vector<span>&lt;</span><span>int</span><span>></span><span>&amp;</span> prices<span>)</span> <span>{</span>\n        <span>int</span> n <span>=</span> prices<span>.</span><span>size</span><span>(</span><span>)</span><span>;</span>\n        <span>if</span><span>(</span>prices<span>.</span><span>empty</span><span>(</span><span>)</span><span>)</span><span>{</span>\n            <span>return</span> <span>0</span><span>;</span>\n        <span>}</span>     \n\n        vector<span>&lt;</span>vector<span>&lt;</span><span>int</span><span>>></span> <span>f</span><span>(</span>n<span>,</span> <span><span>vector</span><span><span>&lt;</span><span>int</span><span>></span></span></span><span>(</span><span>3</span><span>)</span><span>)</span><span>;</span>\n        f<span>[</span><span>0</span><span>]</span><span>[</span><span>0</span><span>]</span> <span>=</span> <span>-</span>prices<span>[</span><span>0</span><span>]</span><span>;</span>\n        <span>// 用 f[i] 表示第 i 天结束之后的「累计最大收益」</span>\n        <span>// 「处于冷冻期」指的是在第 i 天结束之后的状态。也就是说：如果第 i 天结束之后处于冷冻期，那么第 i+1 天无法买入股票。</span>\n        <span>// f[i][0]: 手上持有股票的最大收益</span>\n        <span>// f[i][1]: 手上不持有股票，并且处于冷冻期的累计最大收益</span>\n        <span>// f[i][2]: 手上不持有股票，并且不在冷冻期的累计最大收益</span>\n        <span>for</span><span>(</span><span>int</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;</span> n<span>;</span> <span>++</span>i<span>)</span><span>{</span>\n            f<span>[</span>i<span>]</span><span>[</span><span>0</span><span>]</span> <span>=</span> <span>max</span><span>(</span>f<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>[</span><span>0</span><span>]</span><span>,</span> f<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>[</span><span>2</span><span>]</span> <span>-</span> prices<span>[</span>i<span>]</span><span>)</span><span>;</span>\n            f<span>[</span>i<span>]</span><span>[</span><span>1</span><span>]</span> <span>=</span> f<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>[</span><span>0</span><span>]</span> <span>+</span> prices<span>[</span>i<span>]</span><span>;</span>\n            f<span>[</span>i<span>]</span><span>[</span><span>2</span><span>]</span> <span>=</span> <span>max</span><span>(</span>f<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>[</span><span>1</span><span>]</span><span>,</span> f<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>[</span><span>2</span><span>]</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>return</span> <span>max</span><span>(</span>f<span>[</span>n <span>-</span> <span>1</span><span>]</span><span>[</span><span>1</span><span>]</span><span>,</span> f<span>[</span>n <span>-</span> <span>1</span><span>]</span><span>[</span><span>2</span><span>]</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div></CodeGroupItem>\n</CodeGroup>\n",
      "image": "https://cdn.jsdelivr.net/gh/River-Cold/pictureBed/vuepress-blog/solution/leetcode/LeetCode-hot-topic-HOT-100/309.png",
      "date_published": "2022-04-04T14:19:55.000Z",
      "date_modified": "2022-04-04T14:19:55.000Z",
      "authors": [
        {
          "name": "RiverCold"
        }
      ],
      "tags": []
    },
    {
      "title": "337.打家劫舍III",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/solution/leetcode/LeetCode-hot-topic-HOT-100/337.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DIII/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/solution/leetcode/LeetCode-hot-topic-HOT-100/337.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DIII/",
      "content_html": "<h1 id=\"_337-打家劫舍iii\"> 337.打家劫舍III</h1>\n<p>https://leetcode-cn.com/problems/house-robber-iii/</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/River-Cold/pictureBed/vuepress-blog/solution/leetcode/LeetCode-hot-topic-HOT-100/337.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"方法一-递归-动态规划\"> 方法一：递归+动态规划</h2>\n<h3 id=\"思路分析\"> 思路分析</h3>\n<div><p>提示</p>\n<p>一棵二叉树，树上的每个点有两种状态（选中和不选中），问不能同时选中有父子关系的点的情况下，能选中的点的最大权值和是多少。</p>\n<p>用<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span style=\"margin-right:0.10764em;\">f</span><span>(</span><span>o</span><span>)</span></span></span></span>表示选择<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.4306em;\"></span><span>o</span></span></span></span>节点的情况下，<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.4306em;\"></span><span>o</span></span></span></span>节点的子树上被选择的节点的最大权值和；用<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span style=\"margin-right:0.03588em;\">g</span><span>(</span><span>o</span><span>)</span></span></span></span>表示不选择<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.4306em;\"></span><span>o</span></span></span></span>节点的情况下，<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.4306em;\"></span><span>o</span></span></span></span>节点的子树上被选择的节点的最大权值和</p>\n<p>设<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.6944em;\"></span><span style=\"margin-right:0.01968em;\">l</span></span></span></span>和<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.4306em;\"></span><span style=\"margin-right:0.02778em;\">r</span></span></span></span>分别代表<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.4306em;\"></span><span>o</span></span></span></span>的左右孩子</p>\n<ul>\n<li>当<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.4306em;\"></span><span>o</span></span></span></span>被选中时，<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.4306em;\"></span><span>o</span></span></span></span>的左右孩子都不能被选中，故 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.4306em;\"></span><span>o</span></span></span></span> 被选中情况下子树上被选中点的最大权值和为 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.6944em;\"></span><span style=\"margin-right:0.01968em;\">l</span></span></span></span> 和 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.4306em;\"></span><span style=\"margin-right:0.02778em;\">r</span></span></span></span> 不被选中的最大权值和相加</li>\n</ul>\n<p class='katex-block'><span><span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span style=\"margin-right:0.10764em;\">f</span><span>(</span><span>o</span><span>)</span><span style=\"margin-right:0.2778em;\"></span><span>=</span><span style=\"margin-right:0.2778em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span style=\"margin-right:0.03588em;\">g</span><span>(</span><span style=\"margin-right:0.01968em;\">l</span><span>)</span><span style=\"margin-right:0.2222em;\"></span><span>+</span><span style=\"margin-right:0.2222em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span style=\"margin-right:0.03588em;\">g</span><span>(</span><span style=\"margin-right:0.02778em;\">r</span><span>)</span></span></span></span></span></p>\n<ul>\n<li>当 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.4306em;\"></span><span>o</span></span></span></span> 不被选中时，<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.4306em;\"></span><span>o</span></span></span></span> 的左右孩子可以被选中，也可以不被选中。对于 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.4306em;\"></span><span>o</span></span></span></span> 的某个具体的孩子 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.4306em;\"></span><span>x</span></span></span></span>，它对 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.4306em;\"></span><span>o</span></span></span></span> 的贡献是 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.4306em;\"></span><span>x</span></span></span></span> 被选中和不被选中情况下权值和的较大值。</li>\n</ul>\n<p class='katex-block'><span><span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span style=\"margin-right:0.03588em;\">g</span><span>(</span><span>o</span><span>)</span><span style=\"margin-right:0.2778em;\"></span><span>=</span><span style=\"margin-right:0.2778em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>ma</span><span>x</span><span>{</span><span style=\"margin-right:0.10764em;\">f</span><span>(</span><span style=\"margin-right:0.01968em;\">l</span><span>)</span><span>,</span><span style=\"margin-right:0.1667em;\"></span><span style=\"margin-right:0.03588em;\">g</span><span>(</span><span style=\"margin-right:0.01968em;\">l</span><span>)}</span><span style=\"margin-right:0.2222em;\"></span><span>+</span><span style=\"margin-right:0.2222em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>ma</span><span>x</span><span>{</span><span style=\"margin-right:0.10764em;\">f</span><span>(</span><span style=\"margin-right:0.02778em;\">r</span><span>)</span><span>,</span><span style=\"margin-right:0.1667em;\"></span><span style=\"margin-right:0.03588em;\">g</span><span>(</span><span style=\"margin-right:0.02778em;\">r</span><span>)}</span></span></span></span></span></p>\n</div>\n<h3 id=\"参考代码\"> 参考代码</h3>\n<CodeGroup>\n<CodeGroupItem title=\"c++\">\n<div><pre><code><span>class</span> <span>Solution</span> <span>{</span>\n<span>public</span><span>:</span>\n    unordered_map<span>&lt;</span>TreeNode<span>*</span><span>,</span> <span>int</span><span>></span> f<span>,</span> g<span>;</span>\n\n    <span>void</span> <span>dfs</span><span>(</span>TreeNode<span>*</span> root<span>)</span><span>{</span>\n        <span>if</span><span>(</span>root <span>==</span> <span>nullptr</span><span>)</span><span>{</span>\n            <span>return</span><span>;</span>\n        <span>}</span>\n        <span>dfs</span><span>(</span>root<span>-></span>left<span>)</span><span>;</span>\n        <span>dfs</span><span>(</span>root<span>-></span>right<span>)</span><span>;</span>\n        f<span>[</span>root<span>]</span> <span>=</span> root<span>-></span>val <span>+</span> g<span>[</span>root<span>-></span>left<span>]</span> <span>+</span> g<span>[</span>root<span>-></span>right<span>]</span><span>;</span>\n        g<span>[</span>root<span>]</span> <span>=</span> <span>max</span><span>(</span>f<span>[</span>root<span>-></span>left<span>]</span><span>,</span> g<span>[</span>root<span>-></span>left<span>]</span><span>)</span> <span>+</span> <span>max</span><span>(</span>f<span>[</span>root<span>-></span>right<span>]</span><span>,</span> g<span>[</span>root<span>-></span>right<span>]</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>int</span> <span>rob</span><span>(</span>TreeNode<span>*</span> root<span>)</span> <span>{</span>\n        <span>dfs</span><span>(</span>root<span>)</span><span>;</span>\n        <span>return</span> <span>max</span><span>(</span>f<span>[</span>root<span>]</span><span>,</span> g<span>[</span>root<span>]</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div></CodeGroupItem>\n</CodeGroup>\n<h2 id=\"方法二-递归-记忆化\"> 方法二：递归+记忆化</h2>\n<h3 id=\"思路分析-2\"> 思路分析</h3>\n<div><p>提示</p>\n<p><strong>当前节点的最大偷钱数=max(根节点权值+4个孙子节点最大偷钱数，两个儿子节点的最大偷钱数）</strong></p>\n<p>根节点权值+4个孙子节点最大偷钱数money1：</p>\n<p class='katex-block'><span><span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.7778em;vertical-align:-0.0833em;\"></span><span>roo</span><span>t</span><span>.</span><span style=\"margin-right:0.03588em;\">v</span><span>a</span><span style=\"margin-right:0.01968em;\">l</span><span style=\"margin-right:0.2222em;\"></span><span>+</span><span style=\"margin-right:0.2222em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>ro</span><span>b</span><span>(</span><span>roo</span><span>t</span><span>.</span><span style=\"margin-right:0.01968em;\">l</span><span>e</span><span style=\"margin-right:0.10764em;\">f</span><span>t</span><span>.</span><span style=\"margin-right:0.01968em;\">l</span><span>e</span><span style=\"margin-right:0.10764em;\">f</span><span>t</span><span>)</span><span style=\"margin-right:0.2222em;\"></span><span>+</span><span style=\"margin-right:0.2222em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>ro</span><span>b</span><span>(</span><span>roo</span><span>t</span><span>.</span><span style=\"margin-right:0.01968em;\">l</span><span>e</span><span style=\"margin-right:0.10764em;\">f</span><span>t</span><span>.</span><span style=\"margin-right:0.02778em;\">r</span><span>i</span><span style=\"margin-right:0.03588em;\">g</span><span>h</span><span>t</span><span>)</span><span style=\"margin-right:0.2222em;\"></span><span>+</span><span style=\"margin-right:0.2222em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>ro</span><span>b</span><span>(</span><span>roo</span><span>t</span><span>.</span><span style=\"margin-right:0.02778em;\">r</span><span>i</span><span style=\"margin-right:0.03588em;\">g</span><span>h</span><span>t</span><span>.</span><span style=\"margin-right:0.01968em;\">l</span><span>e</span><span style=\"margin-right:0.10764em;\">f</span><span>t</span><span>)</span><span style=\"margin-right:0.2222em;\"></span><span>+</span><span style=\"margin-right:0.2222em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>ro</span><span>b</span><span>(</span><span>roo</span><span>t</span><span>.</span><span style=\"margin-right:0.02778em;\">r</span><span>i</span><span style=\"margin-right:0.03588em;\">g</span><span>h</span><span>t</span><span>.</span><span style=\"margin-right:0.02778em;\">r</span><span>i</span><span style=\"margin-right:0.03588em;\">g</span><span>h</span><span>t</span><span>)</span></span></span></span></span></p>\n<p>两个儿子节点的最大偷钱数money2：</p>\n<p class='katex-block'><span><span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>ro</span><span>b</span><span>(</span><span>roo</span><span>t</span><span>.</span><span style=\"margin-right:0.01968em;\">l</span><span>e</span><span style=\"margin-right:0.10764em;\">f</span><span>t</span><span>)</span><span style=\"margin-right:0.2222em;\"></span><span>+</span><span style=\"margin-right:0.2222em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>ro</span><span>b</span><span>(</span><span>roo</span><span>t</span><span>.</span><span style=\"margin-right:0.02778em;\">r</span><span>i</span><span style=\"margin-right:0.03588em;\">g</span><span>h</span><span>t</span><span>)</span></span></span></span></span></p>\n<p>当前节点的最大偷钱数money：</p>\n<p class='katex-block'><span><span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span>m</span><span>o</span><span>n</span><span style=\"margin-right:0.03588em;\">ey</span><span style=\"margin-right:0.2778em;\"></span><span>=</span><span style=\"margin-right:0.2778em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>ma</span><span>x</span><span>(</span><span>m</span><span>o</span><span>n</span><span style=\"margin-right:0.03588em;\">ey</span><span>1</span><span>,</span><span style=\"margin-right:0.1667em;\"></span><span>m</span><span>o</span><span>n</span><span style=\"margin-right:0.03588em;\">ey</span><span>2</span><span>)</span></span></span></span></span></p>\n<p><strong>重复子问题</strong></p>\n<p>根节点在计算自己能偷多少钱的时候，同时计算了 4 个孙子节点能偷多少钱，也计算了 2 个儿子能偷多少钱。这样在儿子当爷爷时，就会产生重复计算一遍孙子节点。</p>\n<p>因此使用哈希表来存储已经计算过的结果，使用记忆化解决重复子问题。</p>\n</div>\n<h3 id=\"参考代码-2\"> 参考代码</h3>\n<CodeGroup>\n<CodeGroupItem title=\"c++\">\n<div><pre><code><span>class</span> <span>Solution</span> <span>{</span>\n<span>public</span><span>:</span>\n    unordered_map<span>&lt;</span>TreeNode<span>*</span><span>,</span> <span>int</span><span>></span> memo<span>;</span>\n\n    <span>int</span> <span>robCore</span><span>(</span>TreeNode<span>*</span> root<span>)</span><span>{</span>\n        <span>if</span><span>(</span>root <span>==</span> <span>nullptr</span><span>)</span><span>{</span>\n            <span>return</span> <span>0</span><span>;</span>\n        <span>}</span>\n        <span>if</span><span>(</span>memo<span>.</span><span>find</span><span>(</span>root<span>)</span> <span>!=</span> memo<span>.</span><span>end</span><span>(</span><span>)</span><span>)</span><span>{</span>\n            <span>return</span> memo<span>[</span>root<span>]</span><span>;</span>\n        <span>}</span>\n        <span>int</span> money <span>=</span> root<span>-></span>val<span>;</span>\n        <span>if</span><span>(</span>root<span>-></span>left <span>!=</span> <span>nullptr</span><span>)</span><span>{</span>\n            money <span>+=</span> <span>(</span><span>rob</span><span>(</span>root<span>-></span>left<span>-></span>left<span>)</span> <span>+</span> <span>rob</span><span>(</span>root<span>-></span>left<span>-></span>right<span>)</span><span>)</span><span>;</span>\n        <span>}</span>\n\n        <span>if</span><span>(</span>root<span>-></span>right <span>!=</span> <span>nullptr</span><span>)</span><span>{</span>\n            money <span>+=</span> <span>(</span><span>rob</span><span>(</span>root<span>-></span>right<span>-></span>left<span>)</span> <span>+</span> <span>rob</span><span>(</span>root<span>-></span>right<span>-></span>right<span>)</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>int</span> res <span>=</span> <span>max</span><span>(</span>money<span>,</span> <span>rob</span><span>(</span>root<span>-></span>left<span>)</span> <span>+</span> <span>rob</span><span>(</span>root<span>-></span>right<span>)</span><span>)</span><span>;</span>\n        memo<span>[</span>root<span>]</span> <span>=</span> res<span>;</span>\n        <span>return</span> res<span>;</span>\n    <span>}</span>\n    <span>int</span> <span>rob</span><span>(</span>TreeNode<span>*</span> root<span>)</span> <span>{</span>\n        <span>return</span> <span>robCore</span><span>(</span>root<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div></CodeGroupItem>\n</CodeGroup>\n",
      "image": "https://cdn.jsdelivr.net/gh/River-Cold/pictureBed/vuepress-blog/solution/leetcode/LeetCode-hot-topic-HOT-100/337.png",
      "date_published": "2022-04-04T14:19:55.000Z",
      "date_modified": "2022-04-04T14:19:55.000Z",
      "authors": [
        {
          "name": "RiverCold"
        }
      ],
      "tags": []
    },
    {
      "title": "338.比特位计数",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/solution/leetcode/LeetCode-hot-topic-HOT-100/338.%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E6%95%B0/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/solution/leetcode/LeetCode-hot-topic-HOT-100/338.%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E6%95%B0/",
      "content_html": "<h1 id=\"_338-比特位计数\"> 338.比特位计数</h1>\n<p>https://leetcode-cn.com/problems/counting-bits/</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/River-Cold/pictureBed/vuepress-blog/solution/leetcode/LeetCode-hot-topic-HOT-100/338.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"方法一-位运算-动态规划\"> 方法一：位运算+动态规划</h2>\n<h3 id=\"思路分析\"> 思路分析</h3>\n<div><p>提示</p>\n<p><strong>位运算技巧</strong></p>\n<p><span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>n</span><span>&amp;</span><span>(</span><span>n</span><span style=\"margin-right:0.2222em;\"></span><span>−</span><span style=\"margin-right:0.2222em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>1</span><span>)</span></span></span></span>可以把 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.4306em;\"></span><span>n</span></span></span></span> 的二进制中，最后一个出现的1改写成0，即消除 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.4306em;\"></span><span>n</span></span></span></span> 的二进制中最后一个出现的1</p>\n<p>因为执行 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>n</span><span>&amp;</span><span>(</span><span>n</span><span style=\"margin-right:0.2222em;\"></span><span>−</span><span style=\"margin-right:0.2222em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>1</span><span>)</span></span></span></span> 使得 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.4306em;\"></span><span>n</span></span></span></span> 变成 0 的操作次数，就是 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.4306em;\"></span><span>n</span></span></span></span> 的二进制中 1 的个数</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/River-Cold/pictureBed/vuepress-blog/solution/leetcode/LeetCode-hot-topic-HOT-100/338-1.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>动态规划</strong></p>\n<p><strong>状态定义</strong>：</p>\n<p>设<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>bi</span><span>t</span><span>s</span><span>[</span><span>i</span><span>]</span></span></span></span>代表以数字i二进制中1的个数</p>\n<p><strong>状态转移方程</strong>：</p>\n<p>令 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span style=\"margin-right:0.03588em;\">y</span><span style=\"margin-right:0.2778em;\"></span><span>=</span><span style=\"margin-right:0.2778em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>x</span><span>&amp;</span><span>(</span><span>x</span><span style=\"margin-right:0.2222em;\"></span><span>−</span><span style=\"margin-right:0.2222em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>1</span><span>)</span></span></span></span>，则 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span style=\"margin-right:0.03588em;\">y</span></span></span></span> 为将 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.4306em;\"></span><span>x</span></span></span></span> 的最低位1改写成0之后的数，显然 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.7804em;vertical-align:-0.136em;\"></span><span>0</span><span style=\"margin-right:0.2778em;\"></span><span>≤</span><span style=\"margin-right:0.2778em;\"></span></span><span><span style=\"height:0.8304em;vertical-align:-0.1944em;\"></span><span><span style=\"margin-right:0.03588em;\">y</span></span><span style=\"margin-right:0.2778em;\"></span><span>≤</span><span style=\"margin-right:0.2778em;\"></span></span><span><span style=\"height:0.4306em;\"></span><span><span>x</span></span></span></span></span>，<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>bi</span><span>t</span><span>s</span><span>[</span><span>x</span><span>]</span><span style=\"margin-right:0.2778em;\"></span><span>=</span><span style=\"margin-right:0.2778em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>bi</span><span>t</span><span>s</span><span>[</span><span style=\"margin-right:0.03588em;\">y</span><span>]</span><span style=\"margin-right:0.2222em;\"></span><span>+</span><span style=\"margin-right:0.2222em;\"></span></span><span><span style=\"height:0.6444em;\"></span><span>1</span></span></span></span>。</p>\n<p class='katex-block'><span><span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>bi</span><span>t</span><span>s</span><span>[</span><span>i</span><span>]</span><span style=\"margin-right:0.2778em;\"></span><span>=</span><span style=\"margin-right:0.2778em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>bi</span><span>t</span><span>s</span><span>[</span><span>i</span><span>&amp;</span><span>(</span><span>i</span><span style=\"margin-right:0.2222em;\"></span><span>−</span><span style=\"margin-right:0.2222em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>1</span><span>)]</span><span style=\"margin-right:0.2222em;\"></span><span>+</span><span style=\"margin-right:0.2222em;\"></span></span><span><span style=\"height:0.6444em;\"></span><span>1</span></span></span></span></span></p>\n<p><strong>边界值</strong>：</p>\n<p class='katex-block'><span><span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>bi</span><span>t</span><span>s</span><span>[</span><span>0</span><span>]</span><span style=\"margin-right:0.2778em;\"></span><span>=</span><span style=\"margin-right:0.2778em;\"></span></span><span><span style=\"height:0.6444em;\"></span><span>0</span></span></span></span></span></p>\n</div>\n<h3 id=\"参考代码\"> 参考代码</h3>\n<CodeGroup>\n<CodeGroupItem title=\"c++\">\n<div><pre><code><span>class</span> <span>Solution</span> <span>{</span>\n<span>public</span><span>:</span>\n    vector<span>&lt;</span><span>int</span><span>></span> <span>countBits</span><span>(</span><span>int</span> n<span>)</span> <span>{</span>\n        vector<span>&lt;</span><span>int</span><span>></span> <span>bits</span><span>(</span>n <span>+</span> <span>1</span><span>)</span><span>;</span>\n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;=</span> n<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n            bits<span>[</span>i<span>]</span> <span>=</span> bits<span>[</span>i <span>&amp;</span> <span>(</span>i <span>-</span> <span>1</span><span>)</span><span>]</span> <span>+</span> <span>1</span><span>;</span>\n        <span>}</span>\n        <span>return</span> bits<span>;</span>\n    <span>}</span>\n<span>}</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div></CodeGroupItem>\n</CodeGroup>\n<h3 id=\"参考文献\"> 参考文献</h3>\n<p><a href=\"https://leetcode-cn.com/problems/number-of-1-bits/solution/fu-xue-ming-zhu-xiang-jie-wei-yun-suan-f-ci7i/\" target=\"_blank\" rel=\"noopener noreferrer\">【负雪明烛】详解位运算，附本题躲坑指南 - 位1的个数 - 力扣（LeetCode） (leetcode-cn.com)</a></p>\n<p><a href=\"https://leetcode-cn.com/problems/counting-bits/solution/bi-te-wei-ji-shu-by-leetcode-solution-0t1i/\" target=\"_blank\" rel=\"noopener noreferrer\">比特位计数 - 比特位计数 - 力扣（LeetCode） (leetcode-cn.com)</a></p>\n",
      "image": "https://cdn.jsdelivr.net/gh/River-Cold/pictureBed/vuepress-blog/solution/leetcode/LeetCode-hot-topic-HOT-100/338.png",
      "date_published": "2022-04-04T14:19:55.000Z",
      "date_modified": "2022-04-04T14:19:55.000Z",
      "authors": [
        {
          "name": "RiverCold"
        }
      ],
      "tags": []
    },
    {
      "title": "416.分割等和子集",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/solution/leetcode/LeetCode-hot-topic-HOT-100/416.%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/solution/leetcode/LeetCode-hot-topic-HOT-100/416.%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86/",
      "content_html": "<h1 id=\"_416-分割等和子集\"> 416.分割等和子集</h1>\n<p>https://leetcode-cn.com/problems/partition-equal-subset-sum/</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/River-Cold/pictureBed/vuepress-blog/solution/leetcode/LeetCode-hot-topic-HOT-100/416.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"方法一-dfs-记忆化\"> 方法一：DFS+记忆化</h2>\n<h3 id=\"思路分析\"> 思路分析</h3>\n<div><p>提示</p>\n<p>记忆化搜索：哈希表的键定义为<code>index</code>和<code>cur</code>的组合来保证其唯一性，<code>key=to_string(index)+'_'+to_string(cur)</code></p>\n</div>\n<h3 id=\"参考代码\"> 参考代码</h3>\n<CodeGroup>\n<CodeGroupItem title=\"c++\">\n<div><pre><code><span>class</span> <span>Solution</span> <span>{</span>\n<span>public</span><span>:</span>\n    unordered_map<span>&lt;</span>string<span>,</span> <span>bool</span><span>></span> dic<span>;</span>\n    <span>bool</span> <span>dfs</span><span>(</span><span>int</span> index<span>,</span> <span>int</span> cur<span>,</span> vector<span>&lt;</span><span>int</span><span>></span><span>&amp;</span> nums<span>)</span><span>{</span>\n        <span>if</span><span>(</span>cur <span>&lt;</span> <span>0</span><span>)</span><span>{</span>\n            <span>return</span> <span>false</span><span>;</span>\n        <span>}</span>\n        <span>if</span><span>(</span>cur <span>==</span> <span>0</span><span>)</span><span>{</span>\n            <span>return</span> <span>true</span><span>;</span>\n        <span>}</span>\n        <span>if</span><span>(</span>index <span>==</span> nums<span>.</span><span>size</span><span>(</span><span>)</span><span>)</span><span>{</span>\n            <span>return</span> <span>false</span><span>;</span>            \n        <span>}</span>\n        string s <span>=</span> <span>to_string</span><span>(</span>index<span>)</span> <span>+</span> <span>\"_\"</span> <span>+</span> <span>to_string</span><span>(</span>cur<span>)</span><span>;</span>\n        <span>if</span><span>(</span>dic<span>.</span><span>find</span><span>(</span>s<span>)</span> <span>!=</span> dic<span>.</span><span>end</span><span>(</span><span>)</span><span>)</span><span>{</span>\n            <span>return</span> dic<span>[</span>s<span>]</span><span>;</span>\n        <span>}</span>\n        dic<span>[</span>s<span>]</span> <span>=</span> <span>dfs</span><span>(</span>index <span>+</span> <span>1</span><span>,</span> cur <span>-</span> nums<span>[</span>index<span>]</span><span>,</span> nums<span>)</span> <span>||</span> <span>dfs</span><span>(</span>index <span>+</span> <span>1</span><span>,</span> cur<span>,</span> nums<span>)</span><span>;</span>\n        <span>return</span> dic<span>[</span>s<span>]</span><span>;</span>\n    <span>}</span>\n    <span>bool</span> <span>canPartition</span><span>(</span>vector<span>&lt;</span><span>int</span><span>></span><span>&amp;</span> nums<span>)</span> <span>{</span>\n        <span>int</span> n <span>=</span> nums<span>.</span><span>size</span><span>(</span><span>)</span><span>;</span>\n        <span>int</span> sum <span>=</span> <span>0</span><span>;</span>\n        <span>int</span> maxnum <span>=</span> <span>0</span><span>;</span>\n        <span>for</span><span>(</span><span>int</span> num <span>:</span> nums<span>)</span><span>{</span>\n            sum <span>+=</span> num<span>;</span>\n            maxnum <span>=</span> <span>max</span><span>(</span>maxnum<span>,</span> num<span>)</span><span>;</span>\n        <span>}</span>\n        <span>if</span><span>(</span>sum <span>%</span> <span>2</span> <span>!=</span> <span>0</span><span>)</span><span>{</span>\n            <span>return</span> <span>false</span><span>;</span>\n        <span>}</span>\n        <span>if</span><span>(</span>maxnum <span>*</span> <span>2</span> <span>></span> sum<span>)</span><span>{</span>\n            <span>return</span> <span>false</span><span>;</span>\n        <span>}</span>\n        <span>return</span> <span>dfs</span><span>(</span><span>0</span><span>,</span> sum <span>/</span> <span>2</span><span>,</span> nums<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br></div></div></CodeGroupItem>\n<CodeGroupItem title=\"c++\">\n<div><pre><code><span>class</span> <span>Solution</span> <span>{</span>\n<span>public</span><span>:</span>\n    vector<span>&lt;</span><span>int</span><span>></span> dp<span>;</span>\n    <span>bool</span> <span>dfs</span><span>(</span>vector<span>&lt;</span><span>int</span><span>></span><span>&amp;</span> nums<span>,</span> <span>int</span> cur<span>,</span> <span>int</span> idx<span>)</span><span>{</span>\n        <span>if</span><span>(</span>cur <span>&lt;</span> <span>0</span><span>)</span><span>{</span>\n            <span>return</span> <span>false</span><span>;</span>\n        <span>}</span>\n        <span>if</span><span>(</span>cur <span>==</span> <span>0</span><span>)</span><span>{</span>\n            <span>return</span> <span>true</span><span>;</span>\n        <span>}</span>\n        <span>if</span><span>(</span>dp<span>[</span>cur<span>]</span> <span>!=</span> <span>0</span><span>)</span><span>{</span>\n            <span>return</span> dp<span>[</span>cur<span>]</span> <span>==</span> <span>1</span> <span>?</span> <span>true</span> <span>:</span> <span>false</span><span>;</span>\n        <span>}</span>\n        <span>bool</span> find <span>=</span> <span>false</span><span>;</span>\n        <span>for</span><span>(</span><span>int</span> i <span>=</span> idx<span>;</span> i <span>&lt;</span> nums<span>.</span><span>size</span><span>(</span><span>)</span><span>;</span> i<span>++</span><span>)</span><span>{</span>\n            find <span>|=</span> <span>dfs</span><span>(</span>nums<span>,</span> cur <span>-</span> nums<span>[</span>i<span>]</span><span>,</span> i <span>+</span> <span>1</span><span>)</span><span>;</span>\n            <span>if</span><span>(</span>find<span>)</span><span>{</span>\n                <span>break</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n        dp<span>[</span>cur<span>]</span> <span>=</span> find <span>?</span> <span>1</span> <span>:</span> <span>-</span><span>1</span><span>;</span>\n        <span>return</span> find<span>;</span>\n    <span>}</span>\n    <span>bool</span> <span>canPartition</span><span>(</span>vector<span>&lt;</span><span>int</span><span>></span><span>&amp;</span> nums<span>)</span> <span>{</span>\n        <span>int</span> sum <span>=</span> <span>0</span><span>;</span>\n        <span>int</span> maxnum <span>=</span> <span>0</span><span>;</span>\n        <span>for</span><span>(</span><span>int</span> num <span>:</span> nums<span>)</span><span>{</span>\n            sum <span>+=</span> num<span>;</span>\n            maxnum <span>=</span> <span>max</span><span>(</span>maxnum<span>,</span> num<span>)</span><span>;</span>\n        <span>}</span>\n        <span>if</span><span>(</span>sum <span>%</span> <span>2</span> <span>!=</span> <span>0</span><span>)</span><span>{</span>\n            <span>return</span> <span>false</span><span>;</span>\n        <span>}</span>\n        <span>if</span><span>(</span>maxnum <span>*</span> <span>2</span> <span>></span> sum<span>)</span><span>{</span>\n            <span>return</span> <span>false</span><span>;</span>\n        <span>}</span>\n        dp<span>.</span><span>resize</span><span>(</span>sum <span>/</span> <span>2</span> <span>+</span> <span>1</span><span>,</span> <span>0</span><span>)</span><span>;</span>\n        <span>return</span> <span>dfs</span><span>(</span>nums<span>,</span> sum <span>/</span> <span>2</span><span>,</span> <span>0</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br></div></div></CodeGroupItem>\n</CodeGroup>\n<h2 id=\"方法二-动态规划\"> 方法二：动态规划</h2>\n<div><p>提示</p>\n<p><strong>状态定义</strong>：</p>\n<p>设<code>dp[i][j]</code>代表从数组的<code>[0,i]</code>下标范围内选取若干个正整数（可以是0个） 是否存在一种选取方案使得被选取的正整数的和等于j。初始时，<code>dp</code>中的全部元素都是<code>false</code></p>\n<p><strong>求解值</strong>：</p>\n<p class='katex-block'><span><span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>d</span><span>p</span><span>[</span><span>n</span><span style=\"margin-right:0.2222em;\"></span><span>−</span><span style=\"margin-right:0.2222em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>1</span><span>]</span><span>[</span><span>t</span><span>a</span><span style=\"margin-right:0.02778em;\">r</span><span style=\"margin-right:0.03588em;\">g</span><span>e</span><span>t</span><span>]</span></span></span></span></span></p>\n<p><strong>状态转移方程</strong>：</p>\n<p class='katex-block'><span><span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>d</span><span>p</span><span>[</span><span>i</span><span>]</span><span>[</span><span style=\"margin-right:0.05724em;\">j</span><span>]</span><span style=\"margin-right:0.2778em;\"></span><span>=</span><span style=\"margin-right:0.2778em;\"></span></span><span><span style=\"height:3em;vertical-align:-1.25em;\"></span><span><span style=\"top:0em;\"><span>{</span></span><span><span><span><span><span><span style=\"height:1.69em;\"><span style=\"top:-3.69em;\"><span style=\"height:3.008em;\"></span><span><span>d</span><span>p</span><span>[</span><span>i</span><span style=\"margin-right:0.2222em;\"></span><span>−</span><span style=\"margin-right:0.2222em;\"></span><span>1</span><span>]</span><span>[</span><span style=\"margin-right:0.05724em;\">j</span><span>]</span><span> </span><span>∣</span><span> </span><span>d</span><span>p</span><span>[</span><span>i</span><span style=\"margin-right:0.2222em;\"></span><span>−</span><span style=\"margin-right:0.2222em;\"></span><span>1</span><span>]</span><span>[</span><span style=\"margin-right:0.05724em;\">j</span><span style=\"margin-right:0.2222em;\"></span><span>−</span><span style=\"margin-right:0.2222em;\"></span><span>n</span><span>u</span><span>m</span><span>s</span><span>[</span><span>i</span><span>]]</span><span>,</span></span></span><span style=\"top:-2.25em;\"><span style=\"height:3.008em;\"></span><span><span>d</span><span>p</span><span>[</span><span>i</span><span style=\"margin-right:0.2222em;\"></span><span>−</span><span style=\"margin-right:0.2222em;\"></span><span>1</span><span>]</span><span>[</span><span style=\"margin-right:0.05724em;\">j</span><span>]</span><span>,</span></span></span></span><span>​</span></span><span><span style=\"height:1.19em;\"><span></span></span></span></span></span><span style=\"width:1em;\"></span><span><span><span><span style=\"height:1.69em;\"><span style=\"top:-3.69em;\"><span style=\"height:3.008em;\"></span><span><span style=\"margin-right:0.05724em;\">j</span><span style=\"margin-right:0.2778em;\"></span><span>≥</span><span style=\"margin-right:0.2778em;\"></span><span><span>n</span><span>u</span><span>m</span><span>s</span><span>[</span><span>i</span><span>]</span></span></span></span><span style=\"top:-2.25em;\"><span style=\"height:3.008em;\"></span><span><span style=\"margin-right:0.05724em;\">j</span><span style=\"margin-right:0.2778em;\"></span><span>&lt;</span><span style=\"margin-right:0.2778em;\"></span><span>n</span><span>u</span><span>m</span><span>s</span><span>[</span><span>i</span><span>]</span></span></span></span><span>​</span></span><span><span style=\"height:1.19em;\"><span></span></span></span></span></span></span></span><span></span></span></span></span></span></span></p>\n<p><strong>边界条件</strong>：</p>\n<ul>\n<li>如果不选取任何正整数，则被选取的正整数等于0，因此对于所有 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.7804em;vertical-align:-0.136em;\"></span><span>0</span><span style=\"margin-right:0.2778em;\"></span><span>≤</span><span style=\"margin-right:0.2778em;\"></span></span><span><span style=\"height:0.6986em;vertical-align:-0.0391em;\"></span><span><span>i</span></span><span style=\"margin-right:0.2778em;\"></span><span>&lt;</span><span style=\"margin-right:0.2778em;\"></span></span><span><span style=\"height:0.4306em;\"></span><span><span>n</span></span></span></span></span>，都有 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>d</span><span>p</span><span>[</span><span>i</span><span>]</span><span>[</span><span>0</span><span>]</span><span style=\"margin-right:0.2778em;\"></span><span>=</span><span style=\"margin-right:0.2778em;\"></span></span><span><span style=\"height:0.6151em;\"></span><span>t</span><span style=\"margin-right:0.02778em;\">r</span><span>u</span><span>e</span></span></span></span></li>\n<li>当 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.6595em;\"></span><span>i</span><span style=\"margin-right:0.2778em;\"></span><span>==</span><span style=\"margin-right:0.2778em;\"></span></span><span><span style=\"height:0.6444em;\"></span><span>0</span></span></span></span> 时，只有一个正整数 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>n</span><span>u</span><span>m</span><span>s</span><span>[</span><span>0</span><span>]</span></span></span></span> 可以被选取，因此 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>d</span><span>p</span><span>[</span><span>0</span><span>]</span><span>[</span><span>n</span><span>u</span><span>m</span><span>s</span><span>[</span><span>0</span><span>]]</span><span style=\"margin-right:0.2778em;\"></span><span>=</span><span style=\"margin-right:0.2778em;\"></span></span><span><span style=\"height:0.6151em;\"></span><span>t</span><span style=\"margin-right:0.02778em;\">r</span><span>u</span><span>e</span></span></span></span></li>\n</ul>\n</div>\n<div><pre><code><span>class</span> <span>Solution</span> <span>{</span>\n<span>public</span><span>:</span>\n    <span>bool</span> <span>canPartition</span><span>(</span>vector<span>&lt;</span><span>int</span><span>></span><span>&amp;</span> nums<span>)</span> <span>{</span>\n        <span>int</span> n <span>=</span> nums<span>.</span><span>size</span><span>(</span><span>)</span><span>;</span>\n        <span>int</span> sum <span>=</span> <span>0</span><span>,</span> maxnum <span>=</span> <span>0</span><span>;</span>\n        <span>for</span><span>(</span><span>int</span> num <span>:</span> nums<span>)</span><span>{</span>\n            maxnum <span>=</span> <span>max</span><span>(</span>maxnum<span>,</span> num<span>)</span><span>;</span>\n            sum <span>+=</span> num<span>;</span>\n        <span>}</span>\n        <span>if</span><span>(</span>sum <span>%</span> <span>2</span> <span>==</span> <span>1</span><span>)</span><span>{</span>\n            <span>return</span> <span>false</span><span>;</span>\n        <span>}</span>\n        <span>if</span><span>(</span>maxnum <span>></span> <span>(</span>sum <span>/</span> <span>2</span><span>)</span><span>)</span><span>{</span>\n            <span>return</span> <span>false</span><span>;</span>\n        <span>}</span>\n        <span>int</span> tar <span>=</span> sum <span>/</span> <span>2</span><span>;</span>\n        vector<span>&lt;</span>vector<span>&lt;</span><span>int</span><span>>></span> <span>dp</span><span>(</span>n <span>+</span> <span>1</span><span>,</span> <span><span>vector</span><span><span>&lt;</span><span>int</span><span>></span></span></span><span>(</span>tar <span>+</span> <span>1</span><span>,</span> <span>false</span><span>)</span><span>)</span><span>;</span>\n        dp<span>[</span><span>0</span><span>]</span><span>[</span><span>0</span><span>]</span> <span>=</span> <span>true</span><span>;</span>\n        <span>for</span><span>(</span><span>int</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;=</span> n<span>;</span> i<span>++</span><span>)</span><span>{</span>\n            <span>for</span><span>(</span><span>int</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;=</span> tar<span>;</span> j<span>++</span><span>)</span><span>{</span>\n                dp<span>[</span>i<span>]</span><span>[</span>j<span>]</span> <span>=</span> dp<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>[</span>j<span>]</span><span>;</span>\n                <span>if</span><span>(</span>j <span>>=</span> nums<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>)</span><span>{</span>\n                    dp<span>[</span>i<span>]</span><span>[</span>j<span>]</span> <span>|=</span> dp<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>[</span>j <span>-</span> nums<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>]</span><span>;</span>\n                <span>}</span>\n                <span>if</span><span>(</span>j <span>==</span> tar<span>)</span><span>{</span>\n                    <span>if</span><span>(</span>dp<span>[</span>i<span>]</span><span>[</span>j<span>]</span><span>)</span><span>{</span>\n                        <span>return</span> <span>true</span><span>;</span>\n                    <span>}</span>\n                <span>}</span>\n            <span>}</span>\n        <span>}</span>\n        <span>return</span> <span>false</span><span>;</span>\n    <span>}</span>\n<span>}</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br></div></div><p>:::</p>\n<p>::::</p>\n<h2 id=\"参考文献\"> 参考文献</h2>\n<p><a href=\"https://leetcode-cn.com/problems/partition-equal-subset-sum/solution/ti-gong-wo-de-yi-ge-xie-dong-tai-gui-hua-44n4/\" target=\"_blank\" rel=\"noopener noreferrer\">提供我的一个写动态规划问题的思路 - 分割等和子集 - 力扣（LeetCode） (leetcode-cn.com)</a></p>\n<p><a href=\"https://leetcode-cn.com/problems/partition-equal-subset-sum/solution/fen-ge-deng-he-zi-ji-by-leetcode-solution/\" target=\"_blank\" rel=\"noopener noreferrer\">分割等和子集 - 分割等和子集 - 力扣（LeetCode） (leetcode-cn.com)</a></p>\n",
      "image": "https://cdn.jsdelivr.net/gh/River-Cold/pictureBed/vuepress-blog/solution/leetcode/LeetCode-hot-topic-HOT-100/416.png",
      "date_published": "2022-04-04T14:19:55.000Z",
      "date_modified": "2022-04-04T14:19:55.000Z",
      "authors": [
        {
          "name": "RiverCold"
        }
      ],
      "tags": []
    },
    {
      "title": "42.接雨水",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/solution/leetcode/LeetCode-hot-topic-HOT-100/42.%E6%8E%A5%E9%9B%A8%E6%B0%B4/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/solution/leetcode/LeetCode-hot-topic-HOT-100/42.%E6%8E%A5%E9%9B%A8%E6%B0%B4/",
      "content_html": "<h1 id=\"_42-接雨水\"> 42.接雨水</h1>\n<p>https://leetcode-cn.com/problems/trapping-rain-water/</p>\n<h2 id=\"方法一-中心扩散\"> 方法一：中心扩散</h2>\n<h3 id=\"思路分析\"> 思路分析</h3>\n<div><p>提示</p>\n</div>\n<h3 id=\"参考代码\"> 参考代码</h3>\n<CodeGroup>\n<CodeGroupItem title=\"c++\">\n<div><pre><code>\n</code></pre>\n<div><span>1</span><br></div></div></CodeGroupItem>\n</CodeGroup>\n<h2 id=\"方法二-单调栈\"> 方法二：单调栈</h2>\n<div><p>提示</p>\n</div>\n<div><pre><code>\n</code></pre>\n<div><span>1</span><br></div></div><p>:::</p>\n<p>::::</p>\n<h2 id=\"参考文献\"> 参考文献</h2>\n<p><a href=\"https://leetcode-cn.com/problems/trapping-rain-water/solution/dan-diao-zhan-jie-jue-jie-yu-shui-wen-ti-by-sweeti/\" target=\"_blank\" rel=\"noopener noreferrer\">单调栈O(n)解决，动图预警🎶🎵 - 接雨水 - 力扣（LeetCode） (leetcode-cn.com)</a></p>\n",
      "date_published": "2022-04-04T14:19:55.000Z",
      "date_modified": "2022-04-04T14:19:55.000Z",
      "authors": [
        {
          "name": "RiverCold"
        }
      ],
      "tags": []
    },
    {
      "title": "437.路径总和 III",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/solution/leetcode/LeetCode-hot-topic-HOT-100/437.%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C%20III/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/solution/leetcode/LeetCode-hot-topic-HOT-100/437.%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C%20III/",
      "content_html": "<h1 id=\"_437-路径总和-iii\"> 437.路径总和 III</h1>\n<p>https://leetcode-cn.com/problems/path-sum-iii/</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/River-Cold/pictureBed/vuepress-blog/docs/solution/leetcode/LeetCode-hot-topic-HOT-100/437.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"方法一-递归\"> 方法一：递归</h2>\n<h3 id=\"思路分析\"> 思路分析</h3>\n<div><p>提示</p>\n</div>\n<h3 id=\"参考代码\"> 参考代码</h3>\n<CodeGroup>\n<CodeGroupItem title=\"c++\">\n<div><pre><code><span>class</span> <span>Solution</span> <span>{</span>\n<span>public</span><span>:</span>\n    <span>int</span> <span>pathSumStartWithRoot</span><span>(</span>TreeNode<span>*</span> root<span>,</span> <span>int</span> sum<span>)</span><span>{</span>\n        <span>if</span><span>(</span>root <span>==</span> <span>NULL</span><span>)</span> <span>return</span> <span>0</span><span>;</span>\n        <span>int</span> ret <span>=</span> <span>0</span><span>;</span>\n        <span>if</span><span>(</span>root<span>-></span>val <span>==</span> sum<span>)</span> ret<span>++</span><span>;</span>\n        ret <span>+=</span> <span>pathSumStartWithRoot</span><span>(</span>root<span>-></span>left<span>,</span> sum <span>-</span> root<span>-></span>val<span>)</span> <span>+</span> <span>pathSumStartWithRoot</span><span>(</span>root<span>-></span>right<span>,</span> sum <span>-</span> root<span>-></span>val<span>)</span><span>;</span>\n        <span>return</span> ret<span>;</span>\n    <span>}</span>\n    <span>int</span> <span>pathSum</span><span>(</span>TreeNode<span>*</span> root<span>,</span> <span>int</span> sum<span>)</span> <span>{</span>\n        <span>if</span><span>(</span>root <span>==</span> <span>NULL</span><span>)</span><span>{</span>\n            <span>return</span> <span>0</span><span>;</span>\n        <span>}</span>\n        <span>int</span> ret <span>=</span> <span>pathSumStartWithRoot</span><span>(</span>root<span>,</span> sum<span>)</span> <span>+</span> <span>pathSum</span><span>(</span>root<span>-></span>left<span>,</span> sum<span>)</span> <span>+</span> <span>pathSum</span><span>(</span>root<span>-></span>right<span>,</span> sum<span>)</span><span>;</span>\n        <span>return</span> ret<span>;</span>\n    <span>}</span>\n<span>}</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div></CodeGroupItem>\n</CodeGroup>\n<h2 id=\"方法二-前缀和\"> 方法二：前缀和</h2>\n<div><p>提示</p>\n<p><strong>解题思路</strong>：</p>\n<p><code>dfs</code>先序遍历二叉树</p>\n<p>记录下根节点 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.6151em;\"></span><span>roo</span><span>t</span></span></span></span> 到当前节点 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span>p</span></span></span></span> 的路径上除当前节点以外所有节点的前缀和</p>\n<p>在已保存的路径前缀和中查找是否存在前缀和刚好等于当前节点到根节点的前缀</p>\n<p>和 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.4306em;\"></span><span>c</span><span>u</span><span style=\"margin-right:0.02778em;\">rr</span></span></span></span> 减去 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span>t</span><span>a</span><span style=\"margin-right:0.02778em;\">r</span><span style=\"margin-right:0.03588em;\">g</span><span>e</span><span style=\"margin-right:0.05764em;\">tS</span><span>u</span><span>m</span></span></span></span></p>\n<p>如果从根节点 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.6151em;\"></span><span>roo</span><span>t</span></span></span></span> 到当前节点 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.6944em;\"></span><span>n</span><span>o</span><span>d</span><span>e</span></span></span></span> 的路径中存在节点 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.854em;vertical-align:-0.1944em;\"></span><span>p</span><span>i</span></span></span></span> 到根节点 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.6151em;\"></span><span>roo</span><span>t</span></span></span></span> 的前缀和为 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span>c</span><span>u</span><span style=\"margin-right:0.02778em;\">rr</span><span style=\"margin-right:0.2222em;\"></span><span>−</span><span style=\"margin-right:0.2222em;\"></span></span><span><span style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span>t</span><span>a</span><span style=\"margin-right:0.02778em;\">r</span><span style=\"margin-right:0.03588em;\">g</span><span>e</span><span style=\"margin-right:0.05764em;\">tS</span><span>u</span><span>m</span></span></span></span>，则节点 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.6389em;vertical-align:-0.2083em;\"></span><span><span>p</span><span><span><span><span style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span><span>i</span><span>+</span><span>1</span></span></span></span></span><span>​</span></span><span><span style=\"height:0.2083em;\"><span></span></span></span></span></span></span></span></span></span> 到 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.6944em;\"></span><span>n</span><span>o</span><span>d</span><span>e</span></span></span></span> 的路径上所有节点的和一定为<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span>t</span><span>a</span><span style=\"margin-right:0.02778em;\">r</span><span style=\"margin-right:0.03588em;\">g</span><span>e</span><span style=\"margin-right:0.05764em;\">tS</span><span>u</span><span>m</span></span></span></span>，则路径数目加1</p>\n<p><strong>变量定义</strong>：</p>\n<p><code>prefix</code>：key是前缀和，val是该前缀和的节点数量，记录数量是因为有可能出现重复前缀和的可能。</p>\n<p><code>targetSum</code>：节点值的目标总和</p>\n<p><code>curr</code>：根节点root到当前节点p的路径上除当前节点以外所有节点的前缀和</p>\n<p><strong>理解难点</strong>：</p>\n<ol>\n<li>前缀和初始化代码<code>prefix[0]=1</code>的含义？</li>\n</ol>\n<blockquote>\n<p>以根节点开始的路径合法，可以认为有一个虚拟的根节点的父节点，其前缀和为0</p>\n</blockquote>\n<ol start=\"2\">\n<li>回溯代码<code>prefix[curr]--</code>的含义？</li>\n</ol>\n<blockquote>\n<p>由于我们只能统计往下的路径，但是树的遍历会同时搜索两个方向的子树。因此我们应当在搜索完以某个节点为根的左右子树之后，应当回溯地将路径总和从哈希表中删除，防止统计到跨越两个方向的路径。</p>\n<p>当我们讨论两个节点的前缀和差值时，有一个前提：一个节点必须是另一个节点的祖先节点状态恢复代码的作用就是： 在遍历完一个节点的所有子节点后，将其从map中除去。</p>\n</blockquote>\n</div>\n<div><pre><code><span>class</span> <span>Solution</span> <span>{</span>\n<span>public</span><span>:</span>\n    unordered_map<span>&lt;</span><span>long</span> <span>long</span><span>,</span> <span>int</span><span>></span> prefix<span>;</span>\n    <span>int</span> <span>dfs</span><span>(</span>TreeNode<span>*</span> root<span>,</span> <span>long</span> <span>long</span> curr<span>,</span> <span>int</span> targetSum<span>)</span><span>{</span>\n        <span>if</span><span>(</span>root <span>==</span> <span>nullptr</span><span>)</span><span>{</span>\n            <span>return</span> <span>0</span><span>;</span>\n        <span>}</span>\n\n        <span>//ret代表和等于targetSum的路径的数目</span>\n        <span>int</span> ret <span>=</span> <span>0</span><span>;</span>    \n        curr <span>+=</span> root<span>-></span>val<span>;</span>\n\n        <span>if</span><span>(</span>prefix<span>.</span><span>count</span><span>(</span>curr <span>-</span> targetSum<span>)</span><span>)</span><span>{</span>\n            ret <span>=</span> prefix<span>[</span>curr <span>-</span> targetSum<span>]</span><span>;</span>\n        <span>}</span>\n\n        prefix<span>[</span>curr<span>]</span><span>++</span><span>;</span>\n        ret <span>+=</span> <span>dfs</span><span>(</span>root<span>-></span>left<span>,</span> curr<span>,</span> targetSum<span>)</span><span>;</span>\n        ret <span>+=</span> <span>dfs</span><span>(</span>root<span>-></span>right<span>,</span> curr<span>,</span> targetSum<span>)</span><span>;</span>\n        prefix<span>[</span>curr<span>]</span><span>--</span><span>;</span>\n\n        <span>return</span> ret<span>;</span>\n    <span>}</span>\n\n    <span>int</span> <span>pathSum</span><span>(</span>TreeNode<span>*</span> root<span>,</span> <span>int</span> targetSum<span>)</span> <span>{</span>\n        prefix<span>[</span><span>0</span><span>]</span> <span>=</span> <span>1</span><span>;</span>\n        <span>return</span> <span>dfs</span><span>(</span>root<span>,</span> <span>0</span><span>,</span> targetSum<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><p>:::</p>\n<p>::::</p>\n<h2 id=\"参考文献\"> 参考文献</h2>\n<p><a href=\"https://leetcode-cn.com/problems/path-sum-iii/solution/lu-jing-zong-he-iii-by-leetcode-solution-z9td/\" target=\"_blank\" rel=\"noopener noreferrer\">路径总和 III - 路径总和 III - 力扣（LeetCode） (leetcode-cn.com)</a></p>\n<p><a href=\"https://leetcode-cn.com/problems/path-sum-iii/solution/gong-shui-san-xie-yi-ti-shuang-jie-dfs-q-usa7/\" target=\"_blank\" rel=\"noopener noreferrer\">【宫水三叶】一题双解 :「DFS」&amp;「前缀和」 - 路径总和 III - 力扣（LeetCode） (leetcode-cn.com)</a></p>\n<p><a href=\"https://leetcode-cn.com/problems/path-sum-iii/solution/dui-qian-zhui-he-jie-fa-de-yi-dian-jie-s-dey6/\" target=\"_blank\" rel=\"noopener noreferrer\">对前缀和解法的一点解释 - 路径总和 III - 力扣（LeetCode） (leetcode-cn.com)</a></p>\n",
      "image": "https://cdn.jsdelivr.net/gh/River-Cold/pictureBed/vuepress-blog/docs/solution/leetcode/LeetCode-hot-topic-HOT-100/437.png",
      "date_published": "2022-04-04T14:19:55.000Z",
      "date_modified": "2022-04-04T14:19:55.000Z",
      "authors": [
        {
          "name": "RiverCold"
        }
      ],
      "tags": []
    },
    {
      "title": "494.目标和",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/solution/leetcode/LeetCode-hot-topic-HOT-100/494.%E7%9B%AE%E6%A0%87%E5%92%8C/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/solution/leetcode/LeetCode-hot-topic-HOT-100/494.%E7%9B%AE%E6%A0%87%E5%92%8C/",
      "content_html": "<h1 id=\"_494-目标和\"> 494.目标和</h1>\n<p>https://leetcode-cn.com/problems/target-sum/</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/River-Cold/pictureBed/vuepress-blog/solution/leetcode/LeetCode-hot-topic-HOT-100/494.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"方法一-递归回溯\"> 方法一：递归回溯</h2>\n<h3 id=\"思路分析\"> 思路分析</h3>\n<div><p>提示</p>\n<p>数据范围只有 2020，而且每个数据只有 +/-+/− 两种选择，因此可以直接使用 DFS 进行「爆搜」</p>\n</div>\n<h3 id=\"参考代码\"> 参考代码</h3>\n<CodeGroup>\n<CodeGroupItem title=\"c++\">\n<div><pre><code><span>class</span> <span>Solution</span> <span>{</span>\n<span>public</span><span>:</span>\n    <span>int</span> cnt <span>=</span> <span>0</span><span>;</span>\n    <span>void</span> <span>dfs</span><span>(</span><span>int</span> sum<span>,</span> <span>int</span> index<span>,</span> vector<span>&lt;</span><span>int</span><span>></span><span>&amp;</span> nums<span>,</span> <span>int</span> target<span>)</span><span>{</span>\n        <span>if</span><span>(</span>index <span>==</span> nums<span>.</span><span>size</span><span>(</span><span>)</span><span>)</span><span>{</span>\n            <span>if</span><span>(</span>sum <span>==</span> target<span>)</span><span>{</span>\n                cnt<span>++</span><span>;</span>\n            <span>}</span>\n            <span>return</span><span>;</span>\n        <span>}</span>\n        <span>dfs</span><span>(</span>sum <span>+</span> nums<span>[</span>index<span>]</span><span>,</span> index <span>+</span> <span>1</span><span>,</span> nums<span>,</span> target<span>)</span><span>;</span>\n        <span>dfs</span><span>(</span>sum <span>-</span> nums<span>[</span>index<span>]</span><span>,</span> index <span>+</span> <span>1</span><span>,</span> nums<span>,</span> target<span>)</span><span>;</span>\n    <span>}</span>\n    <span>int</span> <span>findTargetSumWays</span><span>(</span>vector<span>&lt;</span><span>int</span><span>></span><span>&amp;</span> nums<span>,</span> <span>int</span> target<span>)</span> <span>{</span>\n        <span>dfs</span><span>(</span><span>0</span><span>,</span> <span>0</span><span>,</span> nums<span>,</span> target<span>)</span><span>;</span>\n        <span>return</span> cnt<span>;</span>\n    <span>}</span>\n<span>}</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div></CodeGroupItem>\n</CodeGroup>\n<h3 id=\"复杂度分析\"> 复杂度分析</h3>\n<ol>\n<li>时间复杂度：<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span style=\"margin-right:0.02778em;\">O</span><span>(</span><span><span>2</span><span><span><span><span style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span>n</span></span></span></span></span></span></span></span><span>)</span></span></span></span></li>\n<li>空间复杂度：<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span style=\"margin-right:0.02778em;\">O</span><span>(</span><span>1</span><span>)</span></span></span></span></li>\n</ol>\n<h2 id=\"方法二-动态规划\"> 方法二：动态规划</h2>\n<h3 id=\"思路分析-2\"> 思路分析</h3>\n<div><p>提示</p>\n<p><strong>状态定义</strong>：</p>\n<p>设<code>dp[i][j]</code>表示考虑前<code>i</code>个数，当前计算结果为<code>j</code>的方案数</p>\n<p><strong>状态转移方程</strong>：</p>\n<p class='katex-block'><span><span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span style=\"margin-right:0.10764em;\">f</span><span>[</span><span>i</span><span>]</span><span>[</span><span style=\"margin-right:0.05724em;\">j</span><span>]</span><span style=\"margin-right:0.2778em;\"></span><span>=</span><span style=\"margin-right:0.2778em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span style=\"margin-right:0.10764em;\">f</span><span>[</span><span>i</span><span style=\"margin-right:0.2222em;\"></span><span>−</span><span style=\"margin-right:0.2222em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>1</span><span>]</span><span>[</span><span style=\"margin-right:0.05724em;\">j</span><span style=\"margin-right:0.2222em;\"></span><span>−</span><span style=\"margin-right:0.2222em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>n</span><span>u</span><span>m</span><span>s</span><span>[</span><span>i</span><span style=\"margin-right:0.2222em;\"></span><span>−</span><span style=\"margin-right:0.2222em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>1</span><span>]]</span><span style=\"margin-right:0.2222em;\"></span><span>+</span><span style=\"margin-right:0.2222em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span style=\"margin-right:0.10764em;\">f</span><span>[</span><span>i</span><span style=\"margin-right:0.2222em;\"></span><span>−</span><span style=\"margin-right:0.2222em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>1</span><span>]</span><span>[</span><span style=\"margin-right:0.05724em;\">j</span><span style=\"margin-right:0.2222em;\"></span><span>+</span><span style=\"margin-right:0.2222em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>n</span><span>u</span><span>m</span><span>s</span><span>[</span><span>i</span><span style=\"margin-right:0.2222em;\"></span><span>−</span><span style=\"margin-right:0.2222em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>1</span><span>]]</span></span></span></span></span></p>\n<p><strong>边界条件</strong>：</p>\n<p>代表不考虑任何数，凑出计算结果为 0 的方案数为 1 种</p>\n<p class='katex-block'><span><span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span style=\"margin-right:0.10764em;\">f</span><span>[</span><span>0</span><span>]</span><span>[</span><span>0</span><span>]</span><span style=\"margin-right:0.2778em;\"></span><span>=</span><span style=\"margin-right:0.2778em;\"></span></span><span><span style=\"height:0.6444em;\"></span><span>1</span></span></span></span></span></p>\n<p>这里还需要考虑维度范围：</p>\n<p>第一维为物品数量：范围为<code>[0,nums.size()]</code></p>\n<p>第二维为中间结果：令<code>s</code>为所有<code>nums</code>元素的总和，则中间结果的范围为<code>[-s,s]</code></p>\n<h3 id=\"参考代码-2\"> 参考代码</h3>\n</div>\n<div><pre><code><span>class</span> <span>Solution</span> <span>{</span>\n<span>public</span><span>:</span>\n    <span>/*\n    状态定义:\n    f[i][j]代表考虑前i个数，当前计算结果为j的方案数\n    状态转移方程:\n    f[i][j] = f[i - 1][j - nums[i - 1]] + f[i - 1][j + nums[i - 1]]\n    在转移时，对第二维度的使用做一个 s 的右偏移，以确保「负权值」也能够被合理计算/存储。\n    边界条件:\n    f[0][0]= 1（代表不考虑任何数，凑出计算结果为 0 的方案数为 1 种\n    */</span>\n    <span>int</span> <span>findTargetSumWays</span><span>(</span>vector<span>&lt;</span><span>int</span><span>></span><span>&amp;</span> nums<span>,</span> <span>int</span> target<span>)</span> <span>{</span>\n        <span>int</span> n <span>=</span> nums<span>.</span><span>size</span><span>(</span><span>)</span><span>;</span>\n        <span>int</span> s <span>=</span> <span>0</span><span>;</span>  <span>//s为所有nums元素的总和</span>\n        <span>for</span><span>(</span><span>int</span> i <span>:</span> nums<span>)</span><span>{</span>\n            s <span>+=</span> <span>abs</span><span>(</span>i<span>)</span><span>;</span>\n        <span>}</span>\n        <span>if</span><span>(</span><span>abs</span><span>(</span>target<span>)</span> <span>></span> s<span>)</span>\n            <span>return</span> <span>0</span><span>;</span>\n        vector<span>&lt;</span>vector<span>&lt;</span><span>int</span><span>>></span> <span>f</span><span>(</span>n <span>+</span> <span>1</span><span>,</span> <span><span>vector</span><span><span>&lt;</span><span>int</span><span>></span></span></span><span>(</span><span>2</span> <span>*</span> s <span>+</span> <span>1</span><span>)</span><span>)</span><span>;</span>\n        f<span>[</span><span>0</span><span>]</span><span>[</span>s<span>]</span> <span>=</span> <span>1</span><span>;</span>    <span>//f[0][s] = 1</span>\n        <span>// 第一维为物品数量</span>\n        <span>for</span><span>(</span><span>int</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;=</span> n<span>;</span> i<span>++</span><span>)</span><span>{</span>\n            <span>int</span> x <span>=</span> nums<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>;</span>\n            <span>// 第二维为中间结果</span>\n            <span>// 中间结果的范围为[-s,s]</span>\n            <span>for</span><span>(</span><span>int</span> j <span>=</span> <span>-</span>s<span>;</span> j <span>&lt;=</span> s<span>;</span> j<span>++</span><span>)</span><span>{</span>\n                <span>if</span><span>(</span><span>(</span>j <span>-</span> x<span>)</span> <span>+</span> s <span>>=</span> <span>0</span><span>)</span><span>{</span>\n                    f<span>[</span>i<span>]</span><span>[</span>j <span>+</span> s<span>]</span> <span>+=</span> f<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>[</span><span>(</span>j <span>-</span> x<span>)</span> <span>+</span> s<span>]</span><span>;</span>\n                <span>}</span>\n                <span>if</span><span>(</span><span>(</span>j <span>+</span> x<span>)</span> <span>+</span> s <span>&lt;=</span> <span>2</span> <span>*</span> s<span>)</span><span>{</span>\n                    f<span>[</span>i<span>]</span><span>[</span>j <span>+</span> s<span>]</span> <span>+=</span> f<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>[</span><span>(</span>j <span>+</span> x<span>)</span> <span>+</span> s<span>]</span><span>;</span>\n                <span>}</span>\n            <span>}</span>\n        <span>}</span>\n        <span>return</span> f<span>[</span>n<span>]</span><span>[</span>target <span>+</span> s<span>]</span><span>;</span>\n    <span>}</span>\n<span>}</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br></div></div><p>:::</p>\n<p>::::</p>\n<h3 id=\"复杂度分析-2\"> 复杂度分析</h3>\n<ol>\n<li>时间复杂度：</li>\n<li>空间复杂度：</li>\n</ol>\n<h2 id=\"参考文献\"> 参考文献</h2>\n<p><a href=\"https://leetcode-cn.com/problems/target-sum/solution/gong-shui-san-xie-yi-ti-si-jie-dfs-ji-yi-et5b/\" target=\"_blank\" rel=\"noopener noreferrer\">【宫水三叶】一题四解 : 「DFS」&amp;「记忆化搜索」&amp;「全量 DP」&amp;「优化 DP」 - 目标和 - 力扣（LeetCode） (leetcode-cn.com)</a></p>\n<p><a href=\"https://leetcode-cn.com/problems/target-sum/solution/494-mu-biao-he-by-ming-zhi-shan-you-m9rfkvkdad/\" target=\"_blank\" rel=\"noopener noreferrer\">494. 目标和 - 目标和 - 力扣（LeetCode） (leetcode-cn.com)</a></p>\n<p><a href=\"https://leetcode-cn.com/problems/target-sum/solution/dong-tai-gui-hua-si-kao-quan-guo-cheng-by-keepal/\" target=\"_blank\" rel=\"noopener noreferrer\">动态规划思考全过程 - 目标和 - 力扣（LeetCode） (leetcode-cn.com)</a></p>\n",
      "image": "https://cdn.jsdelivr.net/gh/River-Cold/pictureBed/vuepress-blog/solution/leetcode/LeetCode-hot-topic-HOT-100/494.png",
      "date_published": "2022-04-04T14:19:55.000Z",
      "date_modified": "2022-04-04T14:19:55.000Z",
      "authors": [
        {
          "name": "RiverCold"
        }
      ],
      "tags": []
    },
    {
      "title": "621.任务调度器",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/solution/leetcode/LeetCode-hot-topic-HOT-100/621.%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%99%A8/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/solution/leetcode/LeetCode-hot-topic-HOT-100/621.%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%99%A8/",
      "content_html": "<h1 id=\"_621-任务调度器\"> 621.任务调度器</h1>\n<p>https://leetcode-cn.com/problems/task-scheduler/</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/River-Cold/pictureBed/vuepress-blog/docs/solution/leetcode/LeetCode-hot-topic-HOT-100/621.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"方法一-桶排序\"> 方法一：桶排序</h2>\n<h3 id=\"思路分析\"> 思路分析</h3>\n<div><p>提示</p>\n</div>\n<h3 id=\"参考代码\"> 参考代码</h3>\n<CodeGroup>\n<CodeGroupItem title=\"c++\">\n<div><pre><code><span>class</span> <span>Solution</span> <span>{</span>\n<span>public</span><span>:</span>\n    <span>int</span> <span>leastInterval</span><span>(</span>vector<span>&lt;</span><span>char</span><span>></span><span>&amp;</span> tasks<span>,</span> <span>int</span> n<span>)</span> <span>{</span>\n        <span>int</span> len <span>=</span> tasks<span>.</span><span>size</span><span>(</span><span>)</span><span>;</span>\n        vector<span>&lt;</span><span>int</span><span>></span> <span>vec</span><span>(</span><span>26</span><span>)</span><span>;</span>\n        <span>for</span><span>(</span><span>char</span> ch <span>:</span> tasks<span>)</span><span>{</span>\n            <span>++</span>vec<span>[</span>ch <span>-</span> <span>'A'</span><span>]</span><span>;</span>\n        <span>}</span>\n        <span>sort</span><span>(</span>vec<span>.</span><span>begin</span><span>(</span><span>)</span><span>,</span> vec<span>.</span><span>end</span><span>(</span><span>)</span><span>,</span> <span><span>greater</span><span><span>&lt;</span><span>int</span><span>></span></span></span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>int</span> cnt <span>=</span> <span>1</span><span>;</span>\n        <span>// 统计任务数量并列最多的任务有多少个，即最后一个桶的任务数X</span>\n        <span>while</span><span>(</span>cnt <span>&lt;</span> vec<span>.</span><span>size</span><span>(</span><span>)</span> <span>&amp;&amp;</span> vec<span>[</span>cnt<span>]</span> <span>==</span> vec<span>[</span><span>0</span><span>]</span><span>)</span><span>{</span>\n            cnt<span>++</span><span>;</span>\n        <span>}</span>\n        <span>return</span> <span>max</span><span>(</span>len<span>,</span> cnt <span>+</span> <span>(</span>n <span>+</span> <span>1</span><span>)</span> <span>*</span> <span>(</span>vec<span>[</span><span>0</span><span>]</span> <span>-</span> <span>1</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div></CodeGroupItem>\n</CodeGroup>\n<h2 id=\"方法二-优先队列\"> 方法二：优先队列</h2>\n<div><p>提示</p>\n<p><strong>选择不在冷却中并且剩余执行次数最多的任务优先执行</strong>。</p>\n<ul>\n<li>每执行完一个任务，将剩下的所有任务按照执行时间升序排列，剩余执行次数降序排列。使用一个优先队列来维护所有任务的优先级。</li>\n<li>取出队首任务，判断当前任务的执行时间是否小于当前时间\n<ul>\n<li>小于则判断剩余执行次数是否大于1\n<ul>\n<li>大于则剩余执行次数-1，计算出下一次执行时间，将新的任务加入队列</li>\n</ul>\n</li>\n<li>否则当前时间+1</li>\n</ul>\n</li>\n</ul>\n<p><strong>下一次执行时间</strong>：两个相同任务之间必须有 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.4306em;\"></span><span>n</span></span></span></span> 的冷却，因此每个任务执行完成之后需要等到 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span>n</span><span style=\"margin-right:0.2222em;\"></span><span>+</span><span style=\"margin-right:0.2222em;\"></span></span><span><span style=\"height:0.6444em;\"></span><span>1</span></span></span></span> 个时间单位之后才能执行，即 <code>task.nextTime = task.nextTime + n + 1</code></p>\n<p><strong>剩余执行次数</strong>：如果大于1则等于当前执行次数-1，即<code>task.restTaskNum=task.restTaskNum-1</code></p>\n</div>\n<div><pre><code><span>class</span> <span>Solution</span> <span>{</span>\n<span>public</span><span>:</span> \n    <span>class</span> <span>Task</span><span>{</span>\n        <span>public</span><span>:</span>\n            <span>int</span> nextTime<span>;</span>\n            <span>int</span> restTaskNum<span>;</span>\n            <span>Task</span><span>(</span><span>int</span> nextTime<span>,</span> <span>int</span> restTaskNum<span>)</span><span>{</span>\n                <span>this</span><span>-></span>nextTime <span>=</span> nextTime<span>;</span>\n                <span>this</span><span>-></span>restTaskNum <span>=</span> restTaskNum<span>;</span>\n            <span>}</span>\n            <span>friend</span> <span>bool</span> <span>operator</span> <span>&lt;</span> <span>(</span>Task t1<span>,</span> Task t2<span>)</span><span>{</span>\n                <span>// 按照下一次执行时间升序，任务数降序</span>\n                <span>if</span><span>(</span>t1<span>.</span>nextTime <span>==</span> t2<span>.</span>nextTime<span>)</span><span>{</span>\n                    <span>return</span> t1<span>.</span>restTaskNum <span>&lt;</span> t2<span>.</span>restTaskNum<span>;</span>\n                <span>}</span>\n                <span>return</span> t1<span>.</span>nextTime <span>></span> t2<span>.</span>nextTime<span>;</span>\n            <span>}</span>\n    <span>}</span><span>;</span>\n\n    <span>int</span> <span>leastInterval</span><span>(</span>vector<span>&lt;</span><span>char</span><span>></span><span>&amp;</span> tasks<span>,</span> <span>int</span> n<span>)</span> <span>{</span>\n        vector<span>&lt;</span><span>int</span><span>></span> <span>TaskNum</span><span>(</span><span>26</span><span>,</span> <span>0</span><span>)</span><span>;</span>\n        <span>for</span><span>(</span><span>char</span> ch <span>:</span> tasks<span>)</span><span>{</span>\n            <span>++</span>TaskNum<span>[</span>ch <span>-</span> <span>'A'</span><span>]</span><span>;</span>\n        <span>}</span>    \n        <span>// 定义优先队列</span>\n        priority_queue<span>&lt;</span>Task<span>,</span> vector<span>&lt;</span>Task<span>>></span> pq<span>;</span>\n        <span>// 初始化优先队列</span>\n        <span>for</span><span>(</span><span>int</span> tasknum <span>:</span> TaskNum<span>)</span><span>{</span>\n            <span>if</span><span>(</span>tasknum <span>==</span> <span>0</span><span>)</span>\n                <span>continue</span><span>;</span>\n            Task <span>newTask</span><span>(</span><span>0</span><span>,</span> tasknum<span>)</span><span>;</span>\n            pq<span>.</span><span>push</span><span>(</span>newTask<span>)</span><span>;</span>\n        <span>}</span>\n        <span>// 计算任务调度</span>\n        <span>int</span> time <span>=</span> <span>0</span><span>;</span>\n        <span>while</span><span>(</span><span>!</span>pq<span>.</span><span>empty</span><span>(</span><span>)</span><span>)</span><span>{</span>\n            <span>auto</span> top <span>=</span> pq<span>.</span><span>top</span><span>(</span><span>)</span><span>;</span>\n            <span>if</span><span>(</span>top<span>.</span>nextTime <span>&lt;=</span> time<span>)</span><span>{</span>\n                pq<span>.</span><span>pop</span><span>(</span><span>)</span><span>;</span>\n                <span>if</span><span>(</span>top<span>.</span>restTaskNum <span>></span> <span>1</span><span>)</span><span>{</span>\n                    top<span>.</span>restTaskNum<span>--</span><span>;</span>\n                    top<span>.</span>nextTime <span>=</span> top<span>.</span>nextTime <span>+</span> n <span>+</span> <span>1</span><span>;</span>\n                    pq<span>.</span><span>push</span><span>(</span>top<span>)</span><span>;</span>\n                <span>}</span>\n            <span>}</span>\n            time<span>++</span><span>;</span>\n        <span>}</span>\n\n        <span>return</span> time<span>;</span>\n    <span>}</span>\n<span>}</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br></div></div><p>:::</p>\n<p>::::</p>\n<h2 id=\"参考文献\"> 参考文献</h2>\n<p><a href=\"https://leetcode-cn.com/problems/task-scheduler/solution/tong-zi-by-popopop/\" target=\"_blank\" rel=\"noopener noreferrer\">【任务调度器】C++ 桶子_配图理解 - 任务调度器 - 力扣（LeetCode） (leetcode-cn.com)</a></p>\n<p><a href=\"https://leetcode-cn.com/problems/task-scheduler/solution/python-xiang-jie-by-jalan/\" target=\"_blank\" rel=\"noopener noreferrer\">Python 详解 - 任务调度器 - 力扣（LeetCode） (leetcode-cn.com)</a></p>\n<p><a href=\"https://leetcode-cn.com/problems/task-scheduler/solution/by-sixiermu-ahl4/\" target=\"_blank\" rel=\"noopener noreferrer\">最小堆、小顶堆：剩余次数和冷却时间 24ms 超官方一 - 任务调度器 - 力扣（LeetCode） (leetcode-cn.com)</a></p>\n",
      "image": "https://cdn.jsdelivr.net/gh/River-Cold/pictureBed/vuepress-blog/docs/solution/leetcode/LeetCode-hot-topic-HOT-100/621.png",
      "date_published": "2022-04-04T14:19:55.000Z",
      "date_modified": "2022-04-04T14:19:55.000Z",
      "authors": [
        {
          "name": "RiverCold"
        }
      ],
      "tags": []
    },
    {
      "title": "64.最小路径和",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/solution/leetcode/LeetCode-hot-topic-HOT-100/64.%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/solution/leetcode/LeetCode-hot-topic-HOT-100/64.%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/",
      "content_html": "<h1 id=\"_64-最小路径和\"> 64.最小路径和</h1>\n<p>https://leetcode-cn.com/problems/minimum-path-sum/</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/River-Cold/pictureBed/vuepress-blog/solution/leetcode/LeetCode-hot-topic-HOT-100/64.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"方法一-动态规划\"> 方法一：动态规划</h2>\n<h3 id=\"思路分析\"> 思路分析</h3>\n<div><p>提示</p>\n<p>状态定义：<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>d</span><span>p</span><span>[</span><span>i</span><span>]</span><span>[</span><span style=\"margin-right:0.05724em;\">j</span><span>]</span></span></span></span>表示从左上角出发到 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>(</span><span>i</span><span>,</span><span style=\"margin-right:0.1667em;\"></span><span style=\"margin-right:0.05724em;\">j</span><span>)</span></span></span></span> 位置的最小路径和</p>\n<p>状态转移方程：</p>\n<p>当<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.6986em;vertical-align:-0.0391em;\"></span><span>i</span><span style=\"margin-right:0.2778em;\"></span><span>&gt;</span><span style=\"margin-right:0.2778em;\"></span></span><span><span style=\"height:0.6444em;\"></span><span>0</span></span></span></span>且<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.854em;vertical-align:-0.1944em;\"></span><span style=\"margin-right:0.05724em;\">j</span><span style=\"margin-right:0.2778em;\"></span><span>=</span><span style=\"margin-right:0.2778em;\"></span></span><span><span style=\"height:0.6444em;\"></span><span>0</span></span></span></span>时，<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>d</span><span>p</span><span>[</span><span>i</span><span>]</span><span>[</span><span>0</span><span>]</span><span style=\"margin-right:0.2778em;\"></span><span>=</span><span style=\"margin-right:0.2778em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>d</span><span>p</span><span>[</span><span>i</span><span style=\"margin-right:0.2222em;\"></span><span>−</span><span style=\"margin-right:0.2222em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>1</span><span>]</span><span>[</span><span>0</span><span>]</span><span style=\"margin-right:0.2222em;\"></span><span>+</span><span style=\"margin-right:0.2222em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span style=\"margin-right:0.03588em;\">g</span><span style=\"margin-right:0.02778em;\">r</span><span>i</span><span>d</span><span>[</span><span>i</span><span>]</span><span>[</span><span>0</span><span>]</span></span></span></span></p>\n<p>当<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.6595em;\"></span><span>i</span><span style=\"margin-right:0.2778em;\"></span><span>=</span><span style=\"margin-right:0.2778em;\"></span></span><span><span style=\"height:0.6444em;\"></span><span>0</span></span></span></span>且<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.854em;vertical-align:-0.1944em;\"></span><span style=\"margin-right:0.05724em;\">j</span><span style=\"margin-right:0.2778em;\"></span><span>&gt;</span><span style=\"margin-right:0.2778em;\"></span></span><span><span style=\"height:0.6444em;\"></span><span>0</span></span></span></span>时，<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>d</span><span>p</span><span>[</span><span>0</span><span>]</span><span>[</span><span style=\"margin-right:0.05724em;\">j</span><span>]</span><span style=\"margin-right:0.2778em;\"></span><span>=</span><span style=\"margin-right:0.2778em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>d</span><span>p</span><span>[</span><span>0</span><span>]</span><span>[</span><span style=\"margin-right:0.05724em;\">j</span><span style=\"margin-right:0.2222em;\"></span><span>−</span><span style=\"margin-right:0.2222em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>1</span><span>]</span><span style=\"margin-right:0.2222em;\"></span><span>+</span><span style=\"margin-right:0.2222em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span style=\"margin-right:0.03588em;\">g</span><span style=\"margin-right:0.02778em;\">r</span><span>i</span><span>d</span><span>[</span><span>0</span><span>]</span><span>[</span><span style=\"margin-right:0.05724em;\">j</span><span>]</span></span></span></span></p>\n<p>当<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.6986em;vertical-align:-0.0391em;\"></span><span>i</span><span style=\"margin-right:0.2778em;\"></span><span>&gt;</span><span style=\"margin-right:0.2778em;\"></span></span><span><span style=\"height:0.6444em;\"></span><span>0</span></span></span></span>且<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.854em;vertical-align:-0.1944em;\"></span><span style=\"margin-right:0.05724em;\">j</span><span style=\"margin-right:0.2778em;\"></span><span>&gt;</span><span style=\"margin-right:0.2778em;\"></span></span><span><span style=\"height:0.6444em;\"></span><span>0</span></span></span></span>时，<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>d</span><span>p</span><span>[</span><span>i</span><span>]</span><span>[</span><span style=\"margin-right:0.05724em;\">j</span><span>]</span><span style=\"margin-right:0.2778em;\"></span><span>=</span><span style=\"margin-right:0.2778em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>min</span><span>(</span><span>d</span><span>p</span><span>[</span><span>i</span><span style=\"margin-right:0.2222em;\"></span><span>−</span><span style=\"margin-right:0.2222em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>1</span><span>]</span><span>[</span><span style=\"margin-right:0.05724em;\">j</span><span>]</span><span>,</span><span style=\"margin-right:0.1667em;\"></span><span>d</span><span>p</span><span>[</span><span>i</span><span>]</span><span>[</span><span style=\"margin-right:0.05724em;\">j</span><span style=\"margin-right:0.2222em;\"></span><span>−</span><span style=\"margin-right:0.2222em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>1</span><span>])</span><span style=\"margin-right:0.2222em;\"></span><span>+</span><span style=\"margin-right:0.2222em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span style=\"margin-right:0.03588em;\">g</span><span style=\"margin-right:0.02778em;\">r</span><span>i</span><span>d</span><span>[</span><span>i</span><span>]</span><span>[</span><span style=\"margin-right:0.05724em;\">j</span><span>]</span></span></span></span></p>\n<p>状态边界</p>\n<p><span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>d</span><span>p</span><span>[</span><span>0</span><span>]</span><span>[</span><span>0</span><span>]</span><span style=\"margin-right:0.2778em;\"></span><span>=</span><span style=\"margin-right:0.2778em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span style=\"margin-right:0.03588em;\">g</span><span style=\"margin-right:0.02778em;\">r</span><span>i</span><span>d</span><span>[</span><span>0</span><span>]</span><span>[</span><span>0</span><span>]</span></span></span></span></p>\n</div>\n<h3 id=\"参考代码\"> 参考代码</h3>\n<CodeGroup>\n<CodeGroupItem title=\"c++\">\n<div><pre><code><span>/*\n第一行和第一列的值在循环外提前初始化\n*/</span>\n<span>class</span> <span>Solution</span> <span>{</span>\n<span>public</span><span>:</span>\n    <span>int</span> <span>minPathSum</span><span>(</span>vector<span>&lt;</span>vector<span>&lt;</span><span>int</span><span>>></span><span>&amp;</span> grid<span>)</span> <span>{</span>\n        <span>int</span> m <span>=</span> grid<span>.</span><span>size</span><span>(</span><span>)</span><span>,</span> n <span>=</span> grid<span>[</span><span>0</span><span>]</span><span>.</span><span>size</span><span>(</span><span>)</span><span>;</span>\n        vector<span>&lt;</span>vector<span>&lt;</span><span>int</span><span>>></span> <span>dp</span><span>(</span>m<span>,</span> <span><span>vector</span><span><span>&lt;</span><span>int</span><span>></span></span></span><span>(</span>n<span>)</span><span>)</span><span>;</span>\n        <span>// 初始化边界值</span>\n        dp<span>[</span><span>0</span><span>]</span><span>[</span><span>0</span><span>]</span> <span>=</span> grid<span>[</span><span>0</span><span>]</span><span>[</span><span>0</span><span>]</span><span>;</span>\n        <span>// 第一列的值</span>\n        <span>for</span><span>(</span><span>int</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;</span> m<span>;</span> i<span>++</span><span>)</span><span>{</span>\n            dp<span>[</span>i<span>]</span><span>[</span><span>0</span><span>]</span> <span>=</span> dp<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>[</span><span>0</span><span>]</span> <span>+</span> grid<span>[</span>i<span>]</span><span>[</span><span>0</span><span>]</span><span>;</span>\n        <span>}</span>\n        <span>// 第一行的值</span>\n        <span>for</span><span>(</span><span>int</span> j <span>=</span> <span>1</span><span>;</span> j <span>&lt;</span> n<span>;</span> j<span>++</span><span>)</span><span>{</span>\n            dp<span>[</span><span>0</span><span>]</span><span>[</span>j<span>]</span> <span>=</span> grid<span>[</span><span>0</span><span>]</span><span>[</span>j<span>]</span> <span>+</span> dp<span>[</span><span>0</span><span>]</span><span>[</span>j <span>-</span> <span>1</span><span>]</span><span>;</span>\n        <span>}</span>\n\n        <span>for</span><span>(</span><span>int</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;</span> m<span>;</span> i<span>++</span><span>)</span><span>{</span>\n            <span>for</span><span>(</span><span>int</span> j <span>=</span> <span>1</span><span>;</span> j <span>&lt;</span> n<span>;</span> j<span>++</span><span>)</span><span>{</span>\n                dp<span>[</span>i<span>]</span><span>[</span>j<span>]</span> <span>=</span> <span>min</span><span>(</span>dp<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>[</span>j<span>]</span><span>,</span> dp<span>[</span>i<span>]</span><span>[</span>j <span>-</span> <span>1</span><span>]</span><span>)</span> <span>+</span> grid<span>[</span>i<span>]</span><span>[</span>j<span>]</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n\n        <span>return</span> dp<span>[</span>m <span>-</span> <span>1</span><span>]</span><span>[</span>n <span>-</span> <span>1</span><span>]</span><span>;</span>\n    <span>}</span>\n<span>}</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div></CodeGroupItem>\n<CodeGroupItem title=\"c++\" active>\n<div><pre><code><span>/*\n第一行和第一列的值在循环的同时进行初始化\n*/</span>\n<span>class</span> <span>Solution</span> <span>{</span>\n<span>public</span><span>:</span>\n    <span>int</span> <span>minPathSum</span><span>(</span>vector<span>&lt;</span>vector<span>&lt;</span><span>int</span><span>>></span><span>&amp;</span> grid<span>)</span> <span>{</span>\n        <span>int</span> m <span>=</span> grid<span>.</span><span>size</span><span>(</span><span>)</span><span>,</span> n <span>=</span> grid<span>[</span><span>0</span><span>]</span><span>.</span><span>size</span><span>(</span><span>)</span><span>;</span>\n        vector<span>&lt;</span>vector<span>&lt;</span><span>int</span><span>>></span> <span>dp</span><span>(</span>m<span>,</span> <span><span>vector</span><span><span>&lt;</span><span>int</span><span>></span></span></span><span>(</span>n<span>)</span><span>)</span><span>;</span>\n        <span>for</span><span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> m<span>;</span> i<span>++</span><span>)</span><span>{</span>\n            <span>for</span><span>(</span><span>int</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> n<span>;</span> j<span>++</span><span>)</span><span>{</span>\n                <span>if</span><span>(</span>i <span>==</span> <span>0</span><span>)</span><span>{</span>\n                    <span>if</span><span>(</span>j <span>>=</span> <span>1</span><span>)</span><span>{</span>\n                        dp<span>[</span>i<span>]</span><span>[</span>j<span>]</span> <span>=</span> dp<span>[</span>i<span>]</span><span>[</span>j<span>-</span><span>1</span><span>]</span> <span>+</span> grid<span>[</span>i<span>]</span><span>[</span>j<span>]</span><span>;</span>\n                    <span>}</span><span>else</span><span>{</span>\n                        dp<span>[</span><span>0</span><span>]</span><span>[</span><span>0</span><span>]</span> <span>=</span> grid<span>[</span><span>0</span><span>]</span><span>[</span><span>0</span><span>]</span><span>;</span>\n                    <span>}</span>\n                <span>}</span><span>else</span><span>{</span>\n                    <span>if</span><span>(</span>j <span>>=</span> <span>1</span><span>)</span><span>{</span>\n                        dp<span>[</span>i<span>]</span><span>[</span>j<span>]</span> <span>=</span> <span>min</span><span>(</span>dp<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>[</span>j<span>]</span><span>,</span> dp<span>[</span>i<span>]</span><span>[</span>j <span>-</span> <span>1</span><span>]</span><span>)</span> <span>+</span> grid<span>[</span>i<span>]</span><span>[</span>j<span>]</span><span>;</span>\n                    <span>}</span><span>else</span><span>{</span>\n                        dp<span>[</span>i<span>]</span><span>[</span>j<span>]</span> <span>=</span> dp<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>[</span>j<span>]</span> <span>+</span> grid<span>[</span>i<span>]</span><span>[</span>j<span>]</span><span>;</span>\n                    <span>}</span>\n                <span>}</span>\n            <span>}</span>\n        <span>}</span>\n        <span>return</span> dp<span>[</span>m <span>-</span> <span>1</span><span>]</span><span>[</span>n <span>-</span> <span>1</span><span>]</span><span>;</span>\n    <span>}</span>\n<span>}</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div></CodeGroupItem>\n</CodeGroup>\n<h2 id=\"方法二-滚动数组\"> 方法二：滚动数组</h2>\n<h3 id=\"思路分析-2\"> 思路分析</h3>\n<div><p>提示</p>\n<p><strong>状态定义</strong>：<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>d</span><span>p</span><span>[</span><span>i</span><span>]</span><span>[</span><span style=\"margin-right:0.05724em;\">j</span><span>]</span></span></span></span>表示从左上角出发到 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>(</span><span>i</span><span>,</span><span style=\"margin-right:0.1667em;\"></span><span style=\"margin-right:0.05724em;\">j</span><span>)</span></span></span></span> 位置的最小路径和</p>\n<p>由状态转移方程</p>\n<p class='katex-block'><span><span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>d</span><span>p</span><span>[</span><span>i</span><span>]</span><span>[</span><span style=\"margin-right:0.05724em;\">j</span><span>]</span><span style=\"margin-right:0.2778em;\"></span><span>=</span><span style=\"margin-right:0.2778em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>min</span><span>(</span><span>d</span><span>p</span><span>[</span><span>i</span><span style=\"margin-right:0.2222em;\"></span><span>−</span><span style=\"margin-right:0.2222em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>1</span><span>]</span><span>[</span><span style=\"margin-right:0.05724em;\">j</span><span>]</span><span>,</span><span style=\"margin-right:0.1667em;\"></span><span>d</span><span>p</span><span>[</span><span>i</span><span>]</span><span>[</span><span style=\"margin-right:0.05724em;\">j</span><span style=\"margin-right:0.2222em;\"></span><span>−</span><span style=\"margin-right:0.2222em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>1</span><span>])</span><span style=\"margin-right:0.2222em;\"></span><span>+</span><span style=\"margin-right:0.2222em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span style=\"margin-right:0.03588em;\">g</span><span style=\"margin-right:0.02778em;\">r</span><span>i</span><span>d</span><span>[</span><span>i</span><span>]</span><span>[</span><span style=\"margin-right:0.05724em;\">j</span><span>]</span></span></span></span></span></p>\n<p>可知<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>d</span><span>p</span><span>[</span><span>i</span><span>]</span><span>[</span><span style=\"margin-right:0.05724em;\">j</span><span>]</span></span></span></span>只会从<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>d</span><span>p</span><span>[</span><span>i</span><span style=\"margin-right:0.2222em;\"></span><span>−</span><span style=\"margin-right:0.2222em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>1</span><span>]</span><span>[</span><span style=\"margin-right:0.05724em;\">j</span><span>]</span></span></span></span>（上方行的数据）或者<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>d</span><span>p</span><span>[</span><span>i</span><span>]</span><span>[</span><span style=\"margin-right:0.05724em;\">j</span><span style=\"margin-right:0.2222em;\"></span><span>−</span><span style=\"margin-right:0.2222em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>1</span><span>]</span></span></span></span>（左侧列的数据）转移得到，在循环的过程中只会使用到之前已经计算好的值，因此可以使用滚动数组进行优化，将<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>d</span><span>p</span><span>[</span><span>i</span><span>]</span><span>[</span><span style=\"margin-right:0.05724em;\">j</span><span>]</span></span></span></span>中的行<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.6595em;\"></span><span>i</span></span></span></span>去掉，使用<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>d</span><span>p</span><span>[</span><span style=\"margin-right:0.05724em;\">j</span><span>]</span></span></span></span>替代。得到新的<strong>状态转移方程</strong>如下：</p>\n<p>当<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.6986em;vertical-align:-0.0391em;\"></span><span>i</span><span style=\"margin-right:0.2778em;\"></span><span>&gt;</span><span style=\"margin-right:0.2778em;\"></span></span><span><span style=\"height:0.6444em;\"></span><span>0</span></span></span></span>且<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.854em;vertical-align:-0.1944em;\"></span><span style=\"margin-right:0.05724em;\">j</span><span style=\"margin-right:0.2778em;\"></span><span>=</span><span style=\"margin-right:0.2778em;\"></span></span><span><span style=\"height:0.6444em;\"></span><span>0</span></span></span></span>时，<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>d</span><span>p</span><span>[</span><span style=\"margin-right:0.05724em;\">j</span><span>]</span><span style=\"margin-right:0.2778em;\"></span><span>=</span><span style=\"margin-right:0.2778em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>d</span><span>p</span><span>[</span><span style=\"margin-right:0.05724em;\">j</span><span>]</span><span style=\"margin-right:0.2222em;\"></span><span>+</span><span style=\"margin-right:0.2222em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span style=\"margin-right:0.03588em;\">g</span><span style=\"margin-right:0.02778em;\">r</span><span>i</span><span>d</span><span>[</span><span>i</span><span>]</span><span>[</span><span style=\"margin-right:0.05724em;\">j</span><span>]</span></span></span></span></p>\n<p>当<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.6595em;\"></span><span>i</span><span style=\"margin-right:0.2778em;\"></span><span>=</span><span style=\"margin-right:0.2778em;\"></span></span><span><span style=\"height:0.6444em;\"></span><span>0</span></span></span></span>且<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.854em;vertical-align:-0.1944em;\"></span><span style=\"margin-right:0.05724em;\">j</span><span style=\"margin-right:0.2778em;\"></span><span>&gt;</span><span style=\"margin-right:0.2778em;\"></span></span><span><span style=\"height:0.6444em;\"></span><span>0</span></span></span></span>时，<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>d</span><span>p</span><span>[</span><span style=\"margin-right:0.05724em;\">j</span><span>]</span><span style=\"margin-right:0.2778em;\"></span><span>=</span><span style=\"margin-right:0.2778em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>d</span><span>p</span><span>[</span><span style=\"margin-right:0.05724em;\">j</span><span style=\"margin-right:0.2222em;\"></span><span>−</span><span style=\"margin-right:0.2222em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>1</span><span>]</span><span style=\"margin-right:0.2222em;\"></span><span>+</span><span style=\"margin-right:0.2222em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span style=\"margin-right:0.03588em;\">g</span><span style=\"margin-right:0.02778em;\">r</span><span>i</span><span>d</span><span>[</span><span>i</span><span>]</span><span>[</span><span style=\"margin-right:0.05724em;\">j</span><span>]</span></span></span></span></p>\n<p>当<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.6986em;vertical-align:-0.0391em;\"></span><span>i</span><span style=\"margin-right:0.2778em;\"></span><span>&gt;</span><span style=\"margin-right:0.2778em;\"></span></span><span><span style=\"height:0.6444em;\"></span><span>0</span></span></span></span>且<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.854em;vertical-align:-0.1944em;\"></span><span style=\"margin-right:0.05724em;\">j</span><span style=\"margin-right:0.2778em;\"></span><span>&gt;</span><span style=\"margin-right:0.2778em;\"></span></span><span><span style=\"height:0.6444em;\"></span><span>0</span></span></span></span>时，<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>d</span><span>p</span><span>[</span><span style=\"margin-right:0.05724em;\">j</span><span>]</span><span style=\"margin-right:0.2778em;\"></span><span>=</span><span style=\"margin-right:0.2778em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>min</span><span>(</span><span>d</span><span>p</span><span>[</span><span style=\"margin-right:0.05724em;\">j</span><span>]</span><span>,</span><span style=\"margin-right:0.1667em;\"></span><span>d</span><span>p</span><span>[</span><span style=\"margin-right:0.05724em;\">j</span><span style=\"margin-right:0.2222em;\"></span><span>−</span><span style=\"margin-right:0.2222em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>1</span><span>])</span><span style=\"margin-right:0.2222em;\"></span><span>+</span><span style=\"margin-right:0.2222em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span style=\"margin-right:0.03588em;\">g</span><span style=\"margin-right:0.02778em;\">r</span><span>i</span><span>d</span><span>[</span><span>i</span><span>]</span><span>[</span><span style=\"margin-right:0.05724em;\">j</span><span>]</span></span></span></span></p>\n<p><strong>状态边界</strong></p>\n<p><span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>d</span><span>p</span><span>[</span><span>0</span><span>]</span><span style=\"margin-right:0.2778em;\"></span><span>=</span><span style=\"margin-right:0.2778em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span style=\"margin-right:0.03588em;\">g</span><span style=\"margin-right:0.02778em;\">r</span><span>i</span><span>d</span><span>[</span><span>0</span><span>]</span><span>[</span><span>0</span><span>]</span></span></span></span></p>\n</div>\n<h3 id=\"参考代码-2\"> 参考代码</h3>\n<CodeGroup>\n<CodeGroupItem title=\"c++\">\n<div><pre><code><span>class</span> <span>Solution</span> <span>{</span>\n<span>public</span><span>:</span>\n    <span>int</span> <span>minPathSum</span><span>(</span>vector<span>&lt;</span>vector<span>&lt;</span><span>int</span><span>>></span><span>&amp;</span> grid<span>)</span> <span>{</span>\n        <span>int</span> m <span>=</span> grid<span>.</span><span>size</span><span>(</span><span>)</span><span>,</span> n <span>=</span> grid<span>[</span><span>0</span><span>]</span><span>.</span><span>size</span><span>(</span><span>)</span><span>;</span>\n        vector<span>&lt;</span><span>int</span><span>></span> <span>dp</span><span>(</span>n<span>)</span><span>;</span>\n        <span>for</span><span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> m<span>;</span> i<span>++</span><span>)</span><span>{</span>\n            <span>for</span><span>(</span><span>int</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> n<span>;</span> j<span>++</span><span>)</span><span>{</span>\n                <span>if</span><span>(</span>i <span>==</span> <span>0</span><span>)</span><span>{</span>\n                    <span>if</span><span>(</span>j <span>>=</span> <span>1</span><span>)</span><span>{</span>\n                        dp<span>[</span>j<span>]</span> <span>=</span> dp<span>[</span>j <span>-</span> <span>1</span><span>]</span> <span>+</span> grid<span>[</span>i<span>]</span><span>[</span>j<span>]</span><span>;</span> \n                    <span>}</span><span>else</span><span>{</span>\n                        dp<span>[</span>j<span>]</span> <span>=</span> grid<span>[</span>i<span>]</span><span>[</span>j<span>]</span><span>;</span>             \n                    <span>}</span>\n                <span>}</span><span>else</span><span>{</span>\n                    <span>if</span><span>(</span>j <span>>=</span> <span>1</span><span>)</span><span>{</span>\n                        dp<span>[</span>j<span>]</span> <span>=</span> <span>min</span><span>(</span>dp<span>[</span>j<span>]</span><span>,</span> dp<span>[</span>j <span>-</span> <span>1</span><span>]</span><span>)</span> <span>+</span> grid<span>[</span>i<span>]</span><span>[</span>j<span>]</span><span>;</span>\n                    <span>}</span><span>else</span><span>{</span>\n                        dp<span>[</span>j<span>]</span> <span>=</span> dp<span>[</span>j<span>]</span> <span>+</span> grid<span>[</span>i<span>]</span><span>[</span>j<span>]</span><span>;</span>\n                    <span>}</span>\n                <span>}</span>\n            <span>}</span>\n        <span>}</span>\n        <span>return</span> dp<span>[</span>n <span>-</span> <span>1</span><span>]</span><span>;</span>\n    <span>}</span>\n<span>}</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div></CodeGroupItem>\n</CodeGroup>\n",
      "image": "https://cdn.jsdelivr.net/gh/River-Cold/pictureBed/vuepress-blog/solution/leetcode/LeetCode-hot-topic-HOT-100/64.png",
      "date_published": "2022-04-04T14:19:55.000Z",
      "date_modified": "2022-04-04T14:19:55.000Z",
      "authors": [
        {
          "name": "RiverCold"
        }
      ],
      "tags": []
    },
    {
      "title": "647.回文子串",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/solution/leetcode/LeetCode-hot-topic-HOT-100/647.%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/solution/leetcode/LeetCode-hot-topic-HOT-100/647.%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/",
      "content_html": "<h1 id=\"_647-回文子串\"> 647.回文子串</h1>\n<p>https://leetcode-cn.com/problems/palindromic-substrings/</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/River-Cold/pictureBed/vuepress-blog/solution/leetcode/LeetCode-hot-topic-HOT-100/647.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"方法一-中心扩散\"> 方法一：中心扩散</h2>\n<h3 id=\"思路分析\"> 思路分析</h3>\n<div><p>提示</p>\n<p>考虑回文长度是奇数和回文长度是偶数的两种情况。如果回文长度是奇数，那么回文中心是一个字符；如果回文长度是偶数，那么中心是两个字符。</p>\n<p>所以可以枚举所有的回文中心，然后从中心向两边扩散，当寻找完所有的回文中心之后，问题就会解决。</p>\n<p>假设字符串<code>s</code>长度为<code>len</code>，则回文中心一共有<code>2*len-1</code>个，包括<code>len</code>个单字符和<code>len-1</code>个双字符。</p>\n</div>\n<h3 id=\"参考代码\"> 参考代码</h3>\n<CodeGroup>\n<CodeGroupItem title=\"c++\">\n<div><pre><code><span>class</span> <span>Solution</span> <span>{</span>\n<span>public</span><span>:</span>\n    <span>int</span> <span>countSubstrings</span><span>(</span>string s<span>)</span> <span>{</span>\n        <span>// 中心扩展法</span>\n        <span>int</span> n <span>=</span> s<span>.</span><span>length</span><span>(</span><span>)</span><span>;</span>\n        <span>int</span> ans <span>=</span> <span>0</span><span>;</span>\n        <span>for</span><span>(</span><span>int</span> center <span>=</span> <span>0</span><span>;</span> center <span>&lt;</span> n<span>;</span> center<span>++</span><span>)</span><span>{</span>\n            <span>// 一个字符作中心</span>\n            <span>int</span> left <span>=</span> center<span>,</span> right <span>=</span> center<span>;</span>\n            <span>while</span><span>(</span>left <span>>=</span> <span>0</span> <span>&amp;&amp;</span> right <span>&lt;</span> n <span>&amp;&amp;</span> s<span>[</span>left<span>]</span> <span>==</span> s<span>[</span>right<span>]</span><span>)</span><span>{</span>\n                left<span>--</span><span>;</span>\n                right<span>++</span><span>;</span>\n                ans<span>++</span><span>;</span>\n            <span>}</span>\n            <span>// 两个字符作中心</span>\n            left <span>=</span> center<span>,</span> right <span>=</span> center <span>+</span> <span>1</span><span>;</span>\n            <span>while</span><span>(</span>left <span>>=</span> <span>0</span> <span>&amp;&amp;</span> right <span>&lt;</span> n <span>&amp;&amp;</span> s<span>[</span>left<span>]</span> <span>==</span> s<span>[</span>right<span>]</span><span>)</span><span>{</span>\n                left<span>--</span><span>;</span>\n                right<span>++</span><span>;</span>\n                ans<span>++</span><span>;</span>\n            <span>}</span>    \n        <span>}</span>\n        <span>return</span> ans<span>;</span>\n    <span>}</span>\n<span>}</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div></CodeGroupItem>\n</CodeGroup>\n<h2 id=\"方法二-动态规划\"> 方法二：动态规划</h2>\n<div><p>提示</p>\n<p><strong>状态定义</strong>：</p>\n<p>设<code>dp[i][j]</code>表示字符串<code>s</code>在<code>[i,j]</code>区间的子串是否是一个回文串</p>\n<p><strong>状态转移方程</strong>：</p>\n<p class='katex-block'><span><span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>d</span><span>p</span><span>[</span><span>i</span><span>]</span><span>[</span><span style=\"margin-right:0.05724em;\">j</span><span>]</span><span style=\"margin-right:0.2778em;\"></span><span>=</span><span style=\"margin-right:0.2778em;\"></span></span><span><span style=\"height:3em;vertical-align:-1.25em;\"></span><span><span style=\"top:0em;\"><span>{</span></span><span><span><span><span><span><span style=\"height:1.69em;\"><span style=\"top:-3.69em;\"><span style=\"height:3.008em;\"></span><span><span>(</span><span>s</span><span>[</span><span>i</span><span>]</span><span style=\"margin-right:0.2778em;\"></span><span>==</span><span style=\"margin-right:0.2778em;\"></span><span>s</span><span>[</span><span style=\"margin-right:0.05724em;\">j</span><span>])</span><span> </span><span>an</span><span>d</span><span> </span><span>d</span><span>p</span><span>[</span><span>i</span><span style=\"margin-right:0.2222em;\"></span><span>+</span><span style=\"margin-right:0.2222em;\"></span><span>1</span><span>]</span><span>[</span><span style=\"margin-right:0.05724em;\">j</span><span style=\"margin-right:0.2222em;\"></span><span>−</span><span style=\"margin-right:0.2222em;\"></span><span>1</span><span>]</span><span>,</span></span></span><span style=\"top:-2.25em;\"><span style=\"height:3.008em;\"></span><span><span>(</span><span>s</span><span>[</span><span>i</span><span>]</span><span style=\"margin-right:0.2778em;\"></span><span>==</span><span style=\"margin-right:0.2778em;\"></span><span>s</span><span>[</span><span style=\"margin-right:0.05724em;\">j</span><span>])</span></span></span></span><span>​</span></span><span><span style=\"height:1.19em;\"><span></span></span></span></span></span><span style=\"width:1em;\"></span><span><span><span><span style=\"height:1.69em;\"><span style=\"top:-3.69em;\"><span style=\"height:3.008em;\"></span><span><span style=\"margin-right:0.05724em;\">j</span><span style=\"margin-right:0.2222em;\"></span><span>−</span><span style=\"margin-right:0.2222em;\"></span><span>i</span><span style=\"margin-right:0.2778em;\"></span><span>≤</span><span style=\"margin-right:0.2778em;\"></span><span><span>2</span></span></span></span><span style=\"top:-2.25em;\"><span style=\"height:3.008em;\"></span><span><span style=\"margin-right:0.05724em;\">j</span><span style=\"margin-right:0.2222em;\"></span><span>−</span><span style=\"margin-right:0.2222em;\"></span><span>i</span><span style=\"margin-right:0.2778em;\"></span><span>&gt;</span><span style=\"margin-right:0.2778em;\"></span><span><span>2</span></span></span></span></span><span>​</span></span><span><span style=\"height:1.19em;\"><span></span></span></span></span></span></span></span><span></span></span></span></span></span></span></p>\n<p><strong>边界条件</strong>：</p>\n<p><code>dp[i][j]</code> 表示 <code>[i,j]</code> 子串是否是回文串，判断该子串是否是回文串需要两个条件：</p>\n<ol>\n<li><code>s[i] == s[j]</code></li>\n<li>掐头去尾看是否还是回文，即 <code>dp[i+1][j-1]</code> 是否是回文。意思就是 <code>dp[i][j]</code> 需要 <code>dp[i+1][j-1]</code> 来判断，即当前元素需要它的左下角元素来判断。正常我们是 <code>for i</code> 里面套 <code>for j</code>，这样循环是一层一层的，就出现了矛盾，即求 <code>dp[i][j]</code> 的时候 <code>dp[i+1][j-1]</code> 此时还是未知的</li>\n</ol>\n</div>\n<div><pre><code><span>class</span> <span>Solution</span> <span>{</span>\n<span>public</span><span>:</span>\n    <span>int</span> <span>countSubstrings</span><span>(</span>string s<span>)</span> <span>{</span>\n        <span>int</span> n <span>=</span> s<span>.</span><span>size</span><span>(</span><span>)</span><span>;</span>\n        <span>int</span> cnt <span>=</span> <span>0</span><span>;</span>\n        vector<span>&lt;</span>vector<span>&lt;</span><span>int</span><span>>></span> <span>dp</span><span>(</span>n<span>,</span> <span><span>vector</span><span><span>&lt;</span><span>int</span><span>></span></span></span><span>(</span>n<span>,</span> <span>false</span><span>)</span><span>)</span><span>;</span>\n        <span>for</span><span>(</span><span>int</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> n<span>;</span> j<span>++</span><span>)</span><span>{</span>\n            <span>for</span><span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;=</span> j<span>;</span> i<span>++</span><span>)</span><span>{</span>\n                <span>if</span><span>(</span>j <span>-</span> i <span>></span> <span>2</span><span>)</span><span>{</span>\n                    dp<span>[</span>i<span>]</span><span>[</span>j<span>]</span> <span>=</span> <span>(</span>s<span>[</span>i<span>]</span> <span>==</span> s<span>[</span>j<span>]</span><span>)</span> <span>&amp;&amp;</span> dp<span>[</span>i <span>+</span> <span>1</span><span>]</span><span>[</span>j <span>-</span> <span>1</span><span>]</span><span>;</span>\n                <span>}</span><span>else</span><span>{</span>\n                    dp<span>[</span>i<span>]</span><span>[</span>j<span>]</span> <span>=</span> <span>(</span>s<span>[</span>i<span>]</span> <span>==</span> s<span>[</span>j<span>]</span><span>)</span><span>;</span>\n                <span>}</span>\n                <span>if</span><span>(</span>dp<span>[</span>i<span>]</span><span>[</span>j<span>]</span> <span>==</span> <span>true</span><span>)</span><span>{</span>\n                    cnt<span>++</span><span>;</span>\n                <span>}</span>\n            <span>}</span>\n        <span>}</span>\n        <span>return</span> cnt<span>;</span>\n    <span>}</span>\n<span>}</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>:::</p>\n<p>::::</p>\n<h2 id=\"参考文献\"> 参考文献</h2>\n<p><a href=\"https://leetcode-cn.com/problems/palindromic-substrings/solution/liang-dao-hui-wen-zi-chuan-de-jie-fa-xiang-jie-zho/\" target=\"_blank\" rel=\"noopener noreferrer\">两道回文子串的解法（详解中心扩展法） - 回文子串 - 力扣（LeetCode） (leetcode-cn.com)</a></p>\n",
      "image": "https://cdn.jsdelivr.net/gh/River-Cold/pictureBed/vuepress-blog/solution/leetcode/LeetCode-hot-topic-HOT-100/647.png",
      "date_published": "2022-04-04T14:19:55.000Z",
      "date_modified": "2022-04-04T14:19:55.000Z",
      "authors": [
        {
          "name": "RiverCold"
        }
      ],
      "tags": []
    },
    {
      "title": "84.柱状图中最大的矩形",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/solution/leetcode/LeetCode-hot-topic-HOT-100/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/solution/leetcode/LeetCode-hot-topic-HOT-100/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2/",
      "content_html": "<h1 id=\"_84-柱状图中最大的矩形\"> 84.柱状图中最大的矩形</h1>\n<p>https://leetcode-cn.com/problems/largest-rectangle-in-histogram/</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/River-Cold/pictureBed/vuepress-blog/docs/solution/leetcode/LeetCode-hot-topic-HOT-100/84.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"方法一-中心扩散\"> 方法一：中心扩散</h2>\n<h3 id=\"思路分析\"> 思路分析</h3>\n<div><p>提示</p>\n<p>首先我们枚举某一根柱子 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.6595em;\"></span><span>i</span></span></span></span> 作为高  <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.6944em;\"></span><span>h</span><span style=\"margin-right:0.2778em;\"></span><span>=</span><span style=\"margin-right:0.2778em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>h</span><span>e</span><span>i</span><span style=\"margin-right:0.03588em;\">g</span><span>h</span><span>t</span><span>s</span><span>[</span><span>i</span><span>]</span></span></span></span></p>\n<p>随后我们需要进行向左右两边扩展，使得扩展到的柱子的高度均不小于 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.6944em;\"></span><span>h</span></span></span></span>。换句话说，我们<strong>需要找到左右两侧最近的高度小于 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.6944em;\"></span><span>h</span></span></span></span> 的柱子</strong>，这样这两根柱子之间（不包括其本身）的所有柱子高度均不小于 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.6944em;\"></span><span>h</span></span></span></span>，并且就是 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.6595em;\"></span><span>i</span></span></span></span> 能够扩展到的最远范围。</p>\n</div>\n<h3 id=\"参考代码\"> 参考代码</h3>\n<CodeGroup>\n<CodeGroupItem title=\"c++\">\n<div><pre><code><span>class</span> <span>Solution</span> <span>{</span>\n<span>public</span><span>:</span>\n    <span>int</span> <span>largestRectangleArea</span><span>(</span>vector<span>&lt;</span><span>int</span><span>></span><span>&amp;</span> heights<span>)</span> <span>{</span>\n        <span>int</span> n <span>=</span> heights<span>.</span><span>size</span><span>(</span><span>)</span><span>;</span>\n        <span>int</span> ans <span>=</span> <span>0</span><span>;</span>\n        <span>for</span><span>(</span><span>int</span> mid <span>=</span> <span>0</span><span>;</span> mid <span>&lt;</span> n<span>;</span> <span>++</span>mid<span>)</span><span>{</span>\n            <span>// 枚举高</span>\n            <span>int</span> height <span>=</span> heights<span>[</span>mid<span>]</span><span>;</span>\n            <span>int</span> left <span>=</span> mid<span>,</span> right <span>=</span> mid<span>;</span>\n            <span>// 确定左右边界</span>\n            <span>while</span><span>(</span>left <span>-</span> <span>1</span> <span>>=</span> <span>0</span> <span>&amp;&amp;</span> heights<span>[</span>left <span>-</span> <span>1</span><span>]</span> <span>>=</span> height<span>)</span><span>{</span>\n                <span>--</span>left<span>;</span>\n            <span>}</span>\n            <span>while</span><span>(</span>right <span>+</span> <span>1</span> <span>&lt;</span> n <span>&amp;&amp;</span> heights<span>[</span>right <span>+</span> <span>1</span><span>]</span> <span>>=</span> height<span>)</span><span>{</span>\n                <span>++</span>right<span>;</span>\n            <span>}</span>\n            <span>// 计算面积</span>\n            ans <span>=</span> <span>max</span><span>(</span>ans<span>,</span> <span>(</span>right <span>-</span> left <span>+</span> <span>1</span><span>)</span> <span>*</span> height<span>)</span><span>;</span>\n        <span>}</span>\n        <span>return</span> ans<span>;</span>\n    <span>}</span>\n<span>}</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div></CodeGroupItem>\n</CodeGroup>\n<h2 id=\"方法二-单调栈\"> 方法二：单调栈</h2>\n<div><p>提示</p>\n<p>维护一个单调递增栈，向左找第一个小于<code>heights[i]</code>的位置<code>left[i]</code>；向右找第一个小于<code>heights[i]</code>的位置<code>right[i]</code>，即最大面积为<code>heights[i]*(right[i]-left[i-1])</code></p>\n<ol>\n<li>\n<p>遍历heights</p>\n</li>\n<li>\n<p>操作规则：</p>\n<ol>\n<li>如果新元素大于栈顶元素，新元素入栈</li>\n<li>否则将栈内元素弹出直到栈顶元素小于新元素</li>\n</ol>\n</li>\n<li>\n<p>规则产生的效果：</p>\n<ol>\n<li>当元素出栈时，说明这个<strong>新元素</strong>是出栈元素<strong>向后</strong>找第一个比其小的元素，即为右边界</li>\n<li>当元素出栈后，说明新<strong>栈顶元素</strong>是出栈元素<strong>向前</strong>找第一个比其小的元素，即为左边界</li>\n</ol>\n</li>\n</ol>\n<p><strong>细节</strong>：</p>\n<ol>\n<li>\n<p><strong>为什么要在heights最前面加0？</strong></p>\n<p>因为没有在heights前加0，不能保证stack不为空，所以left的值就需要赋初始值0</p>\n</li>\n<li>\n<p><strong>为什么要在heights最后面加0？</strong></p>\n<p>在最后加0可以保证矩形高度都是递增的特殊情况下ans也能进行计算</p>\n</li>\n</ol>\n</div>\n<div><pre><code><span>class</span> <span>Solution</span> <span>{</span>\n<span>public</span><span>:</span>\n    <span>int</span> <span>largestRectangleArea</span><span>(</span>vector<span>&lt;</span><span>int</span><span>></span><span>&amp;</span> heights<span>)</span> <span>{</span>\n        <span>int</span> ans <span>=</span> <span>0</span><span>;</span>\n        vector<span>&lt;</span><span>int</span><span>></span> st<span>;</span>\n        \n        heights<span>.</span><span>insert</span><span>(</span>heights<span>.</span><span>begin</span><span>(</span><span>)</span><span>,</span> <span>0</span><span>)</span><span>;</span>\n        heights<span>.</span><span>push_back</span><span>(</span><span>0</span><span>)</span><span>;</span>\n        <span>int</span> n <span>=</span> heights<span>.</span><span>size</span><span>(</span><span>)</span><span>;</span>\n\n        <span>for</span><span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> n<span>;</span> i<span>++</span><span>)</span><span>{</span>\n            <span>while</span><span>(</span><span>!</span>st<span>.</span><span>empty</span><span>(</span><span>)</span> <span>&amp;&amp;</span> heights<span>[</span>st<span>.</span><span>back</span><span>(</span><span>)</span><span>]</span> <span>></span> heights<span>[</span>i<span>]</span><span>)</span><span>{</span>\n                <span>int</span> cur <span>=</span> st<span>.</span><span>back</span><span>(</span><span>)</span><span>;</span>\n                st<span>.</span><span>pop_back</span><span>(</span><span>)</span><span>;</span>\n                \n              <span>// 因为没有在heights前加0，不能保证stack不为空，所以left的值就需要赋初始值0</span>\n              <span>// if (!stack.empty()) {</span>\n              <span>//  left = stack.back() + 1;</span>\n              <span>// }</span>\n                \n                <span>int</span> left <span>=</span> st<span>.</span><span>back</span><span>(</span><span>)</span><span>;</span>\n                <span>int</span> right <span>=</span> i<span>;</span>\n                ans <span>=</span> <span>max</span><span>(</span>ans<span>,</span> <span>(</span>right <span>-</span> left <span>-</span> <span>1</span><span>)</span> <span>*</span> heights<span>[</span>cur<span>]</span><span>)</span><span>;</span>\n            <span>}</span>\n            st<span>.</span><span>push_back</span><span>(</span>i<span>)</span><span>;</span>\n        <span>}</span>   \n\n        <span>return</span> ans<span>;</span>\n    <span>}</span>\n<span>}</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><p>:::</p>\n<p>::::</p>\n<h2 id=\"参考文献\"> 参考文献</h2>\n<p><a href=\"https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/zhao-liang-bian-di-yi-ge-xiao-yu-ta-de-zhi-by-powc/\" target=\"_blank\" rel=\"noopener noreferrer\">找两边第一个小于它的值 - 柱状图中最大的矩形 - 力扣（LeetCode） (leetcode-cn.com)</a></p>\n<p><a href=\"https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/84-by-ikaruga/\" target=\"_blank\" rel=\"noopener noreferrer\">【柱状图中最大的矩形】单调栈入门，使用单调栈快速寻找边界 - 柱状图中最大的矩形 - 力扣（LeetCode） (leetcode-cn.com)</a></p>\n<p>https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/84-by-ikaruga/376124</p>\n",
      "image": "https://cdn.jsdelivr.net/gh/River-Cold/pictureBed/vuepress-blog/docs/solution/leetcode/LeetCode-hot-topic-HOT-100/84.png",
      "date_published": "2022-04-04T14:19:55.000Z",
      "date_modified": "2022-04-04T14:19:55.000Z",
      "authors": [
        {
          "name": "RiverCold"
        }
      ],
      "tags": []
    },
    {
      "title": "85.最大矩形",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/solution/leetcode/LeetCode-hot-topic-HOT-100/85.%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/solution/leetcode/LeetCode-hot-topic-HOT-100/85.%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2/",
      "content_html": "<h1 id=\"_85-最大矩形\"> 85.最大矩形</h1>\n<p>https://leetcode-cn.com/problems/minimum-path-sum/</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/River-Cold/pictureBed/vuepress-blog/solution/leetcode/LeetCode-hot-topic-HOT-100/85.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"方法一-使用柱状图的优化暴力方法\"> 方法一：使用柱状图的优化暴力方法</h2>\n<h3 id=\"思路分析\"> 思路分析</h3>\n<div><p>提示</p>\n<p>用<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span style=\"margin-right:0.01968em;\">l</span><span>e</span><span style=\"margin-right:0.10764em;\">f</span><span>t</span><span>[</span><span>i</span><span>]</span><span>[</span><span style=\"margin-right:0.05724em;\">j</span><span>]</span></span></span></span>记录矩阵第<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.6595em;\"></span><span>i</span></span></span></span>行第<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.854em;vertical-align:-0.1944em;\"></span><span style=\"margin-right:0.05724em;\">j</span></span></span></span>列元素的左边的连续1的数量</p>\n<p>对于矩阵中任意一个点，枚举以该点为右下角的全1矩形</p>\n<p>当考察以<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>ma</span><span>t</span><span style=\"margin-right:0.02778em;\">r</span><span>i</span><span>x</span><span>[</span><span>i</span><span>]</span><span>[</span><span style=\"margin-right:0.05724em;\">j</span><span>]</span></span></span></span>为右下角的矩形时，枚举满足<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.6835em;vertical-align:-0.0391em;\"></span><span>0</span><span style=\"margin-right:0.2778em;\"></span><span>&lt;=</span><span style=\"margin-right:0.2778em;\"></span></span><span><span style=\"height:0.7335em;vertical-align:-0.0391em;\"></span><span style=\"margin-right:0.03148em;\">k</span><span style=\"margin-right:0.2778em;\"></span><span>&lt;=</span><span style=\"margin-right:0.2778em;\"></span></span><span><span style=\"height:0.6595em;\"></span><span>i</span></span></span></span>的所有可能的<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.6944em;\"></span><span style=\"margin-right:0.03148em;\">k</span></span></span></span>，此时矩阵的最大宽度为下列值中的最小值</p>\n<p class='katex-block'><span><span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>min</span><span>{</span><span style=\"margin-right:0.01968em;\">l</span><span>e</span><span style=\"margin-right:0.10764em;\">f</span><span>t</span><span>[</span><span>i</span><span>]</span><span>[</span><span style=\"margin-right:0.05724em;\">j</span><span>]</span><span>,</span><span style=\"margin-right:0.1667em;\"></span><span style=\"margin-right:0.01968em;\">l</span><span>e</span><span style=\"margin-right:0.10764em;\">f</span><span>t</span><span>[</span><span>i</span><span style=\"margin-right:0.2222em;\"></span><span>−</span><span style=\"margin-right:0.2222em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>1</span><span>]</span><span>[</span><span style=\"margin-right:0.05724em;\">j</span><span>]</span><span>,</span><span style=\"margin-right:0.1667em;\"></span><span>...</span><span>,</span><span style=\"margin-right:0.1667em;\"></span><span style=\"margin-right:0.01968em;\">l</span><span>e</span><span style=\"margin-right:0.10764em;\">f</span><span>t</span><span>[</span><span style=\"margin-right:0.03148em;\">k</span><span>]</span><span>[</span><span style=\"margin-right:0.05724em;\">j</span><span>]}</span></span></span></span></span></p>\n</div>\n<h3 id=\"参考代码\"> 参考代码</h3>\n<CodeGroup>\n<CodeGroupItem title=\"c++\">\n<div><pre><code><span>class</span> <span>Solution</span> <span>{</span>\n<span>public</span><span>:</span>\n    <span>int</span> <span>maximalRectangle</span><span>(</span>vector<span>&lt;</span>vector<span>&lt;</span><span>char</span><span>>></span><span>&amp;</span> matrix<span>)</span> <span>{</span>\n        <span>int</span> m <span>=</span> matrix<span>.</span><span>size</span><span>(</span><span>)</span><span>;</span>\n        <span>if</span><span>(</span>m <span>==</span> <span>0</span><span>)</span><span>{</span>\n            <span>return</span> <span>0</span><span>;</span>\n        <span>}</span>\n        <span>int</span> n <span>=</span> matrix<span>[</span><span>0</span><span>]</span><span>.</span><span>size</span><span>(</span><span>)</span><span>;</span>\n        vector<span>&lt;</span>vector<span>&lt;</span><span>int</span><span>>></span> <span>left</span><span>(</span>m<span>,</span> <span><span>vector</span><span><span>&lt;</span><span>int</span><span>></span></span></span><span>(</span>n<span>,</span> <span>0</span><span>)</span><span>)</span><span>;</span>\n        <span>// 初始化left数组</span>\n        <span>for</span><span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> m<span>;</span> i<span>++</span><span>)</span><span>{</span>\n            <span>for</span><span>(</span><span>int</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> n<span>;</span> j<span>++</span><span>)</span><span>{</span>\n                <span>if</span><span>(</span>matrix<span>[</span>i<span>]</span><span>[</span>j<span>]</span> <span>==</span> <span>'1'</span><span>)</span><span>{</span>\n                    left<span>[</span>i<span>]</span><span>[</span>j<span>]</span> <span>=</span> <span>(</span>j <span>==</span> <span>0</span> <span>?</span> <span>0</span> <span>:</span> left<span>[</span>i<span>]</span><span>[</span>j <span>-</span> <span>1</span><span>]</span><span>)</span> <span>+</span> <span>1</span><span>;</span>\n                <span>}</span>\n            <span>}</span>\n        <span>}</span>\n\n        <span>int</span> ret <span>=</span> <span>0</span><span>;</span>\n        <span>for</span><span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> m<span>;</span> i<span>++</span><span>)</span><span>{</span>\n            <span>for</span><span>(</span><span>int</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> n<span>;</span> j<span>++</span><span>)</span><span>{</span>\n                <span>if</span><span>(</span>matrix<span>[</span>i<span>]</span><span>[</span>j<span>]</span> <span>==</span> <span>'0'</span><span>)</span><span>{</span>\n                    <span>continue</span><span>;</span>\n                <span>}</span>\n                <span>int</span> width <span>=</span> left<span>[</span>i<span>]</span><span>[</span>j<span>]</span><span>;</span>\n                <span>int</span> area <span>=</span> width<span>;</span>\n                <span>for</span><span>(</span><span>int</span> k <span>=</span> i <span>-</span> <span>1</span><span>;</span> k <span>>=</span> <span>0</span><span>;</span> k<span>--</span><span>)</span><span>{</span>\n                    width <span>=</span> <span>min</span><span>(</span>width<span>,</span> left<span>[</span>k<span>]</span><span>[</span>j<span>]</span><span>)</span><span>;</span>\n                    area <span>=</span> <span>max</span><span>(</span>area<span>,</span> <span>(</span>i <span>-</span> k <span>+</span> <span>1</span><span>)</span> <span>*</span> width<span>)</span><span>;</span>\n                <span>}</span>\n                ret <span>=</span> <span>max</span><span>(</span>ret<span>,</span> area<span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n        <span>return</span> ret<span>;</span>\n    <span>}</span>\n<span>}</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br></div></div></CodeGroupItem>\n</CodeGroup>\n",
      "image": "https://cdn.jsdelivr.net/gh/River-Cold/pictureBed/vuepress-blog/solution/leetcode/LeetCode-hot-topic-HOT-100/85.png",
      "date_published": "2022-04-04T14:19:55.000Z",
      "date_modified": "2022-04-04T14:19:55.000Z",
      "authors": [
        {
          "name": "RiverCold"
        }
      ],
      "tags": []
    },
    {
      "title": "94.二叉树的中序遍历",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/solution/leetcode/LeetCode-hot-topic-HOT-100/94.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/solution/leetcode/LeetCode-hot-topic-HOT-100/94.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/",
      "content_html": "<h1 id=\"_94-二叉树的中序遍历\"> 94.二叉树的中序遍历</h1>\n<p>https://leetcode-cn.com/problems/binary-tree-inorder-traversal/</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/River-Cold/pictureBed/vuepress-blog/docs/solution/leetcode/LeetCode-hot-topic-HOT-100/94.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"方法一-递归法\"> 方法一：递归法</h2>\n<h3 id=\"思路分析\"> 思路分析</h3>\n<div><p>提示</p>\n</div>\n<h3 id=\"参考代码\"> 参考代码</h3>\n<CodeGroup>\n<CodeGroupItem title=\"c++\">\n<div><pre><code>\n</code></pre>\n<div><span>1</span><br></div></div></CodeGroupItem>\n</CodeGroup>\n<h2 id=\"方法二-迭代法\"> 方法二：迭代法</h2>\n<div><p>提示</p>\n</div>\n<div><pre><code><span>class</span> <span>Solution</span> <span>{</span>\n<span>public</span><span>:</span>\n    <span>// 递归的调用过程是不断往左边走，当左边走不下去了，就打印节点，并转向右边，然后右边继续这个过程。</span>\n    <span>// 我们在迭代实现时，就可以用栈来模拟上面的调用过程。</span>\n    vector<span>&lt;</span><span>int</span><span>></span> <span>inorderTraversal</span><span>(</span>TreeNode<span>*</span> root<span>)</span> <span>{</span>\n        stack<span>&lt;</span>TreeNode<span>*</span><span>></span> st<span>;</span>\n        vector<span>&lt;</span><span>int</span><span>></span> ret<span>;</span>\n        <span>while</span><span>(</span><span>!</span>st<span>.</span><span>empty</span><span>(</span><span>)</span> <span>||</span> root <span>!=</span> <span>nullptr</span><span>)</span><span>{</span>\n            <span>// 不断往左子树方向走，每走一次就将当前节点保存到栈中</span>\n            <span>// 模拟递归的调用</span>\n            <span>if</span><span>(</span>root <span>!=</span> <span>nullptr</span><span>)</span><span>{</span>\n                st<span>.</span><span>push</span><span>(</span>root<span>)</span><span>;</span>\n                root <span>=</span> root<span>-></span>left<span>;</span>\n            <span>}</span>\n            <span>// 当前节点为空，说明左子树方向已经走到尽头，从栈中弹出节点并保存</span>\n            <span>// 然后转向右边节点，继续上面整个过程</span>\n            <span>else</span><span>{</span>\n                TreeNode<span>*</span> tmp <span>=</span> st<span>.</span><span>top</span><span>(</span><span>)</span><span>;</span>\n                st<span>.</span><span>pop</span><span>(</span><span>)</span><span>;</span>\n                ret<span>.</span><span>push_back</span><span>(</span>tmp<span>-></span>val<span>)</span><span>;</span>\n                root <span>=</span> tmp<span>-></span>right<span>;</span>\n            <span>}</span>\n        <span>}</span>\n        <span>return</span> ret<span>;</span>\n    <span>}</span>\n<span>}</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><p>:::</p>\n<p>::::</p>\n<h2 id=\"参考文献\"> 参考文献</h2>\n<p><a href=\"https://leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/dong-hua-yan-shi-94-er-cha-shu-de-zhong-xu-bian-li/\" target=\"_blank\" rel=\"noopener noreferrer\">动画演示+三种实现 94. 二叉树的中序遍历 - 二叉树的中序遍历 - 力扣（LeetCode） (leetcode-cn.com)</a></p>\n",
      "image": "https://cdn.jsdelivr.net/gh/River-Cold/pictureBed/vuepress-blog/docs/solution/leetcode/LeetCode-hot-topic-HOT-100/94.png",
      "date_published": "2022-04-04T14:19:55.000Z",
      "date_modified": "2022-04-04T14:19:55.000Z",
      "authors": [
        {
          "name": "RiverCold"
        }
      ],
      "tags": []
    },
    {
      "title": "145.二叉树的后序遍历",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/solution/leetcode/LeetCode-hot-topic-HOT-100/94.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/solution/leetcode/LeetCode-hot-topic-HOT-100/94.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/",
      "content_html": "<h1 id=\"_145-二叉树的后序遍历\"> 145.二叉树的后序遍历</h1>\n<p>https://leetcode-cn.com/problems/binary-tree-postorder-traversal/</p>\n<h2 id=\"方法一-递归法\"> 方法一：递归法</h2>\n<h3 id=\"思路分析\"> 思路分析</h3>\n<div><p>提示</p>\n</div>\n<h3 id=\"参考代码\"> 参考代码</h3>\n<CodeGroup>\n<CodeGroupItem title=\"c++\">\n<div><pre><code>\n</code></pre>\n<div><span>1</span><br></div></div></CodeGroupItem>\n</CodeGroup>\n<h2 id=\"方法二-迭代法\"> 方法二：迭代法</h2>\n<div><p>提示</p>\n</div>\n<div><pre><code><span>class</span> <span>Solution</span> <span>{</span>\n<span>public</span><span>:</span>\n    vector<span>&lt;</span><span>int</span><span>></span> <span>postorderTraversal</span><span>(</span>TreeNode<span>*</span> root<span>)</span> <span>{</span>\n        vector<span>&lt;</span><span>int</span><span>></span> ret<span>;</span>\n        stack<span>&lt;</span>TreeNode<span>*</span><span>></span> st<span>;</span>\n        <span>// 思路分析</span>\n        <span>// 初始化一个空栈</span>\n        <span>// 当根节点不为空或者栈不为空时，从根节点开始</span>\n        <span>// 每次将当前节点压入栈中，如果当前节点有左子树，就往左子树遍历，没有左子树就往右子树跑</span>\n        <span>// 如果当前节点无左子树也无右子树，从栈中弹出该节点，如果当前节点是上一个节点（即弹出该节点后的栈顶元素）的左节点，尝试访问上一个节点的右子树，如果不是，那当前栈的栈顶元素继续弹出</span>\n        <span>while</span><span>(</span><span>!</span>st<span>.</span><span>empty</span><span>(</span><span>)</span> <span>||</span> root <span>!=</span> <span>nullptr</span><span>)</span><span>{</span>\n            <span>// 往左子树一直遍历直到为空</span>\n            <span>while</span><span>(</span>root <span>!=</span> <span>nullptr</span><span>)</span><span>{</span>\n                st<span>.</span><span>push</span><span>(</span>root<span>)</span><span>;</span>\n                <span>if</span><span>(</span>root<span>-></span>left<span>)</span><span>{</span>\n                    root <span>=</span> root<span>-></span>left<span>;</span>\n                <span>}</span><span>else</span><span>{</span>\n                    root <span>=</span> root<span>-></span>right<span>;</span>\n                <span>}</span>\n            <span>}</span>\n            <span>// root为当前栈顶元素的左结点</span>\n            root <span>=</span> st<span>.</span><span>top</span><span>(</span><span>)</span><span>;</span>\n            <span>// 弹出栈顶元素</span>\n            st<span>.</span><span>pop</span><span>(</span><span>)</span><span>;</span>\n            <span>// 加入结果数组</span>\n            ret<span>.</span><span>push_back</span><span>(</span>root<span>-></span>val<span>)</span><span>;</span>\n            <span>// 如果栈不为空且当前栈顶元素的左节点是刚刚跳出的栈顶元素root</span>\n            <span>// 则转向遍历当前栈顶元素的右子树</span>\n            <span>if</span><span>(</span><span>!</span>st<span>.</span><span>empty</span><span>(</span><span>)</span> <span>&amp;&amp;</span> st<span>.</span><span>top</span><span>(</span><span>)</span><span>-></span>left <span>==</span> root<span>)</span><span>{</span>\n                root <span>=</span> st<span>.</span><span>top</span><span>(</span><span>)</span><span>-></span>right<span>;</span>\n            <span>// 否则证明当前栈顶元素无左右子树，那当前的栈顶元素弹出</span>\n            <span>}</span><span>else</span><span>{</span>\n                root <span>=</span> <span>nullptr</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n        \n        <span>return</span> ret<span>;</span>\n    <span>}</span>\n<span>}</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br></div></div><p>:::</p>\n<p>::::</p>\n<h2 id=\"参考文献\"> 参考文献</h2>\n<p><a href=\"https://leetcode-cn.com/problems/binary-tree-postorder-traversal/solution/acm-xuan-shou-tu-jie-leetcode-er-cha-shu-q9ep/\" target=\"_blank\" rel=\"noopener noreferrer\">ACM 选手图解 LeetCode 二叉树后序遍历（递归 + 非递归） | 编程文青李狗蛋 - 二叉树的后序遍历 - 力扣（LeetCode） (leetcode-cn.com)</a></p>\n<p><a href=\"https://leetcode-cn.com/problems/binary-tree-postorder-traversal/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by--34/\" target=\"_blank\" rel=\"noopener noreferrer\">详细通俗的思路分析，多解法 - 二叉树的后序遍历 - 力扣（LeetCode） (leetcode-cn.com)</a></p>\n",
      "date_published": "2022-04-04T14:19:55.000Z",
      "date_modified": "2022-04-04T14:19:55.000Z",
      "authors": [
        {
          "name": "RiverCold"
        }
      ],
      "tags": []
    },
    {
      "title": "96.不同的二叉搜索树",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/solution/leetcode/LeetCode-hot-topic-HOT-100/96.%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/solution/leetcode/LeetCode-hot-topic-HOT-100/96.%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/",
      "content_html": "<h1 id=\"_96-不同的二叉搜索树\"> 96.不同的二叉搜索树</h1>\n<p>https://leetcode-cn.com/problems/unique-binary-search-trees/</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/River-Cold/pictureBed/vuepress-blog/solution/leetcode/LeetCode-hot-topic-HOT-100/96.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"方法一-动态规划\"> 方法一：动态规划</h2>\n<h3 id=\"思路分析\"> 思路分析</h3>\n<div><p>提示</p>\n<p>状态定义：</p>\n<p>设<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>d</span><span>p</span><span>[</span><span>i</span><span>]</span></span></span></span>代表用连着的<code>i</code>个数，所构建出的二叉搜索树（BST）种类数，左子树用掉<code>j</code>个，则右子树用掉<code>i-j-1</code>个，能构建出<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>d</span><span>p</span><span>[</span><span style=\"margin-right:0.05724em;\">j</span><span>]</span><span style=\"margin-right:0.2222em;\"></span><span>∗</span><span style=\"margin-right:0.2222em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>d</span><span>p</span><span>[</span><span>i</span><span style=\"margin-right:0.2222em;\"></span><span>−</span><span style=\"margin-right:0.2222em;\"></span></span><span><span style=\"height:0.854em;vertical-align:-0.1944em;\"></span><span style=\"margin-right:0.05724em;\">j</span><span style=\"margin-right:0.2222em;\"></span><span>−</span><span style=\"margin-right:0.2222em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>1</span><span>]</span></span></span></span>种不同的BST</p>\n<p class='katex-block'><span><span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>d</span><span>p</span><span>[</span><span>i</span><span>]</span><span style=\"margin-right:0.2778em;\"></span><span>=</span><span style=\"margin-right:0.2778em;\"></span></span><span><span style=\"height:1.6em;vertical-align:-0.55em;\"></span><span style=\"position:relative;top:0em;\">∑</span><span style=\"margin-right:0.1667em;\"></span><span><span>d</span><span>p</span><span>[</span><span style=\"margin-right:0.05724em;\">j</span><span>]</span><span style=\"margin-right:0.2222em;\"></span><span>∗</span><span style=\"margin-right:0.2222em;\"></span><span>d</span><span>p</span><span>[</span><span>i</span><span style=\"margin-right:0.2222em;\"></span><span>−</span><span style=\"margin-right:0.2222em;\"></span><span style=\"margin-right:0.05724em;\">j</span><span style=\"margin-right:0.2222em;\"></span><span>−</span><span style=\"margin-right:0.2222em;\"></span><span>1</span><span>]</span></span><span>,</span><span style=\"margin-right:0.1667em;\"></span><span>0</span><span style=\"margin-right:0.2778em;\"></span><span>≤</span><span style=\"margin-right:0.2778em;\"></span></span><span><span style=\"height:0.854em;vertical-align:-0.1944em;\"></span><span><span style=\"margin-right:0.05724em;\">j</span></span><span style=\"margin-right:0.2778em;\"></span><span>≤</span><span style=\"margin-right:0.2778em;\"></span></span><span><span style=\"height:0.854em;vertical-align:-0.1944em;\"></span><span><span>i</span><span style=\"margin-right:0.2222em;\"></span><span>−</span><span style=\"margin-right:0.2222em;\"></span><span>1</span></span><span>,</span><span style=\"margin-right:0.1667em;\"></span><span>2</span><span style=\"margin-right:0.2778em;\"></span><span>≤</span><span style=\"margin-right:0.2778em;\"></span></span><span><span style=\"height:0.7955em;vertical-align:-0.136em;\"></span><span><span>i</span></span><span style=\"margin-right:0.2778em;\"></span><span>≤</span><span style=\"margin-right:0.2778em;\"></span></span><span><span style=\"height:0.4306em;\"></span><span><span>n</span></span></span></span></span></span></p>\n<p>边界条件：</p>\n<p class='katex-block'><span><span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>d</span><span>p</span><span>[</span><span>0</span><span>]</span><span style=\"margin-right:0.2778em;\"></span><span>=</span><span style=\"margin-right:0.2778em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>d</span><span>p</span><span>[</span><span>1</span><span>]</span><span style=\"margin-right:0.2778em;\"></span><span>=</span><span style=\"margin-right:0.2778em;\"></span></span><span><span style=\"height:0.6444em;\"></span><span>1</span></span></span></span></span></p>\n<ul>\n<li>当<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.4306em;\"></span><span>n</span><span style=\"margin-right:0.2778em;\"></span><span>=</span><span style=\"margin-right:0.2778em;\"></span></span><span><span style=\"height:0.6444em;\"></span><span>0</span></span></span></span>时，没有数字，只能形成一种BST：空树</li>\n<li>当<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.4306em;\"></span><span>n</span><span style=\"margin-right:0.2778em;\"></span><span>=</span><span style=\"margin-right:0.2778em;\"></span></span><span><span style=\"height:0.6444em;\"></span><span>1</span></span></span></span>时，只有一个数字，只能形成一种BST：单个节点</li>\n</ul>\n</div>\n<h3 id=\"参考代码\"> 参考代码</h3>\n<CodeGroup>\n<CodeGroupItem title=\"c++\">\n<div><pre><code><span>class</span> <span>Solution</span> <span>{</span>\n<span>public</span><span>:</span>\n    <span>/*\n    设dp[i]代表连着的i个数能构建的BST的个数\n    dp[i]=∑dp[j]∗dp[i−j−1],0&lt;=j&lt;=i−1\n    */</span>\n    <span>int</span> <span>numTrees</span><span>(</span><span>int</span> n<span>)</span> <span>{</span>\n        vector<span>&lt;</span><span>int</span><span>></span> <span>dp</span><span>(</span>n <span>+</span> <span>1</span><span>,</span> <span>0</span><span>)</span><span>;</span>\n        dp<span>[</span><span>0</span><span>]</span> <span>=</span> dp<span>[</span><span>1</span><span>]</span> <span>=</span> <span>1</span><span>;</span>\n        <span>for</span><span>(</span><span>int</span> i <span>=</span> <span>2</span><span>;</span> i <span>&lt;=</span> n<span>;</span> i<span>++</span><span>)</span><span>{</span>\n            <span>for</span><span>(</span><span>int</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> i<span>;</span> j<span>++</span><span>)</span><span>{</span>\n                dp<span>[</span>i<span>]</span> <span>=</span> dp<span>[</span>i<span>]</span> <span>+</span> dp<span>[</span>j<span>]</span> <span>*</span> dp<span>[</span>i <span>-</span> j <span>-</span> <span>1</span><span>]</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n        <span>return</span> dp<span>[</span>n<span>]</span><span>;</span>\n    <span>}</span>\n<span>}</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div></CodeGroupItem>\n</CodeGroup>\n",
      "image": "https://cdn.jsdelivr.net/gh/River-Cold/pictureBed/vuepress-blog/solution/leetcode/LeetCode-hot-topic-HOT-100/96.png",
      "date_published": "2022-04-04T14:19:55.000Z",
      "date_modified": "2022-04-04T14:19:55.000Z",
      "authors": [
        {
          "name": "RiverCold"
        }
      ],
      "tags": []
    },
    {
      "title": "98.验证二叉搜索树",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/solution/leetcode/LeetCode-hot-topic-HOT-100/98.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/solution/leetcode/LeetCode-hot-topic-HOT-100/98.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/",
      "content_html": "<h1 id=\"_98-验证二叉搜索树\"> 98.验证二叉搜索树</h1>\n<p>https://leetcode-cn.com/problems/validate-binary-search-tree/</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/River-Cold/pictureBed/vuepress-blog/docs/solution/leetcode/LeetCode-hot-topic-HOT-100/98.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"方法一-递归\"> 方法一：递归</h2>\n<h3 id=\"思路分析\"> 思路分析</h3>\n<div><p>提示</p>\n<p>如果二叉树的左子树不为空，则左子树上所有节点的值均小于它的根节点的值；若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值；它的左右子树也为二叉搜索树。</p>\n<p><strong>递归函数</strong></p>\n<p><code>helper(root,lower,upper)</code>函数表示考虑以<code>root</code>为根的子树，判断子树中所有节点的值是否都在 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>(</span><span style=\"margin-right:0.01968em;\">l</span><span>,</span><span style=\"margin-right:0.1667em;\"></span><span style=\"margin-right:0.02778em;\">r</span><span>)</span></span></span></span> 的范围内</p>\n<p><strong>递归终止条件</strong></p>\n<p>根节点为空</p>\n<p>左子树节点的值大于根节点的值，右子树节点的值小于根节点的值</p>\n</div>\n<h3 id=\"参考代码\"> 参考代码</h3>\n<CodeGroup>\n<CodeGroupItem title=\"c++\">\n<div><pre><code><span>class</span> <span>Solution</span> <span>{</span>\n<span>public</span><span>:</span>\n    <span>bool</span> <span>helper</span><span>(</span>TreeNode<span>*</span> root<span>,</span> <span>long</span> lower<span>,</span> <span>long</span> upper<span>)</span><span>{</span>\n        <span>if</span><span>(</span>root <span>==</span> <span>nullptr</span><span>)</span><span>{</span>\n            <span>return</span> <span>true</span><span>;</span>\n        <span>}</span>\n        <span>if</span><span>(</span>root<span>-></span>val <span>&lt;=</span> lower <span>||</span> root<span>-></span>val <span>>=</span> upper<span>)</span><span>{</span>\n            <span>return</span> <span>false</span><span>;</span>\n        <span>}</span>\n        <span>return</span> <span>helper</span><span>(</span>root<span>-></span>left<span>,</span> lower<span>,</span> root<span>-></span>val<span>)</span> <span>&amp;&amp;</span> <span>helper</span><span>(</span>root<span>-></span>right<span>,</span> root<span>-></span>val<span>,</span> upper<span>)</span><span>;</span>\n    <span>}</span>\n    <span>bool</span> <span>isValidBST</span><span>(</span>TreeNode<span>*</span> root<span>)</span> <span>{</span>\n        <span>if</span><span>(</span>root <span>==</span> <span>nullptr</span><span>)</span><span>{</span>\n            <span>return</span> <span>true</span><span>;</span>\n        <span>}</span>\n        <span>return</span> <span>helper</span><span>(</span>root<span>,</span> LONG_MIN<span>,</span> LONG_MAX<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div></CodeGroupItem>\n</CodeGroup>\n<h3 id=\"复杂度分析\"> 复杂度分析</h3>\n<ol>\n<li>时间复杂度：<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span style=\"margin-right:0.02778em;\">O</span><span>(</span><span>n</span><span>)</span></span></span></span></li>\n<li>空间复杂度：<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span style=\"margin-right:0.02778em;\">O</span><span>(</span><span>n</span><span>)</span></span></span></span></li>\n</ol>\n<h2 id=\"参考文献\"> 参考文献</h2>\n<p><a href=\"https://leetcode-cn.com/problems/validate-binary-search-tree/solution/yan-zheng-er-cha-sou-suo-shu-by-leetcode-solution/\" target=\"_blank\" rel=\"noopener noreferrer\">验证二叉搜索树 - 验证二叉搜索树 - 力扣（LeetCode） (leetcode-cn.com)</a>https://leetcode-cn.com/problems/target-sum/solution/dong-tai-gui-hua-si-kao-quan-guo-cheng-by-keepal/)</p>\n",
      "image": "https://cdn.jsdelivr.net/gh/River-Cold/pictureBed/vuepress-blog/docs/solution/leetcode/LeetCode-hot-topic-HOT-100/98.png",
      "date_published": "2022-04-04T14:19:55.000Z",
      "date_modified": "2022-04-04T14:19:55.000Z",
      "authors": [
        {
          "name": "RiverCold"
        }
      ],
      "tags": []
    },
    {
      "title": "LeetCode 热题 HOT 100",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/solution/leetcode/LeetCode-hot-topic-HOT-100/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/solution/leetcode/LeetCode-hot-topic-HOT-100/",
      "content_html": "<h1 id=\"leetcode-热题-hot-100\"> LeetCode 热题 HOT 100</h1>\n<table>\n<thead>\n<tr>\n<th>题解</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"./1.两数之和.html\">1.两数之和</a></td>\n</tr>\n<tr>\n<td><a href=\"./64.最小路径和.html\">64.最小路径和</a></td>\n</tr>\n<tr>\n<td><a href=\"./85.最大矩形.html\">85.最大矩形</a></td>\n</tr>\n<tr>\n<td><a href=\"./121.买卖股票的最佳时机.html\">121.买卖股票的最佳时机</a></td>\n</tr>\n<tr>\n<td><a href=\"./139.单词拆分.html\">139.单词拆分</a></td>\n</tr>\n<tr>\n<td><a href=\"./146.LRU缓存.html\">146.LRU缓存</a></td>\n</tr>\n<tr>\n<td><a href=\"./148.排序链表.html\">148.排序链表</a></td>\n</tr>\n<tr>\n<td><a href=\"./206.反转链表.html\">206.反转链表</a></td>\n</tr>\n<tr>\n<td><a href=\"./236.二叉树的最近公共祖先.html\">236.二叉树的最近公共祖先</a></td>\n</tr>\n<tr>\n<td><a href=\"./297.二叉树的序列化与反序列化.html\">297.二叉树的序列化与反序列化</a></td>\n</tr>\n<tr>\n<td><a href=\"./309.最佳买卖股票时机含冷冻期.html\">309.最佳买卖股票时机含冷冻期</a></td>\n</tr>\n<tr>\n<td><a href=\"./337.打家劫舍III.html\">337.打家劫舍III</a></td>\n</tr>\n<tr>\n<td><a href=\"./338.比特位计数.html\">338.比特位计数</a></td>\n</tr>\n<tr>\n<td><a href=\"./416.分割等和子集.html\">416.分割等和子集</a></td>\n</tr>\n<tr>\n<td><a href=\"./494.目标和.html\">494.目标和</a></td>\n</tr>\n<tr>\n<td><a href=\"./647.回文子串.html\">647.回文子串</a></td>\n</tr>\n<tr>\n<td></td>\n</tr>\n<tr>\n<td></td>\n</tr>\n<tr>\n<td></td>\n</tr>\n<tr>\n<td></td>\n</tr>\n<tr>\n<td></td>\n</tr>\n<tr>\n<td></td>\n</tr>\n<tr>\n<td></td>\n</tr>\n<tr>\n<td></td>\n</tr>\n</tbody>\n</table>\n",
      "date_published": "2022-04-04T14:19:55.000Z",
      "date_modified": "2022-04-04T14:19:55.000Z",
      "authors": [
        {
          "name": "RiverCold"
        }
      ],
      "tags": []
    },
    {
      "title": "1.md",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/solution/nowcoder/sql-advanced/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/vuepress-blog/solution/nowcoder/sql-advanced/",
      "content_html": "<h1 id=\"_1-md\"> 1.md</h1>\n<p>sql-advanced!</p>\n",
      "date_published": "2022-04-04T14:19:55.000Z",
      "date_modified": "2022-04-04T14:19:55.000Z",
      "authors": [
        {
          "name": "RiverCold"
        }
      ],
      "tags": []
    }
  ]
}