# 494.目标和

https://leetcode-cn.com/problems/target-sum/

![](https://cdn.jsdelivr.net/gh/River-Cold/pictureBed/vuepress-blog/solution/leetcode/LeetCode-hot-topic-HOT-100/494.png)

## 方法一：递归回溯

### 思路分析

::: tip

数据范围只有 2020，而且每个数据只有 +/-+/− 两种选择，因此可以直接使用 DFS 进行「爆搜」

:::

### 参考代码

:::: code-group

::: code-group-item c++

```cpp
class Solution {
public:
    int cnt = 0;
    void dfs(int sum, int index, vector<int>& nums, int target){
        if(index == nums.size()){
            if(sum == target){
                cnt++;
            }
            return;
        }
        dfs(sum + nums[index], index + 1, nums, target);
        dfs(sum - nums[index], index + 1, nums, target);
    }
    int findTargetSumWays(vector<int>& nums, int target) {
        dfs(0, 0, nums, target);
        return cnt;
    }
};
```

:::

::::

### 复杂度分析

1. 时间复杂度：$O(2^n)$
2. 空间复杂度：$O(1)$

## 方法二：动态规划

### 思路分析

::: tip

**状态定义**：

设`dp[i][j]`表示考虑前`i`个数，当前计算结果为`j`的方案数

**状态转移方程**：
$$
f[i][j]=f[i-1][j-nums[i-1]]+f[i-1][j+nums[i-1]]
$$
**边界条件**：

代表不考虑任何数，凑出计算结果为 0 的方案数为 1 种
$$
f[0][0]=1
$$
这里还需要考虑维度范围：

第一维为物品数量：范围为`[0,nums.size()]`

第二维为中间结果：令`s`为所有`nums`元素的总和，则中间结果的范围为`[-s,s]`

### 参考代码

:::

```cpp
class Solution {
public:
    /*
    状态定义:
    f[i][j]代表考虑前i个数，当前计算结果为j的方案数
    状态转移方程:
    f[i][j] = f[i - 1][j - nums[i - 1]] + f[i - 1][j + nums[i - 1]]
    在转移时，对第二维度的使用做一个 s 的右偏移，以确保「负权值」也能够被合理计算/存储。
    边界条件:
    f[0][0]= 1（代表不考虑任何数，凑出计算结果为 0 的方案数为 1 种
    */
    int findTargetSumWays(vector<int>& nums, int target) {
        int n = nums.size();
        int s = 0;  //s为所有nums元素的总和
        for(int i : nums){
            s += abs(i);
        }
        if(abs(target) > s)
            return 0;
        vector<vector<int>> f(n + 1, vector<int>(2 * s + 1));
        f[0][s] = 1;    //f[0][s] = 1
        // 第一维为物品数量
        for(int i = 1; i <= n; i++){
            int x = nums[i - 1];
            // 第二维为中间结果
            // 中间结果的范围为[-s,s]
            for(int j = -s; j <= s; j++){
                if((j - x) + s >= 0){
                    f[i][j + s] += f[i - 1][(j - x) + s];
                }
                if((j + x) + s <= 2 * s){
                    f[i][j + s] += f[i - 1][(j + x) + s];
                }
            }
        }
        return f[n][target + s];
    }
};
```

:::

::::

### 复杂度分析

1. 时间复杂度：
2. 空间复杂度：

## 参考文献

[【宫水三叶】一题四解 : 「DFS」&「记忆化搜索」&「全量 DP」&「优化 DP」 - 目标和 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/target-sum/solution/gong-shui-san-xie-yi-ti-si-jie-dfs-ji-yi-et5b/)

[494. 目标和 - 目标和 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/target-sum/solution/494-mu-biao-he-by-ming-zhi-shan-you-m9rfkvkdad/)

[动态规划思考全过程 - 目标和 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/target-sum/solution/dong-tai-gui-hua-si-kao-quan-guo-cheng-by-keepal/)
