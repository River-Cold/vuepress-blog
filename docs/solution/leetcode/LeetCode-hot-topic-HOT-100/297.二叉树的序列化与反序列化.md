#  297.二叉树的序列化与反序列化

https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/

![](https://cdn.jsdelivr.net/gh/River-Cold/pictureBed/vuepress-blog/solution/leetcode/LeetCode-hot-topic-HOT-100/297.png)

## 方法一：先序遍历DFS

### 思路分析

::: tip

深度优先搜索策略区分为先序遍历、中序遍历、后序遍历，这里采用先序遍历的编码方式对二叉树进行序列化

**序列化**

- 遇到空子树时序列化为`NULL`
- 遇到非空子树时首先序列化根节点root为`root->val`，递归序列化这棵树的左子树和右子树。

**反序列化**

- 根据空格将二叉树的先序遍历序列分割得到先序遍历的元素列表，从左向右遍历这个序列
  - 遇到元素为`NULL`时反序列化为空树
  - 遇到元素为数值时创建根节点`root`为`stoi(str)`，继续递归反序列化`root`的左右子树

:::

### 参考代码

:::: code-group

::: code-group-item c++

```cpp
class Codec {
public:
    void rserialize(TreeNode* root, string& str){
        if(root == NULL){
            str += "null ";
        } else{
            str += to_string(root->val) + " ";
            rserialize(root->left, str);
            rserialize(root->right, str);
        }
    }

    // Encodes a tree to a single string.
    string serialize(TreeNode* root) {
        string ret;
        rserialize(root, ret);
        return ret;
    }

    TreeNode* rdeserialize(list<string>& dataArray){
        if(dataArray.front() == "null"){
            dataArray.erase(dataArray.begin());
            return NULL;
        }

        TreeNode* root = new TreeNode(stoi(dataArray.front()));
        dataArray.erase(dataArray.begin());
        root->left = rdeserialize(dataArray);
        root->right = rdeserialize(dataArray);
        return root;
    }

    // Decodes your encoded data to tree.
    TreeNode* deserialize(string data) {
        list<string> dataArray;
        string str;
        stringstream ss(data);
        while(ss >> str){
            dataArray.emplace_back(str);
        }
        return rdeserialize(dataArray);
    }
};
```

:::

::::

## 方法二：层次遍历BFS

### 思路分析

::: tip

**序列化**

对树进行层次遍历，维护一个队列`q`，初始时让根节点入队，考察出队节点：

- 如果出队节点为`null`，将符号`null`加入`encode`
- 如果出队节点为数值，将节点值加入`encode`，并将其左右子节点入队（子节点为NULL也要入队，它对应`null`，需要被记录）

循环出队入队过程直到队列为空，遍历完所有节点，完成序列化。

**反序列化**

维护一个队列`q`，初始时用序列化字符串`encode`的第一个子串`encode[0]`创建根节点，并将根节点入队。

- 将队首元素`top`出队，然后利用`encode`串的接下来两个元素创建左右节点，并让`top`指向左右子节点

- 如果子节点不为空，则将子节点继续入队

循环出队入队过程直到队列为空，遍历完`encode`串，完成反序列化。

:::

### 参考代码

:::: code-group

::: code-group-item c++

```cpp
class Codec {
public:

    // Encodes a tree to a single string.
    string serialize(TreeNode* root) {
        string encode = "";

        queue<TreeNode*> q;
        if(root == NULL){
            encode = "null";
            return encode;
        }
        
        q.push(root);
        
        while(!q.empty()){
            auto top = q.front();
            q.pop();
            if(top == NULL){
                encode += " null";
                continue;
            }
            if(top != root)
                encode += " ";
            encode += to_string(top->val);
            q.push(top->left);
            q.push(top->right);
        }

        // cout << "encode = " << encode << endl;
        return encode;       
    }

    // Decodes your encoded data to tree.
    TreeNode* deserialize(string data) {
        stringstream ss(data);
        string str;
        
        ss >> str;
        if(str == "null"){
            return NULL;
        }

        // cout << "str = " << str << endl;
        TreeNode* root = new TreeNode(stoi(str));
        queue<TreeNode*> q;
        q.push(root);
        while(!q.empty()){
            auto top = q.front();
            q.pop();

            TreeNode* root = top;
            
            ss >> str;
            TreeNode* left = (str == "null" ? NULL : new TreeNode(stoi(str)));

            ss >> str;
            TreeNode* right = (str == "null" ? NULL : new TreeNode(stoi(str)));

            root->left = left, root->right = right;

            if(root->left){
                q.push(root->left);
            }
            if(root->right){
                q.push(root->right);
            }
        }

        return root;
    }
};
```

:::

::::

## 参考文献

[二叉树的序列化与反序列化 - 二叉树的序列化与反序列化 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/solution/er-cha-shu-de-xu-lie-hua-yu-fan-xu-lie-hua-by-le-2/)

[『手画图解』剖析DFS、BFS解法 | 二叉树的序列化与反序列化 - 二叉树的序列化与反序列化 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/solution/shou-hui-tu-jie-gei-chu-dfshe-bfsliang-chong-jie-f/)