# 84.柱状图中最大的矩形

https://leetcode-cn.com/problems/largest-rectangle-in-histogram/

![](https://cdn.jsdelivr.net/gh/River-Cold/pictureBed/vuepress-blog/docs/solution/leetcode/LeetCode-hot-topic-HOT-100/84.png)

## 方法一：中心扩散

### 思路分析

::: tip

首先我们枚举某一根柱子 $i$ 作为高  $h=heights[i]$

随后我们需要进行向左右两边扩展，使得扩展到的柱子的高度均不小于 $h$。换句话说，我们**需要找到左右两侧最近的高度小于 $h$ 的柱子**，这样这两根柱子之间（不包括其本身）的所有柱子高度均不小于 $h$，并且就是 $i$ 能够扩展到的最远范围。

:::

### 参考代码

:::: code-group

::: code-group-item c++

```cpp
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        int n = heights.size();
        int ans = 0;
        for(int mid = 0; mid < n; ++mid){
            // 枚举高
            int height = heights[mid];
            int left = mid, right = mid;
            // 确定左右边界
            while(left - 1 >= 0 && heights[left - 1] >= height){
                --left;
            }
            while(right + 1 < n && heights[right + 1] >= height){
                ++right;
            }
            // 计算面积
            ans = max(ans, (right - left + 1) * height);
        }
        return ans;
    }
};
```

:::

::::

## 方法二：单调栈

::: tip

维护一个单调递增栈，向左找第一个小于`heights[i]`的位置`left[i]`；向右找第一个小于`heights[i]`的位置`right[i]`，即最大面积为`heights[i]*(right[i]-left[i-1])`

1. 遍历heights
2. 操作规则：

   1. 如果新元素大于栈顶元素，新元素入栈
   2. 否则将栈内元素弹出直到栈顶元素小于新元素
3. 规则产生的效果：
   1. 当元素出栈时，说明这个**新元素**是出栈元素**向后**找第一个比其小的元素，即为右边界
   2. 当元素出栈后，说明新**栈顶元素**是出栈元素**向前**找第一个比其小的元素，即为左边界

**细节**：

1. **为什么要在heights最前面加0？** 

   因为没有在heights前加0，不能保证stack不为空，所以left的值就需要赋初始值0

2. **为什么要在heights最后面加0？** 

   在最后加0可以保证矩形高度都是递增的特殊情况下ans也能进行计算

:::

```cpp
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        int ans = 0;
        vector<int> st;
        
        heights.insert(heights.begin(), 0);
        heights.push_back(0);
        int n = heights.size();

        for(int i = 0; i < n; i++){
            while(!st.empty() && heights[st.back()] > heights[i]){
                int cur = st.back();
                st.pop_back();
                
              // 因为没有在heights前加0，不能保证stack不为空，所以left的值就需要赋初始值0
              // if (!stack.empty()) {
              //  left = stack.back() + 1;
              // }
                
                int left = st.back();
                int right = i;
                ans = max(ans, (right - left - 1) * heights[cur]);
            }
            st.push_back(i);
        }   

        return ans;
    }
};
```

:::

::::

## 参考文献

[找两边第一个小于它的值 - 柱状图中最大的矩形 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/zhao-liang-bian-di-yi-ge-xiao-yu-ta-de-zhi-by-powc/)

[【柱状图中最大的矩形】单调栈入门，使用单调栈快速寻找边界 - 柱状图中最大的矩形 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/84-by-ikaruga/)

https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/84-by-ikaruga/376124