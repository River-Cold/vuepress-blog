# 145.二叉树的后序遍历

https://leetcode-cn.com/problems/binary-tree-postorder-traversal/



## 方法一：递归法

### 思路分析

::: tip



:::

### 参考代码

:::: code-group

::: code-group-item c++

```cpp

```

:::

::::

## 方法二：迭代法

::: tip

:::

```cpp
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> ret;
        stack<TreeNode*> st;
        // 思路分析
        // 初始化一个空栈
        // 当根节点不为空或者栈不为空时，从根节点开始
        // 每次将当前节点压入栈中，如果当前节点有左子树，就往左子树遍历，没有左子树就往右子树跑
        // 如果当前节点无左子树也无右子树，从栈中弹出该节点，如果当前节点是上一个节点（即弹出该节点后的栈顶元素）的左节点，尝试访问上一个节点的右子树，如果不是，那当前栈的栈顶元素继续弹出
        while(!st.empty() || root != nullptr){
            // 往左子树一直遍历直到为空
            while(root != nullptr){
                st.push(root);
                if(root->left){
                    root = root->left;
                }else{
                    root = root->right;
                }
            }
            // root为当前栈顶元素的左结点
            root = st.top();
            // 弹出栈顶元素
            st.pop();
            // 加入结果数组
            ret.push_back(root->val);
            // 如果栈不为空且当前栈顶元素的左节点是刚刚跳出的栈顶元素root
            // 则转向遍历当前栈顶元素的右子树
            if(!st.empty() && st.top()->left == root){
                root = st.top()->right;
            // 否则证明当前栈顶元素无左右子树，那当前的栈顶元素弹出
            }else{
                root = nullptr;
            }
        }
        
        return ret;
    }
};
```

:::

::::

## 参考文献

[ACM 选手图解 LeetCode 二叉树后序遍历（递归 + 非递归） | 编程文青李狗蛋 - 二叉树的后序遍历 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/solution/acm-xuan-shou-tu-jie-leetcode-er-cha-shu-q9ep/)

[详细通俗的思路分析，多解法 - 二叉树的后序遍历 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by--34/)