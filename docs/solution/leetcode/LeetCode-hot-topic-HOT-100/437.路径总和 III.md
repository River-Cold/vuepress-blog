# 437.路径总和 III

https://leetcode-cn.com/problems/path-sum-iii/

![](https://cdn.jsdelivr.net/gh/River-Cold/pictureBed/vuepress-blog/docs/solution/leetcode/LeetCode-hot-topic-HOT-100/437.png)

## 方法一：递归

### 思路分析

::: tip



:::

### 参考代码

:::: code-group

::: code-group-item c++

```cpp
class Solution {
public:
    int pathSumStartWithRoot(TreeNode* root, int sum){
        if(root == NULL) return 0;
        int ret = 0;
        if(root->val == sum) ret++;
        ret += pathSumStartWithRoot(root->left, sum - root->val) + pathSumStartWithRoot(root->right, sum - root->val);
        return ret;
    }
    int pathSum(TreeNode* root, int sum) {
        if(root == NULL){
            return 0;
        }
        int ret = pathSumStartWithRoot(root, sum) + pathSum(root->left, sum) + pathSum(root->right, sum);
        return ret;
    }
};
```

:::

::::

## 方法二：前缀和

::: tip

**解题思路**：

`dfs`先序遍历二叉树

记录下根节点 $root$ 到当前节点 $p$ 的路径上除当前节点以外所有节点的前缀和

在已保存的路径前缀和中查找是否存在前缀和刚好等于当前节点到根节点的前缀

和 $curr$ 减去 $targetSum$

如果从根节点 $root$ 到当前节点 $node$ 的路径中存在节点 $pi$ 到根节点 $root$ 的前缀和为 $curr-targetSum$，则节点 $p_{i+1}$ 到 $node$ 的路径上所有节点的和一定为$targetSum$，则路径数目加1

**变量定义**：

`prefix`：key是前缀和，val是该前缀和的节点数量，记录数量是因为有可能出现重复前缀和的可能。

`targetSum`：节点值的目标总和

`curr`：根节点root到当前节点p的路径上除当前节点以外所有节点的前缀和

**理解难点**：

1. 前缀和初始化代码`prefix[0]=1`的含义？

> 以根节点开始的路径合法，可以认为有一个虚拟的根节点的父节点，其前缀和为0

2. 回溯代码`prefix[curr]--`的含义？

> 由于我们只能统计往下的路径，但是树的遍历会同时搜索两个方向的子树。因此我们应当在搜索完以某个节点为根的左右子树之后，应当回溯地将路径总和从哈希表中删除，防止统计到跨越两个方向的路径。
>
> 当我们讨论两个节点的前缀和差值时，有一个前提：一个节点必须是另一个节点的祖先节点状态恢复代码的作用就是： 在遍历完一个节点的所有子节点后，将其从map中除去。

:::

```cpp
class Solution {
public:
    unordered_map<long long, int> prefix;
    int dfs(TreeNode* root, long long curr, int targetSum){
        if(root == nullptr){
            return 0;
        }

        //ret代表和等于targetSum的路径的数目
        int ret = 0;    
        curr += root->val;

        if(prefix.count(curr - targetSum)){
            ret = prefix[curr - targetSum];
        }

        prefix[curr]++;
        ret += dfs(root->left, curr, targetSum);
        ret += dfs(root->right, curr, targetSum);
        prefix[curr]--;

        return ret;
    }

    int pathSum(TreeNode* root, int targetSum) {
        prefix[0] = 1;
        return dfs(root, 0, targetSum);
    }
};
```

:::

::::

## 参考文献

[路径总和 III - 路径总和 III - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/path-sum-iii/solution/lu-jing-zong-he-iii-by-leetcode-solution-z9td/)

[【宫水三叶】一题双解 :「DFS」&「前缀和」 - 路径总和 III - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/path-sum-iii/solution/gong-shui-san-xie-yi-ti-shuang-jie-dfs-q-usa7/)

[对前缀和解法的一点解释 - 路径总和 III - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/path-sum-iii/solution/dui-qian-zhui-he-jie-fa-de-yi-dian-jie-s-dey6/)