#  337.打家劫舍III

https://leetcode-cn.com/problems/house-robber-iii/

![](https://cdn.jsdelivr.net/gh/River-Cold/pictureBed/vuepress-blog/interview/basics/network/20220303104052.png)

## 方法一：递归+动态规划

### 思路分析

::: tip

一棵二叉树，树上的每个点有两种状态（选中和不选中），问不能同时选中有父子关系的点的情况下，能选中的点的最大权值和是多少。

用$f(o)$表示选择$o$节点的情况下，$o$节点的子树上被选择的节点的最大权值和；用$g(o)$表示不选择$o$节点的情况下，$o$节点的子树上被选择的节点的最大权值和

设$l$和$r$分别代表$o$的左右孩子

- 当$o$被选中时，$o$的左右孩子都不能被选中，故 $o$ 被选中情况下子树上被选中点的最大权值和为 $l$ 和 $r$ 不被选中的最大权值和相加

$$
f(o)=g(l)+g(r)
$$

- 当 $o$ 不被选中时，$o$ 的左右孩子可以被选中，也可以不被选中。对于 $o$ 的某个具体的孩子 $x$，它对 $o$ 的贡献是 $x$ 被选中和不被选中情况下权值和的较大值。

$$
g(o)=max\{f(l),g(l)\} + max\{f(r),g(r)\}
$$

:::

### 参考代码

:::: code-group

::: code-group-item c++

```cpp
class Solution {
public:
    unordered_map<TreeNode*, int> f, g;

    void dfs(TreeNode* root){
        if(root == nullptr){
            return;
        }
        dfs(root->left);
        dfs(root->right);
        f[root] = root->val + g[root->left] + g[root->right];
        g[root] = max(f[root->left], g[root->left]) + max(f[root->right], g[root->right]);
    }

    int rob(TreeNode* root) {
        dfs(root);
        return max(f[root], g[root]);
    }
};
```

:::

::::

## 方法二：递归+记忆化

### 思路分析

::: tip

**当前节点的最大偷钱数=max(根节点权值+4个孙子节点最大偷钱数，两个儿子节点的最大偷钱数）**

根节点权值+4个孙子节点最大偷钱数money1：
$$
root.val + rob(root.left.left)+ rob(root.left.right) + rob(root.right.left) + rob(root.right.right)
$$
两个儿子节点的最大偷钱数money2：
$$
rob(root.left)+rob(root.right)
$$
当前节点的最大偷钱数money：
$$
money = max(money1, money2)
$$
**重复子问题**

根节点在计算自己能偷多少钱的时候，同时计算了 4 个孙子节点能偷多少钱，也计算了 2 个儿子能偷多少钱。这样在儿子当爷爷时，就会产生重复计算一遍孙子节点。

因此使用哈希表来存储已经计算过的结果，使用记忆化解决重复子问题。

:::

### 参考代码

:::: code-group

::: code-group-item c++

```cpp
class Solution {
public:
    unordered_map<TreeNode*, int> memo;

    int robCore(TreeNode* root){
        if(root == nullptr){
            return 0;
        }
        if(memo.find(root) != memo.end()){
            return memo[root];
        }
        int money = root->val;
        if(root->left != nullptr){
            money += (rob(root->left->left) + rob(root->left->right));
        }

        if(root->right != nullptr){
            money += (rob(root->right->left) + rob(root->right->right));
        }
        int res = max(money, rob(root->left) + rob(root->right));
        memo[root] = res;
        return res;
    }
    int rob(TreeNode* root) {
        return robCore(root);
    }
};
```

:::

::::
