# 94.二叉树的中序遍历

https://leetcode-cn.com/problems/binary-tree-inorder-traversal/

![](https://cdn.jsdelivr.net/gh/River-Cold/pictureBed/vuepress-blog/docs/solution/leetcode/LeetCode-hot-topic-HOT-100/94.png)

## 方法一：递归法

### 思路分析

::: tip



:::

### 参考代码

:::: code-group

::: code-group-item c++

```cpp

```

:::

::::

## 方法二：迭代法

::: tip

:::

```cpp
class Solution {
public:
    // 递归的调用过程是不断往左边走，当左边走不下去了，就打印节点，并转向右边，然后右边继续这个过程。
    // 我们在迭代实现时，就可以用栈来模拟上面的调用过程。
    vector<int> inorderTraversal(TreeNode* root) {
        stack<TreeNode*> st;
        vector<int> ret;
        while(!st.empty() || root != nullptr){
            // 不断往左子树方向走，每走一次就将当前节点保存到栈中
            // 模拟递归的调用
            if(root != nullptr){
                st.push(root);
                root = root->left;
            }
            // 当前节点为空，说明左子树方向已经走到尽头，从栈中弹出节点并保存
            // 然后转向右边节点，继续上面整个过程
            else{
                TreeNode* tmp = st.top();
                st.pop();
                ret.push_back(tmp->val);
                root = tmp->right;
            }
        }
        return ret;
    }
};
```

:::

::::

## 参考文献

[动画演示+三种实现 94. 二叉树的中序遍历 - 二叉树的中序遍历 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/dong-hua-yan-shi-94-er-cha-shu-de-zhong-xu-bian-li/)