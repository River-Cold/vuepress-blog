#  64.最小路径和

https://leetcode-cn.com/problems/minimum-path-sum/

![](https://cdn.jsdelivr.net/gh/River-Cold/pictureBed/vuepress-blog/solution/leetcode/LeetCode-hot-topic-HOT-100/64.png)

## 方法一：动态规划

### 思路分析

::: tip

状态定义：$dp[i][j]$表示从左上角出发到 $(i,j)$ 位置的最小路径和

状态转移方程：

当$i>0$且$j=0$时，$dp[i][0]=dp[i-1][0]+grid[i][0]$

当$i=0$且$j>0$时，$dp[0][j]=dp[0][j-1]+grid[0][j]$

当$i>0$且$j>0$时，$dp[i][j]=min(dp[i-1][j],dp[i][j-1])+grid[i][j]$

状态边界

$dp[0][0]=grid[0][0]$

:::

### 参考代码

:::: code-group

::: code-group-item c++

```cpp
/*
第一行和第一列的值在循环外提前初始化
*/
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size();
        vector<vector<int>> dp(m, vector<int>(n));
        // 初始化边界值
        dp[0][0] = grid[0][0];
        // 第一列的值
        for(int i = 1; i < m; i++){
            dp[i][0] = dp[i - 1][0] + grid[i][0];
        }
        // 第一行的值
        for(int j = 1; j < n; j++){
            dp[0][j] = grid[0][j] + dp[0][j - 1];
        }

        for(int i = 1; i < m; i++){
            for(int j = 1; j < n; j++){
                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
            }
        }

        return dp[m - 1][n - 1];
    }
};
```

:::

::: code-group-item c++:active

```cpp
/*
第一行和第一列的值在循环的同时进行初始化
*/
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size();
        vector<vector<int>> dp(m, vector<int>(n));
        for(int i = 0; i < m; i++){
            for(int j = 0; j < n; j++){
                if(i == 0){
                    if(j >= 1){
                        dp[i][j] = dp[i][j-1] + grid[i][j];
                    }else{
                        dp[0][0] = grid[0][0];
                    }
                }else{
                    if(j >= 1){
                        dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
                    }else{
                        dp[i][j] = dp[i - 1][j] + grid[i][j];
                    }
                }
            }
        }
        return dp[m - 1][n - 1];
    }
};
```

:::

::::

## 方法二：滚动数组



### 思路分析

::: tip

**状态定义**：$dp[i][j]$表示从左上角出发到 $(i,j)$ 位置的最小路径和

由状态转移方程
$$
dp[i][j]=min(dp[i-1][j],dp[i][j-1])+grid[i][j]
$$
可知$dp[i][j]$只会从$dp[i-1][j]$（上方行的数据）或者$dp[i][j-1]$（左侧列的数据）转移得到，在循环的过程中只会使用到之前已经计算好的值，因此可以使用滚动数组进行优化，将$dp[i][j]$中的行$i$去掉，使用$dp[j]$替代。得到新的**状态转移方程**如下：

当$i>0$且$j=0$时，$dp[j]=dp[j]+grid[i][j]$

当$i=0$且$j>0$时，$dp[j]=dp[j-1]+grid[i][j]$

当$i>0$且$j>0$时，$dp[j]=min(dp[j],dp[j-1])+grid[i][j]$

**状态边界**

$dp[0]=grid[0][0]$

:::

### 参考代码

:::: code-group

::: code-group-item c++

```cpp
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size();
        vector<int> dp(n);
        for(int i = 0; i < m; i++){
            for(int j = 0; j < n; j++){
                if(i == 0){
                    if(j >= 1){
                        dp[j] = dp[j - 1] + grid[i][j]; 
                    }else{
                        dp[j] = grid[i][j];             
                    }
                }else{
                    if(j >= 1){
                        dp[j] = min(dp[j], dp[j - 1]) + grid[i][j];
                    }else{
                        dp[j] = dp[j] + grid[i][j];
                    }
                }
            }
        }
        return dp[n - 1];
    }
};
```

:::
