#  121.买卖股票的最佳时机

https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/

![](https://cdn.jsdelivr.net/gh/River-Cold/pictureBed/vuepress-blog/interview/basics/network/20220227151237.png)

## 方法一：动态规划

### 思路分析

::: tip

::: details 

考虑每次如何获取最大收益？第i天的最大收益只需要知道前i天的最低点就可以算出来了。而第i天以前（包括第i天）的最低点和i-1天的最低点有关。则设$dp[i]$代表第i天以前（包括第i天）的最低点，状态转移方程为：
$$
dp[i]=min(dp[i-1],price[i])
$$
在第$i$天能卖出股票得到的利润为
$$
prices[i]-dp[i-1]
$$
:::

### 参考代码

:::: code-group

::: code-group-item c++

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        int maxprofit = 0;

        vector<int> dp(n);
        dp[0] = prices[0];

        for(int i = 1; i < n; i++){
            dp[i] = (dp[i - 1] < prices[i]) ? dp[i - 1] : prices[i];
            maxprofit = (prices[i] - dp[i]) > maxprofit ? prices[i] - dp[i] : maxprofit;
        }
        
        return maxprofit;
    }
};
```

:::

::::

## 方法一：空间优化

### 思路分析

::: tip

::: details 

方法一的每次状态转移只使用到了$dp[i-1]$这一个空间，因此可以使用单个变量$minprice$来存储截止到第$i$天（不包括第$i$天）的价格最低点。

:::

### 参考代码

:::: code-group

::: code-group-item c++

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int inf = 1e9;
        int minprice = inf, maxprofit = 0;
        for(int price : prices){
            maxprofit = max(maxprofit, price - minprice);
            minprice = min(minprice, price);
        }
        return maxprofit;
    }
};
```

:::

::::
