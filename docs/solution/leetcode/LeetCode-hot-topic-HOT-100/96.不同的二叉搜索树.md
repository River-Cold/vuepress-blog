#  96.不同的二叉搜索树

https://leetcode-cn.com/problems/unique-binary-search-trees/

![](https://cdn.jsdelivr.net/gh/River-Cold/pictureBed/vuepress-blog/solution/leetcode/LeetCode-hot-topic-HOT-100/96.png)

## 方法一：动态规划

### 思路分析

::: tip

状态定义：

设$dp[i]$代表用连着的`i`个数，所构建出的二叉搜索树（BST）种类数，左子树用掉`j`个，则右子树用掉`i-j-1`个，能构建出$dp[j]*dp[i-j-1]$种不同的BST
$$
dp[i]=\sum{dp[j]*dp[i-j-1]},0\leq{j}\leq{i-1},2\leq{i}\leq{n}
$$
边界条件：
$$
dp[0]=dp[1]=1
$$

- 当$n=0$时，没有数字，只能形成一种BST：空树
- 当$n=1$时，只有一个数字，只能形成一种BST：单个节点

:::

### 参考代码

:::: code-group

::: code-group-item c++

```cpp
class Solution {
public:
    /*
    设dp[i]代表连着的i个数能构建的BST的个数
    dp[i]=∑dp[j]∗dp[i−j−1],0<=j<=i−1
    */
    int numTrees(int n) {
        vector<int> dp(n + 1, 0);
        dp[0] = dp[1] = 1;
        for(int i = 2; i <= n; i++){
            for(int j = 0; j < i; j++){
                dp[i] = dp[i] + dp[j] * dp[i - j - 1];
            }
        }
        return dp[n];
    }
};
```

:::

::::
