#  139.单词拆分

https://leetcode-cn.com/problems/word-break/

![](https://cdn.jsdelivr.net/gh/River-Cold/pictureBed/vuepress-blog/solution/leetcode/LeetCode-hot-topic-HOT-100/139.png)

## 方法一：字典树+dfs+记忆化

### 思路分析

::: tip

设字符串s的长度为n，单词列表wordDict的长度为m，单词列表中每个单词的最大长度为len

首先暴力的想法是枚举字符串s的从起点startPos开始截取的所有可能子串，将子串和wordDict中的单词一一匹配，成功则继续递归搜索，直到搜索到s的末尾时结束。但是这样的时间复杂度最坏会达到$O(n^2*m*len)$，会产生TLE超时错误。

根据提示中s和WordDict[i]仅有小写英文字母组成，我们可以想到使用字典树`trie`来进行单词的快速查找，这样可以将时间复杂度降到$O(n^2*len)$，但是当面对类似下面的

```
"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab"
["a","aa","aaa","aaaa","aaaaa","aaaaaa","aaaaaaa","aaaaaaaa","aaaaaaaaa","aaaaaaaaaa"]
```

测试用例时仍然会产生超时错误，这是因为在搜索过程中如果匹配失败返回之后会产生很多的重复判断，此时需要使用记忆化数组`failMemo`来记录dfs没有匹配成功时对应的s中的index

:::

### 参考代码

:::: code-group

::: code-group-item c++

```cpp
class Trie{
public:
    Trie* next[26];
    bool isEnd;
    Trie(){
        memset(next, 0, sizeof(next));
        isEnd = false;
    }
    void insert(string word){
        Trie* node = this;
        for(char ch : word){
            if(node->next[ch - 'a'] == NULL){
                node->next[ch - 'a'] = new Trie();
            }
            node = node->next[ch - 'a'];
        }
        node->isEnd = true;
    }
};
class Solution {
    Trie* root;
    int failMemo[301];  //记录dfs中失败时对应的s中的index
public:
    bool dfs(string &s, int startPos){
        if(failMemo[startPos] == 1){
            return false;
        }
        if(startPos == s.size()){
            return true;
        }
        Trie* node = root;
        for(int i = startPos; i < s.size(); i++){
            char ch = s[i];
            if(node->next[ch - 'a'] != NULL){
                node = node->next[ch - 'a'];
                if(node->isEnd == true && dfs(s, i + 1)){
                    return true;
                }
            }else{
                break;
            }
        }
        failMemo[startPos] = 1;
        return false;
    }
    bool wordBreak(string s, vector<string>& wordDict) {
        root = new Trie();
        // 建立字典树
        for(auto && word : wordDict){
            root->insert(word);
        }
        return dfs(s, 0);
    }
};
```

:::

::::

## 方法二：动态规划

### 思路分析

::: tip

状态定义:

$dp[i]$表示字符串s前i个字符组成的字符串$s[0...i-1]$是否能被空格拆分成若干个字典中出现的单词

$check(s)$表示判断子串s是否出现在字典中

状态转移方程:
$$
dp[i] = dp[j] \&\& check(s[j...i-1])
$$
边界条件：
$$
dp[0]=true
$$
:::

### 参考代码

:::: code-group

::: code-group-item c++

```cpp
class Solution {
public:
    /*

    */
    bool wordBreak(string s, vector<string>& wordDict) {
        auto wordDictSet = unordered_set<string>();
        for(auto word : wordDict){
            wordDictSet.insert(word);
        }

        auto dp = vector<bool>(s.size() + 1);
        dp[0] = true;   //表示空串且合法
        for(int i = 1; i <= s.size(); i++){
            for(int j = 0; j < i; j++){
                if(dp[j] && wordDictSet.count(s.substr(j, i - j))){
                    dp[i] = true;
                    break;
                }
            }
        }

        return dp[s.size()];
    }
};
```

:::

::::
