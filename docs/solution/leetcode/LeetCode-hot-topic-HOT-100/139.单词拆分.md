#  139.单词拆分

https://leetcode-cn.com/problems/word-break/

![](https://cdn.jsdelivr.net/gh/River-Cold/pictureBed/vuepress-blog/interview/basics/network/20220228105707.png)

## 方法一：字典树+dfs+记忆化

### 思路分析

::: tip

::: details 

设字符串s的长度为n，单词列表wordDict的长度为m，单词列表中每个单词的最大长度为len

首先暴力的想法是枚举字符串s的从起点startPos开始截取的所有可能子串，将子串和wordDict中的单词一一匹配，成功则继续递归搜索，直到搜索到s的末尾时结束。但是这样的时间复杂度最坏会达到$O(n^2*m*len)$，会产生TLE超时错误。

根据提示中s和WordDict[i]仅有小写英文字母组成，我们可以想到使用字典树`trie`来进行单词的快速查找，这样可以将时间复杂度降到$O(n^2*len)$，但是当面对类似下面的

```
"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab"
["a","aa","aaa","aaaa","aaaaa","aaaaaa","aaaaaaa","aaaaaaaa","aaaaaaaaa","aaaaaaaaaa"]
```

测试用例时仍然会产生超时错误，这是因为在搜索过程中会产生很多的重复判断，此时需要使用记忆化数组`failMemo`来记录dfs没有匹配成功时对应的s中的index

:::

### 参考代码

:::: code-group

::: code-group-item c++

```cpp
class Trie{
public:
    Trie* next[26];
    bool isEnd;
    Trie(){
        memset(next, 0, sizeof(next));
        isEnd = false;
    }
    void insert(string word){
        Trie* node = this;
        for(char ch : word){
            if(node->next[ch - 'a'] == NULL){
                node->next[ch - 'a'] = new Trie();
            }
            node = node->next[ch - 'a'];
        }
        node->isEnd = true;
    }
};
class Solution {
    Trie* root;
    int failMemo[301];  //记录dfs中失败时对应的s中的index
public:
    bool dfs(string &s, int startPos){
        if(failMemo[startPos] == 1){
            return false;
        }
        if(startPos == s.size()){
            return true;
        }
        Trie* node = root;
        for(int i = startPos; i < s.size(); i++){
            char ch = s[i];
            if(node->next[ch - 'a'] != NULL){
                node = node->next[ch - 'a'];
                if(node->isEnd == true && dfs(s, i + 1)){
                    return true;
                }
            }else{
                break;
            }
        }
        failMemo[startPos] = 1;
        return false;
    }
    bool wordBreak(string s, vector<string>& wordDict) {
        root = new Trie();
        // 建立字典树
        for(auto && word : wordDict){
            root->insert(word);
        }
        return dfs(s, 0);
    }
};
```

:::

::::

## 方法二：动态规划

### 思路分析

::: tip

::: details 



:::

### 参考代码

:::: code-group

::: code-group-item c++

```cpp

```

:::

::::
