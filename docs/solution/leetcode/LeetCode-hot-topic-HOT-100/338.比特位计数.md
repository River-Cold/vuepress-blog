# 338.比特位计数

https://leetcode-cn.com/problems/counting-bits/

![](https://cdn.jsdelivr.net/gh/River-Cold/pictureBed/vuepress-blog/solution/leetcode/LeetCode-hot-topic-HOT-100/338.png)

## 方法一：位运算+动态规划

### 思路分析

::: tip

**位运算技巧**

$n\&(n-1)$可以把 $n$ 的二进制中，最后一个出现的1改写成0，即消除 $n$ 的二进制中最后一个出现的1

因为执行 $n\&(n-1)$ 使得 $n$ 变成 0 的操作次数，就是 $n$ 的二进制中 1 的个数

![](https://cdn.jsdelivr.net/gh/River-Cold/pictureBed/vuepress-blog/solution/leetcode/LeetCode-hot-topic-HOT-100/338-1.png)

**动态规划**

**状态定义**：

设$bits[i]$代表以数字i二进制中1的个数

**状态转移方程**：

令 $y=x\&(x-1)$，则 $y$ 为将 $x$ 的最低位1改写成0之后的数，显然 $0\leq{y}\leq{x}$，$bits[x]=bits[y]+1$。
$$
bits[i]=bits[i\&(i-1)]+1
$$
**边界值**：
$$
bits[0]=0
$$
:::

### 参考代码

:::: code-group

::: code-group-item c++

```cpp
class Solution {
public:
    vector<int> countBits(int n) {
        vector<int> bits(n + 1);
        for (int i = 1; i <= n; i++) {
            bits[i] = bits[i & (i - 1)] + 1;
        }
        return bits;
    }
};
```

:::

::::

### 参考文献

[【负雪明烛】详解位运算，附本题躲坑指南 - 位1的个数 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/number-of-1-bits/solution/fu-xue-ming-zhu-xiang-jie-wei-yun-suan-f-ci7i/)

[比特位计数 - 比特位计数 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/counting-bits/solution/bi-te-wei-ji-shu-by-leetcode-solution-0t1i/)