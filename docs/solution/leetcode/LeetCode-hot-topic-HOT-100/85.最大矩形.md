#  85.最大矩形

https://leetcode-cn.com/problems/minimum-path-sum/

![](https://cdn.jsdelivr.net/gh/River-Cold/pictureBed/vuepress-blog/solution/leetcode/LeetCode-hot-topic-HOT-100/85.png)

## 方法一：使用柱状图的优化暴力方法

### 思路分析

::: tip

用$left[i][j]$记录矩阵第$i$行第$j$列元素的左边的连续1的数量

对于矩阵中任意一个点，枚举以该点为右下角的全1矩形

当考察以$matrix[i][j]$为右下角的矩形时，枚举满足$0<=k<=i$的所有可能的$k$，此时矩阵的最大宽度为下列值中的最小值
$$
min\{left[i][j],left[i-1][j],...,left[k][j]\}
$$
:::

### 参考代码

:::: code-group

::: code-group-item c++

```cpp
class Solution {
public:
    int maximalRectangle(vector<vector<char>>& matrix) {
        int m = matrix.size();
        if(m == 0){
            return 0;
        }
        int n = matrix[0].size();
        vector<vector<int>> left(m, vector<int>(n, 0));
        // 初始化left数组
        for(int i = 0; i < m; i++){
            for(int j = 0; j < n; j++){
                if(matrix[i][j] == '1'){
                    left[i][j] = (j == 0 ? 0 : left[i][j - 1]) + 1;
                }
            }
        }

        int ret = 0;
        for(int i = 0; i < m; i++){
            for(int j = 0; j < n; j++){
                if(matrix[i][j] == '0'){
                    continue;
                }
                int width = left[i][j];
                int area = width;
                for(int k = i - 1; k >= 0; k--){
                    width = min(width, left[k][j]);
                    area = max(area, (i - k + 1) * width);
                }
                ret = max(ret, area);
            }
        }
        return ret;
    }
};
```

:::

::::
