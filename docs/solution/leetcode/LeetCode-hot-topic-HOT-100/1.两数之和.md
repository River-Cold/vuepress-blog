#  [1.两数之和](https://leetcode-cn.com/problems/two-sum/)

![](https://cdn.jsdelivr.net/gh/River-Cold/pictureBed/vuepress-blog/solution/leetcode/LeetCode-hot-topic-HOT-100/1.png)

## 方法一：哈希表

::: tip

创建一个哈希表，对于每一个 `x`，我们首先查询哈希表中是否存在 `target - x`，然后将 `x` 插入到哈希表中，即可保证不会让 `x` 和自己匹配。

:::

## 参考代码

:::: code-group

::: code-group-item c++

```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        // 使用map记录所有出现过的数字最后一次出现的下标
        unordered_map<int, int> dic;
        for(int i = 0; i < nums.size(); i++){
            dic[nums[i]] = i;
        }
        // 然后查找target - num的元素是否在map中出现过
        for(int i = 0; i < nums.size(); i++){
            int num2 = target - nums[i];
            // 如果出现过，则返回两个元素的数组下标
            if(dic[num2] && dic[num2] != i){
                return {i, dic[num2]};
            }
        }
        return {};
    }
};
```

:::

::: code-group-item c++:active

```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        int n = nums.size();
        // 使用map记录所有出现过的数字出现的下标
        unordered_map<int, int> dic;
        for(int i = 0; i < n; i++){
            int num = target - nums[i];
            // 查询哈希表中是否存在 target - nums[i]，若存在直接返回下标
            if(dic.find(num) != dic.end()){
                return {i, dic[num]};
            }
            // 如果不存在则将当前元素和其下标插入哈希表
            dic[nums[i]] = i;
        }
        return {};
    }
};
```

:::

::::

