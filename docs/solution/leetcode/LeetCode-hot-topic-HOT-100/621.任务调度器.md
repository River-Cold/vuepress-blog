# 621.任务调度器

https://leetcode-cn.com/problems/task-scheduler/

![](https://cdn.jsdelivr.net/gh/River-Cold/pictureBed/vuepress-blog/docs/solution/leetcode/LeetCode-hot-topic-HOT-100/621.png)

## 方法一：桶排序

### 思路分析

::: tip



:::

### 参考代码

:::: code-group

::: code-group-item c++

```cpp
class Solution {
public:
    int leastInterval(vector<char>& tasks, int n) {
        int len = tasks.size();
        vector<int> vec(26);
        for(char ch : tasks){
            ++vec[ch - 'A'];
        }
        sort(vec.begin(), vec.end(), greater<int>());
        int cnt = 1;
        // 统计任务数量并列最多的任务有多少个，即最后一个桶的任务数X
        while(cnt < vec.size() && vec[cnt] == vec[0]){
            cnt++;
        }
        return max(len, cnt + (n + 1) * (vec[0] - 1));
    }
};
```

:::

::::

## 方法二：优先队列

::: tip

**选择不在冷却中并且剩余执行次数最多的任务优先执行**。

- 每执行完一个任务，将剩下的所有任务按照执行时间升序排列，剩余执行次数降序排列。使用一个优先队列来维护所有任务的优先级。
- 取出队首任务，判断当前任务的执行时间是否小于当前时间
  - 小于则判断剩余执行次数是否大于1
    - 大于则剩余执行次数-1，计算出下一次执行时间，将新的任务加入队列
  - 否则当前时间+1

**下一次执行时间**：两个相同任务之间必须有 $n$ 的冷却，因此每个任务执行完成之后需要等到 $n+1$ 个时间单位之后才能执行，即 `task.nextTime = task.nextTime + n + 1`

**剩余执行次数**：如果大于1则等于当前执行次数-1，即`task.restTaskNum=task.restTaskNum-1`

:::

```cpp
class Solution {
public: 
    class Task{
        public:
            int nextTime;
            int restTaskNum;
            Task(int nextTime, int restTaskNum){
                this->nextTime = nextTime;
                this->restTaskNum = restTaskNum;
            }
            friend bool operator < (Task t1, Task t2){
                // 按照下一次执行时间升序，任务数降序
                if(t1.nextTime == t2.nextTime){
                    return t1.restTaskNum < t2.restTaskNum;
                }
                return t1.nextTime > t2.nextTime;
            }
    };

    int leastInterval(vector<char>& tasks, int n) {
        vector<int> TaskNum(26, 0);
        for(char ch : tasks){
            ++TaskNum[ch - 'A'];
        }    
        // 定义优先队列
        priority_queue<Task, vector<Task>> pq;
        // 初始化优先队列
        for(int tasknum : TaskNum){
            if(tasknum == 0)
                continue;
            Task newTask(0, tasknum);
            pq.push(newTask);
        }
        // 计算任务调度
        int time = 0;
        while(!pq.empty()){
            auto top = pq.top();
            if(top.nextTime <= time){
                pq.pop();
                if(top.restTaskNum > 1){
                    top.restTaskNum--;
                    top.nextTime = top.nextTime + n + 1;
                    pq.push(top);
                }
            }
            time++;
        }

        return time;
    }
};
```

:::

::::

## 参考文献

[【任务调度器】C++ 桶子_配图理解 - 任务调度器 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/task-scheduler/solution/tong-zi-by-popopop/)

[Python 详解 - 任务调度器 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/task-scheduler/solution/python-xiang-jie-by-jalan/)

[最小堆、小顶堆：剩余次数和冷却时间 24ms 超官方一 - 任务调度器 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/task-scheduler/solution/by-sixiermu-ahl4/)