# 647.回文子串

https://leetcode-cn.com/problems/sort-list/

![](https://cdn.jsdelivr.net/gh/River-Cold/pictureBed/vuepress-blog/docs/solution/leetcode/LeetCode-hot-topic-HOT-100/148.png)



## 方法一：自顶向下归并排序

### 思路分析

::: tip

**递归过程**：

1. **分割**：找到链表的`中间节点`，以`中点`为分界，将链表拆分成两个子链表，寻找两个子链表的`中点`可以用快慢指针的方法
2. **递归**：然后对两个子链表分别排序
3. **合并**：将两个排序后的子链表合并，得到完整的排序后的链表

**递归终止条件**：

链表的节点个数小于或等于1，即当链表为空或者链表只包含1个节点时，不需要对链表进行拆分和排序。

在分割操作中，**快慢指针的方法**有两种：

**方法1**：指向中间节点的后一个节点

1. 初始时快指针`fast`和慢指针`slow`初始时都指向头结点
2. 快指针`fast`每次移动2步，慢指针`slow`每次移动1步
3. 当快指针`fast`到达链表末尾时，慢指针`slow`指向的链表节点即为链表的中点 

**方法2**：指向中间节点的前一个节点

1. 初始时快指针`fast`指向头结点的下一个节点，慢指针`slow`指向头结点
2. 快指针`fast`每次移动2步，慢指针`slow`每次移动1步
3. 当快指针`fast`到达链表末尾时，慢指针`slow`指向的链表节点即为链表的中点（其中奇数个节点直接找到最中间的那个点，偶数个节点找到中心两个节点左边的节点）

以偶数个节点链表`[4,2,1,3]`为例，方法1中的慢指针`slow`最终指向的中点是1，方法2中的慢指针`slow`最终指向的中点是2

以奇数个节点链表`[-1,5,3,4,0]`为例，方法1中的慢指针`slow`分割操作后指向的中点是3，方法2中的慢指针`slow`分割操作后指向的中点是3

:::

### 参考代码

:::: code-group

::: code-group-item c++

```cpp
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        return sortList(head, nullptr);
    }

    ListNode* sortList(ListNode* head, ListNode* tail){
        if(head == nullptr){
            return head;
        }
        if(head->next == tail){
            head->next = nullptr;
            return head;
        }
        // 慢指针每次移动2步，慢指针每次移动1步
        ListNode* slow = head, *fast = head;
        // 找到链表的中点
        while(fast != tail){
            slow = slow->next;
            fast = fast->next;
            if(fast != tail){
                fast = fast->next;
            }
        }
        ListNode* mid = slow;
        // 对两个排序后的子链表合并
        return merge(sortList(head, mid), sortList(mid, tail));
    }
    // 归并排序
    ListNode* merge(ListNode* head1, ListNode* head2){
        ListNode* dummy = new ListNode(0);
        ListNode* ret = dummy;
        while(head1 && head2){
            if(head1->val < head2->val){
                dummy->next = head1;
                head1 = head1->next;
            }else{
                dummy->next = head2;
                head2 = head2->next;
            }
            dummy = dummy->next;
        }
        if(head1){
            dummy->next = head1;
        }
        if(head2){
            dummy->next = head2;
        }
        return ret->next;
    }
};
```

:::

::: code-group-item c++

```cpp
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        // 链表为空或者只剩下一个节点时，直接返回head
        if(head == nullptr || head->next == nullptr){
            return head;
        }
        ListNode* slow = head, *fast = head->next;
        while(fast != nullptr && fast->next != nullptr){
            slow = slow->next;
            fast = fast->next->next;
        }
        ListNode* tmp = slow->next;
        slow->next = nullptr;
        ListNode* left = sortList(head);
        ListNode* right = sortList(tmp);
        return merge(left, right);
    }
    ListNode* merge(ListNode* head1, ListNode* head2){
        ListNode* ret = new ListNode(0);
        ListNode* dummy = ret;
        while(head1 && head2){
            if(head1->val < head2->val){
                dummy->next = head1;
                head1 = head1->next;
            }else{
                dummy->next = head2;
                head2 = head2->next;
            }
            dummy = dummy->next;
        }
        dummy->next = head1 ? head1 : head2;
        return ret->next;
    }
};
```

:::

::::

## 方法二：自底向上归并排序

::: tip

:::

```cpp

```

:::

::::

## 参考文献

[排序链表 - 排序链表 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/sort-list/solution/pai-xu-lian-biao-by-leetcode-solution/)

[Sort List （归并排序链表） - 排序链表 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/sort-list/solution/sort-list-gui-bing-pai-xu-lian-biao-by-jyd/)