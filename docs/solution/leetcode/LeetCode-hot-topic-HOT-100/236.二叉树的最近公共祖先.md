#  236.二叉树的最近公共祖先

https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/

![](https://cdn.jsdelivr.net/gh/River-Cold/pictureBed/vuepress-blog/docs/solution/leetcode/LeetCode-hot-topic-HOT-100/236.png)

## 方法一：递归

### 思路分析

::: tip

定义子问题：$f$ 表示左右子树分别包含`p,q`

定义 $f_{x}$ 表示 $x$ 节点的子树中是否包含 $p$ 节点或 $q$ 节点，如果包含为 `true`，否则为`false`。

符合条件的最近公共祖先 `x` 一定满足条件：
$$
(f_{lson}\&\&f_{rson})||(x==p||x==q)\&\&(f_{lson}||f_{rson})
$$
其中 $lson$ 和 $rson$ 分别代表 $x$ 节点的左孩子和右孩子。

- $(f_{lson}\&\&f_{rson})$ 说明左子树和右子树均包含 $p$ 节点或 $q$ 节点
- $(x==p||x==q)\&\&(f_{lson}||f_{rson})$说明 $x$ 恰好是 $p$ 节点或 $q$ 节点且它的左子树或右子树有一个包含了另一个节点的情况

:::

### 参考代码

:::: code-group

::: code-group-item c++

```cpp
class Solution {
public:
    TreeNode* ans;
    bool dfs(TreeNode* root, TreeNode* p, TreeNode* q){
        if(root == nullptr){
            return false;
        }
        bool flson = dfs(root->left, p, q);
        bool frson = dfs(root->right, p, q);
        if((flson && frson) || (root->val == p->val || root->val == q->val) && (flson || frson)){
            ans = root;
        }
        return root->val == p->val || root->val == q->val || flson || frson;
    }
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(root == nullptr){
            return nullptr;
        }
        dfs(root, p, q);
        return ans;
    }
};
```

:::

::::

## 参考文献

[二叉树的最近公共祖先 - 二叉树的最近公共祖先 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/solution/er-cha-shu-de-zui-jin-gong-gong-zu-xian-by-leetc-2/)