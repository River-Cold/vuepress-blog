# 416.分割等和子集

https://leetcode-cn.com/problems/partition-equal-subset-sum/

![](https://cdn.jsdelivr.net/gh/River-Cold/pictureBed/vuepress-blog/solution/leetcode/LeetCode-hot-topic-HOT-100/416.png)

## 方法一：DFS+记忆化

### 思路分析

::: tip

记忆化搜索：哈希表的键定义为`index`和`cur`的组合来保证其唯一性，`key=to_string(index)+'_'+to_string(cur)`

:::

### 参考代码

:::: code-group

::: code-group-item c++

```cpp
class Solution {
public:
    unordered_map<string, bool> dic;
    bool dfs(int index, int cur, vector<int>& nums){
        if(cur < 0){
            return false;
        }
        if(cur == 0){
            return true;
        }
        if(index == nums.size()){
            return false;            
        }
        string s = to_string(index) + "_" + to_string(cur);
        if(dic.find(s) != dic.end()){
            return dic[s];
        }
        dic[s] = dfs(index + 1, cur - nums[index], nums) || dfs(index + 1, cur, nums);
        return dic[s];
    }
    bool canPartition(vector<int>& nums) {
        int n = nums.size();
        int sum = 0;
        int maxnum = 0;
        for(int num : nums){
            sum += num;
            maxnum = max(maxnum, num);
        }
        if(sum % 2 != 0){
            return false;
        }
        if(maxnum * 2 > sum){
            return false;
        }
        return dfs(0, sum / 2, nums);
    }
};
```

:::

::: code-group-item c++

```cpp
class Solution {
public:
    vector<int> dp;
    bool dfs(vector<int>& nums, int cur, int idx){
        if(cur < 0){
            return false;
        }
        if(cur == 0){
            return true;
        }
        if(dp[cur] != 0){
            return dp[cur] == 1 ? true : false;
        }
        bool find = false;
        for(int i = idx; i < nums.size(); i++){
            find |= dfs(nums, cur - nums[i], i + 1);
            if(find){
                break;
            }
        }
        dp[cur] = find ? 1 : -1;
        return find;
    }
    bool canPartition(vector<int>& nums) {
        int sum = 0;
        int maxnum = 0;
        for(int num : nums){
            sum += num;
            maxnum = max(maxnum, num);
        }
        if(sum % 2 != 0){
            return false;
        }
        if(maxnum * 2 > sum){
            return false;
        }
        dp.resize(sum / 2 + 1, 0);
        return dfs(nums, sum / 2, 0);
    }
};
```

:::

::::

## 方法二：动态规划

::: tip

**状态定义**：

 设`dp[i][j]`代表从数组的`[0,i]`下标范围内选取若干个正整数（可以是0个） 是否存在一种选取方案使得被选取的正整数的和等于j。初始时，`dp`中的全部元素都是`false`

**求解值**：
$$
dp[n-1][target]
$$
**状态转移方程**：
$$
dp[i][j]= 
\begin{cases}
dp[i-1][j] \ | \  
dp[i-1][j-nums[i]],&j\geq{nums[i]} \\ 
dp[i-1][j],&j<nums[i]
\end{cases}
$$
**边界条件**：

- 如果不选取任何正整数，则被选取的正整数等于0，因此对于所有 $0\leq{i}<{n}$，都有 $dp[i][0]=true$
- 当 $i==0$ 时，只有一个正整数 $nums[0]$ 可以被选取，因此 $dp[0][nums[0]]=true$

:::

```cpp
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int n = nums.size();
        int sum = 0, maxnum = 0;
        for(int num : nums){
            maxnum = max(maxnum, num);
            sum += num;
        }
        if(sum % 2 == 1){
            return false;
        }
        if(maxnum > (sum / 2)){
            return false;
        }
        int tar = sum / 2;
        vector<vector<int>> dp(n + 1, vector<int>(tar + 1, false));
        dp[0][0] = true;
        for(int i = 1; i <= n; i++){
            for(int j = 0; j <= tar; j++){
                dp[i][j] = dp[i - 1][j];
                if(j >= nums[i - 1]){
                    dp[i][j] |= dp[i - 1][j - nums[i - 1]];
                }
                if(j == tar){
                    if(dp[i][j]){
                        return true;
                    }
                }
            }
        }
        return false;
    }
};
```

:::

::::

## 参考文献

[提供我的一个写动态规划问题的思路 - 分割等和子集 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/partition-equal-subset-sum/solution/ti-gong-wo-de-yi-ge-xie-dong-tai-gui-hua-44n4/)

[分割等和子集 - 分割等和子集 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/partition-equal-subset-sum/solution/fen-ge-deng-he-zi-ji-by-leetcode-solution/)