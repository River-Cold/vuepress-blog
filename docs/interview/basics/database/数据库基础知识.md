# 数据库知识手册

## 数据库基础概念

### 什么是数据库？数据库管理系统？数据库系统？数据库管理员？

::: details answer

**数据库**：数据库（Database）是保存有组织的数据的容器（通常是一个文件或一组文件），是通过数据库管理系统（DataBase-Management System，DBMS）创建和操纵的容器。

**数据库管理系统**：一种操纵和管理数据库的大型软件，（DataBase Management System，简称DBMS）。

**数据库系统**：数据库系统（DataBase System，简称DBS）通常由软件、数据库（DataBase）和数据库管理员（DBA）组成。其软件主要包括操作系统、宿主语言、实用程序以及数据库管理系统。

**数据库管理员**：数据库管理员（Database Administrator，简称DBA）负责全面管理和控制数据库系统。

:::  

### 为什么要使用数据库？

::: details answer

1. 数据可永久保存且数据安全性高
2. 使用SQL语句，查询方便效率高
3. 便于数据管理和数据分析

::: 

### SQL和MySQL有什么区别？

::: details answer

SQL是一种结构化查询语言，用于在数据库上执行各种操作。

MySQL是一个关系型数据库管理系统（RDBMS），使用SQL执行所有数据库操作。

::: 

### 数据库三大范式是什么？

::: details answer

数据库范式是设计数据库时，需要遵循的一些规范。越高的范式数据库冗余越小。常用的数据库三大范式为：

- **第一范式（1NF）：**每个列都不可以再拆分，强调列的原子性。第一范式要求数据库中的表都是二维表。
- **第二范式（2NF）：**在第一范式的基础上，一个表必须有一个主键，非主键列（非主属性）**完全依赖**于主键，而不能是依赖于主键的一部分。
- **第三范式（3NF）：**在第二范式的基础上，非主键列（非主属性）只依赖于（直接依赖）于主键，不依赖于其他非主键。

**函数依赖（functional dependency）**：在一张表中，在属性（或属性组）X的值确定的情况下，必定能确定属性Y的值，那么就可以说Y函数依赖于X，写作X->Y。

**部分函数依赖（partial functional dependency）**：如果X->Y，并且存在X的一个真子集X0，使得X0->Y，则称Y对X部分函数依赖。

**完全函数依赖（fully functional dependency）**：在一个关系中，若某个非主属性数据项依赖于全部关键字则称为完全函数依赖。

**传递函数依赖（transitive functional dependency）**：在关系模式R (U) 中, 如果X→Y, Y→Z, Z不是Y的子集, Y不函数决定X, 则称Z对X传递函数依赖 (Transitive Functional Dependency) 。

**总结**

- 1NF：属性不可再分
- 2NF：1NF的基础之上，消除了非主属性对于码的部分函数依赖
- 3NF：2NF的基础之上，消除了非主属性对于码的传递函数依赖

::: 

### 什么是ER图？

::: details answer

**E-R图** 也称为实体-联系图（Entity Relationship Diagram），提供了表示实体类型、属性和联系的方法，用来描述现实世界的概念模型。

**矩形框**：表示实体

**菱形框**：表示联系

**椭圆形框**：表示实体或联系的属性

下图是一个学生选课的 ER 图，每个学生可以选若干门课程，同一门课程也可以被若干人选择，所以它们之间的关系是多对多（M: N）。另外，还有其他两种关系是：1 对 1（1:1）、1 对多（1: N）。

![ER图示例](https://img-blog.csdnimg.cn/img_convert/4717673e36966e0e4b33fccfd753f6ea.png)

:::

### 数据库设计通常分为哪几步？

::: details answer

1. **需求分析**：分析用户需求，包括数据、功能和性能需求
2. **概念结构设计**：主要采用E-R模型进行设计，包括画E-R图

3. **逻辑结构设计**：通过将E-R图转换成表，实现从E-R模型到关系模型的转换
4. **物理结构设计**：为所设计的数据库选择合适的存储结构和存取路径
5. **数据库实施**：包括编程、测试和试运行
6. **数据库的运行和维护**：系统的运行与数据库的日常维护

:::

## 索引

### 索引的优缺点

::: details answer

**索引的优点**

- 通过创建**唯一性索引**，可以**保证每一行数据的唯一性**；
- 加快数据的**检索速度**
- 加速**表与表之间的连接**

**索引的缺点**

- 时间上，创建和维护索引都需要耗费时间，这种时间随数据量增加而增加
- 空间上，索引需要占**物理空间**，除了数据表占数据空间外，每个索引还要占一定的物理空间，如果要建立聚簇索引，需要的空间就更大。

::: 

### 索引的数据结构有哪些？

::: details answer

数据库索引按照结构分类，主要有**B树索引、Hash索引和位图索引**三种

**B树索引**

又称**平衡树索引**。以树结构组织，有一个或多个分支结点，分支结点又指向单级叶结点。其中分支结点用于遍历树，叶结点则保存真正的值和位置信息。

**Hash索引**

哈希索引采取一定的哈希算法（常见哈希算法有直接定址法，平方取中法，折叠法，除数取余法，随机数法），将数据库字段转换成定长的Hash值，与这条数据的行指针一并存入Hash表的对应位置，如果发生Hash冲突（两个不同关键字的Hash值相同），则在对应Hash键下以链表形式存储。

**位图索引**

位图索引为存储在某列中的每一个值生成一个位图。位图索引适合只有几个固定值的列，需要注意位图索引适合静态数据，不适合索引频繁更新的列。

::: 

### B树的特点

::: details answer

![](https://cdn.jsdelivr.net/gh/River-Cold/vuepress-theme-hope-image/img/B-树.png)

B树是所有结点的平衡因子均等于0的多路平衡查找树

- 每个节点最多m个子结点（m棵子树），即**至多含有$m-1$个关键字**
- 如果根节点没有关键字就没有子树，此时B树为空；如果根节点有关键字，则其子树必然大于等于两棵
- 除了根节点和叶子结点外，每个结点至少有$\lceil{m/2\rceil}$（向上取整）个子结点
- 所有叶子结点位于同一层，按照关键字大小顺序排列
- 每个节点既存放关键字信息也存放具体数据

:::

### B+树的特点

::: details answer

B+ 树是在 B 树基础上的一种优化，使其更适合实现存储索引结构。

![](https://cdn.jsdelivr.net/gh/River-Cold/vuepress-theme-hope-image/img/B+树.png)

- 每个节点最多m个子结点（m棵子树），即**至多含有$m$个关键字**
- 如果根节点没有关键字就没有子树，此时B树为空；如果根节点有关键字，则其子树必然大于等于两棵
- 除了根节点和叶子结点外，每个结点至少有$\lceil{m/2\rceil}$（向上取整）个子结点
- 所有叶子结点位于同一层，按照关键字大小顺序排列，**并且相邻叶结点之间有一个链指针**
- 非叶结点只起到索引作用，只存放关键字，不存放数据，只有叶子结点既存放关键字也存放数据

:::

### B+树和B-树的区别？

::: details answer

- B树每个节点的子节点个数=关键字个数+1，B+树每个节点的子节点个数=关键字个数
- B树的相邻叶结点都是独立的，B+树的相邻叶结点之间有链指针
- B树的每个节点既存放关键字也存放数据，B+树的非叶结点只起到索引作用，只存放关键字，不存放数据，只有叶子结点既存放关键字也存放数据

:::

### 使用B+树的好处?

::: details answer

**更少的IO次数**：B+树的内部结点只存放键，不存放值，因此，一次读取，可以在同一内存页中获取更多的键，有利于更快的缩小查找范围。

**更适用于范围查询：**B+树的叶结点由一条链相连，因此当需要进行一次**全数据遍历**的时候，B+树只需要使用$O(logN)$时间找到最小结点，然后通过链进行$O(N)$的顺序遍历即可。或者在找**大于某个关键字或者小于某个关键字的数据**的时候，B+树只需要找到该关键字然后沿着链表遍历即可。

::: 

### Hash索引和B+树索引的区别？

::: details answer

- **范围查询：**Hash索引不支持范围查询，B+树支持范围查询
- **排序：**Hash索引不支持排序，B+树索引支持排序，因为Hash索引指向的数据是无序的，而B+树索引指向的数据是有序的
- **模糊查询和最左前缀匹配：**Hash索引不支持模糊查询以及多列索引的最左前缀匹配，原因是Hash函数的不可预测，AAAA和AAAAB的索引没有相关性，B+树索引支持模糊查询以及多列索引的最左前缀匹配
- **查询效率：**Hash索引虽然在等值查询上较快，但是不稳定，当某个键值存在大量重复的时候，发生Hash碰撞，此时效率可能极差；B+树的查询效率比较稳定，对于所有的查询都是从根节点到叶子结点，且树的高度较低

:::

### 什么是前缀索引？

::: details answer

有时需要索引很长的字符列，它会使索引变大且变慢，一个策略就是使用索引开始的几个字符，而不是全部值，即被称为**前缀索引**，以节约空间并获得好的性能。

:::

### 什么是联合索引？

::: details answer

联合索引就是由两个或以上的字段共同构成的索引。

:::

### 什么是最左前缀匹配原则？

::: details answer

在MySQL建立联合索引（多列索引）时会遵循最左前缀匹配原则，即**最左优先**，在检索数据时从联合索引的最左边一列开始匹配（也就是where子句中一定要有联合索引的第一个字段，并且where子句中字段的顺序可以任意调整）。

例如有一个3列索引（a,b,c），则已经对(a)、(a,b)、(a,b,c)上建立了索引。所以在创建**多列索引**时，要根据业务需求，`where`子句中使用最频繁的一列放在最左边。

**根据最左前缀匹配原则，MySQL 会一直向右匹配直到遇到 范围查询（>、<、between、like）就停止匹配，**比如采用查询条件 where a = 1 and b = 2 and c > 3 and d = 4 时，如果建立（a,b,c,d）顺序的索引，d 是用不到索引的，如果建立（a,b,d,c）的索引则都可以用到，并且 where 子句中 a、b、d 的顺序可以任意调整。

:::

### 添加索引的原则

::: details answer

- **在查询中很少使用或者参考的列不要创建索引：**由于这些列很少使用到，增加索引反而会降低系统的维护速度和增大空间需求。
- **只有很少数据值的列不创建索引：**区分度太低，增加索引并不能明显加快检索速度
- **修改性能远远大于检索性能时，不应该创建索引**：二者相互矛盾，当增加索引时，会提高索引性能，但是会降低修改性能。
- **定义为外键的数据列一定要创建索引**：如果不加索引，则删除主表记录或主子表关联查询，都会进行字表的全表扫描。

:::

### 聚集索引和非聚集索引

::: details answer

**聚集索引，又称为聚集索引，首先并不是一种索引类型，而是一种数据存储方式，即索引结构和数据一起存放。**

聚集索引的特点

1. 聚集索引的检索效率更高
2. 聚集索引的磁盘IO次数更少
3. 一个数据表只能有一个聚集索引
4. 一般而言，会在频繁使用、排序的字段上创建聚集索引

**非聚集索引即索引结构和数据分开存放，非聚集索引中并不存放真正的数据行，只包含一个指向数据行的指针。**

非聚簇索引的创建也是以此为根据的，分为**复合索引**和**覆盖索引**

![](https://cdn.jsdelivr.net/gh/River-Cold/vuepress-theme-hope-image/img/聚簇索引和非聚簇索引.png)

:::

## 事务管理

### 什么是数据库事务？

::: details answer

数据库的**事务**（Transaction）是一种机制、一个操作序列，包含了一组数据库操作命令，其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。

事务把所有的命令作为一个整体一起向系统提交或撤销操作请求，即这一组数据库命令要么都执行，要么都不执行，因此事务是一个不可分割的工作逻辑单元。如果任意一个操作失败，那么整组操作即为失败，会回到操作前状态或者上一个节点。

:::

### 有哪些事务状态？

::: details answer

事务在其生命周期中会经历不同的状态，这些状态被称为**事务状态**。

![](https://cdn.jsdelivr.net/gh/River-Cold/vuepress-theme-hope-image/img/事务状态.png)

[Transaction States in DBMS - GeeksforGeeks](https://www.geeksforgeeks.org/transaction-states-in-dbms/)

**活跃状态（Active State）**：事务的第一个状态，任何正在执行的事务都处于此状态，所做的**更改**存储在**主内存（本地）的缓冲区**中。

**部分提交状态（Partially Commited State）**：执行操作后，事务进入部分提交状态。之所以是部分提交，是因为所做的更改仍然在**主内存（本地）的缓冲区**中。

**失败状态（Failed State）**：如果事务在活动状态或者部分提交状态发生一些错误，并且事务无法进一步执行，则事务进入失败状态。

**中止状态（Aborted State）**：如果任何事务已达到失败状态，撤销失败事务对当前数据库造成的影响，恢复管理器将数据库回滚到开始执行的原始状态。

**提交状态（Commited State）**：如果所有操作成功执行，数据永久写入到磁盘上的数据库中，则来自部分提交状态的事务进入提交状态，无法从此状态回滚，它是一个新的**一致状态**。

:::

### 事务的四大特性？

::: details answer

事务具有4个特性：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability），这4个特性通常简称为ACID，**关系型数据库**需要遵循ACID规则。

**原子性：**事务是最小的执行单位，不可分割的（原子的）。事务的原子性确保动作要么全部执行，要么全部不执行。

**一致性：**事务执行前后数据的完整性保持一致。

**隔离性：**并发访问数据库时，一个用户的事务不被其他事务所干扰，各个事务不干涉内部的数据。

**持久性：**一个事务被提交之后，对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。

:::

### 如何实现事务的ACID特性？

::: details answer

事务的ACID特性是由关系型数据库管理系统来实现的。

DBMS采用**日志**来保证事务的**原子性、一致性、持久性**。日志记录了事务对数据库所做的操作，如果某个事务在执行过程中发生错误，就可以根据日志，撤销事务对数据库已做的操作，使数据库退回到执行事务之前的初始状态。

DBMS采用**锁机制**来保证事务的隔离性。当多个事务同时更新数据库中相同的数据时，只允许**持有锁的事务**能更新该数据，其他事务必须等待，直到前一个事务释放了锁，其他事务才有机会更新该数据。

[深入学习MySQL事务：ACID特性的实现原理 - 编程迷思 - 博客园 (cnblogs.com)](https://www.cnblogs.com/kismetv/p/10331633.html)

:::

### 并发事务之间的相互影响

::: details answer

**脏读（Dirty Read）**：**A事务读取到了B事务还未提交的数据**。

**不可重复读（Non-repeatable Read）**：**A事务读取到了B事务提交的更改数据**。在一个事务范围内，两次相同的查询返回两个不同的数据，这是因为在此间隔内有其他事务对数据进行了修改并提交。

**幻读（Phantom Read）**：**A事务读取到了B事务提交的新增数据**。例如有一个事务对表中的数据进行了修改并提交，这种修改是向表中**插入一行新数据**。那么，当第一个事务的用户发现表中还有没有修改的数据行，就好像发生了幻觉一样。

**丢失更新（Lost Update）**：

**第一类丢失更新（回滚丢失，Lost update）**

A事务撤销时，把已经提交的B事务的更新数据覆盖了

**第二类丢失更新（覆盖丢失/两次更新问题，Second lost update）**

A事务覆盖B事务已经提交的数据，造成B事务所做操作丢失

两个事务同时读取同一条记录，事务A先修改记录，事务B也修改记录（B是不知道A修改过），当B提交数据后，其修改结果覆盖了A的修改结果，导致事务A更新丢失。

不可重复读的重点是修改，幻读的重点在于新增或删除。

:::

### 什么是事务的隔离级别？

::: details answer

读取未提交（READ-UNCOMMITTED）

读取已提交（READ-COMMITTED）

可重复读（REPEATABLE-READ）

可串行化（SERIALIZABLE）

| 隔离级别   | 脏读 | 不可重复读 | 幻读 |
| ---------- | ---- | ---------- | ---- |
| 读取未提交 | 是   | 是         | 是   |
| 读取已提交 | 否   | 是         | 是   |
| 可重复读   | 否   | 否         | 是   |
| 可串行化   | 否   | 否         | 否   |

:::

## 锁

### 锁的分类

::: details answer

从数据库系统角度分为三种：

**共享锁（S）**：又叫**读锁**。可以并发读取数据，但不能修改数据。也就是说当数据资源上存在共享锁时，所有的事务都不能对该数据进行修改（不能加排他锁），直到数据读取完成，共享锁释放。

**排他锁（X）**：又叫**独占锁、写锁**。对数据资源进行增删改时，不允许其他事务操作这块资源（读取或修改），直到排他锁被释放，从而防止同时对同一资源进行多重操作。

**更新锁（U）**：防止出现**死锁**的锁模式。两个事务对一个数据资源进行先读取再修改的情况下，使用共享锁和排他锁有时会出现死锁现象，而使用更新锁就可以避免死锁的出现。

**死锁**：如果有两个或多个事务同时对一个数据资源申请了共享锁，在修改数据时，这些事务都要将共享锁升级为排他锁。这时，这些事务都不会释放共享锁，而是一直等待对方释放，这样就造成了死锁。

:::

### 什么是死锁？如何解决死锁？

::: details answer

死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。

1. 不同的程序并发存取多个表，尽量约定以**相同的顺序访问表**。

2. 在同一个事务中，尽可能做到**一次锁定事务所需要的所有资源**。

3. 对于非常容易产生死锁的业务部分，可以尝试**升级锁定粒度**，设置**表级锁**。

:::

## 常用SQL语句

### SQL语句主要分为哪些类别？

::: details answer

1. 数据定义语言DDL（Data Definition Language）：例如`CREATE`，`DROP`，`ALTER`等，对逻辑结构有操作的，其中包括表结构，视图和索引。
2. 数据查询语言DQL（Data Query Language）：即查询操作，以`SELECT`为主，各种简单查询、连接查询都属于DQL
3. 数据操作语言DML（Data Manipulation Lanuage）：例如`INSERT`、`UPDATE`、`DELETE`等，对数据进行操作的。DQL和DML共同构建了常用的**增删改查**操作。
4. 数据控制语言DCL（Data Control Language）：例如`GRANT`、`REVOKE`、`COMMIT`、`ROLLBACK`等，对数据库安全性、完整性等有操作的，可以简单的理解为权限控制等。

:::

### 什么是元组？键？超键？候选键？主键？外键？主属性？非主属性？

::: details answer

**元组**：元组（tuple）是关系数据库中的基本概念，关系是一张表，表中的每行（即数据库中的每条记录）就是一个元组。在二维表中，元组也称为行。

**键**：能唯一标识元组的属性，对应表中的列

**超键：**在关系中，能唯一标识元组的属性集称为关系模式的超键。一个属性可以作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。

**候选键：**是最小超键，即没有冗余元素的超键。

**主键：**主关键字（主键，Primary key）是中被挑选出来的候选键，作为表的行的唯一标识。主键不能有重复，不能为空（NULL）。

**外键：**在一个表（关系）中存在的另一个表（关系）的主键称为此表的外键，外键可以有重复的，可以是空值。外键是用来和其他表建立联系用的。

**主属性**：候选键中出现过的属性称为主属性。

**非主属性**：不包含在任何一个候选键中的属性称为非主属性。

:::

### 主键和外键有什么区别？

::: details answer

**主键**：主键用于唯一标识一个元组，不能有重复，不允许为空。一个表只能有一个主键。

**外键**：外键用于和其他表建立联系用，外键是另一表的主键，外键是可以有重复的，可以是空值。一个表可以有多个外键。

:::

### char和varchar的区别？

::: details answer

1. char表示定长字符串，长度是固定的，最多能存放的字符个数为255；varchar表示可变长字符串，长度是可变的，最多能存放的字符个数为65532

2. 使用char时，如果插入数据的长度小于char的固定长度时，用空格填充
3. char的存取速度比varchar快很多，缺点是会占用多余空间，属于以空间换时间

:::

### SQL约束有哪几种类型

::: details answer

约束是一种简单地强加于表中一列或多列（字段）的限制，从而保证表中数据一致性（准确和可靠）。以下为六大约束：

- **非空约束（NOT NULL）**：保证字段不为空
- **唯一约束（UNIQUE）**：限制一列或多列的值，保证字段值在表内的唯一性，可以为空（主键约束是一种特殊类型的唯一约束）
- **主键约束（PRIMARY KEY）**：标志一列或多列，保证其值在表中的唯一性，不能为空，相当于非空约束和唯一约束的组合
- **外键约束（FOREIGN KEY）**：限制一列或多列中的值必须被包含在另一表的外键列中，并且在级联更新或级联删除规则建立后也可以限制其他表中的可用值
- **默认约束（DEFAULT）**：保证字段有默认值
- **检查约束（CHECK）**：限制一列的可用值范围

:::

### 有哪些关联查询？

::: details answer

**交叉连接（CROSS JOIN）**

- 返回被连接的两个表所有数据行的**笛卡尔积**，返回的数据行数等于第一个表中符合查询条件的数据行数**乘以**第二个表中符合查询条件的数据行数，以下两个表达式等价：
  - `SELECT  *  FROM  A, B`
  - `SELECT  *  FROM  A  CROSS JOIN  B`

**内连接（INNER JOIN）**

- 等值连接

  - `ON A.id=B.id`

- 不等值连接

  - `ON A.id > B.id`

- 自连接

  - `SELECT * FROM A T1 INNER JOIN A T2 ON T1.id=T2.id`

- 外连接（LEFT JOIN/RIGHT JOIN）

  - 左外连接

    - 以左表为主，先查询出左表，按照`ON`后的关联条件匹配右表，没有匹配到的用`NULL`填充，可以简写成`LEFT JOIN`

  - 右外连接

    - 以左表为主，先查询出右表，按照`ON`后的关联条件匹配左表，没有匹配到的用`NULL`填充，可以简写成`RIGHT JOIN`

**全连接（FULL JOIN）**

**联合查询（UNION与UNION ALL）**

  - `SELECT  * FROM A UNION SELECT * FROM B UNION ...`

:::

### 什么是子查询？

::: details answer

多条MySQL语句嵌套使用时，内部的MySQL查询语句称为子查询。

子查询是一个`SELECT`语句，它嵌套在另一个`SELECT`、`SELECT...INTO`、`INSERT...INTO`、`DELETE`、`UPDATE`语句或嵌套在另一子查询中。

:::

### DROP、DELETE与TRUNCATE的区别？

> 用法不同、属于不同的数据库语言、执行速度不同

::: details answer

drop（丢弃数据）

属于DDL语言，`drop table 表名`删除整张表，不保留表的结构（定义），不能回滚，删除速度快。

truncate（清空数据）

属于DDL语言，`truncate table 表名`保留表的结构（定义）但删除表的所有数据，不能回滚，删除速度快

delete（删除数据）

属于DML语言，`delete from 表名 where 列名=值`删除表的部分数据行，如果不加`where`子句和`truncate table 表名`作用类似，可以回滚，删除速度慢

:::

### UNION和UNION ALL的区别？

::: details answer

`UNION`和`UNION ALL`用于把来自多个`SELECT`语句的结果组合到一个结果集合中，`UNION`会把结果集合中重复的记录行删掉只保留一行，使用`UNION ALL`则会将所有记录返回，效率高于`UNION`。

:::

## 参考文献

[(37条消息) 死锁，更新锁，共享锁，排它锁，意向锁，乐观锁，悲观锁等名词解释及案例详解_trusause的博客-CSDN博客](https://blog.csdn.net/trusause/article/details/79487807)

[级联更新_百度百科 (baidu.com)](https://baike.baidu.com/item/级联更新/11036500?fr=aladdin.)

[检查约束_百度百科 (baidu.com)](https://baike.baidu.com/item/检查约束/10272981?fr=aladdin)

